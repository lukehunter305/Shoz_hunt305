<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Java</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; line-height: 1.6; background-color: #f4f4f4; }
        h1 { color: #fff; text-align: center; background-color: #3498db; padding: 15px; border-radius: 8px; }
        .question { font-weight: bold; margin-top: 20px; color: #000; background-color: yellow; padding: 10px; border-radius: 5px; }
        p { background: white; padding: 10px; border-radius: 5px; color: green; font-weight: bold; }
    </style>
</head>
<body>
    <h1>Paper-1</h1>
    
    <div class="question">Q1. What is Java?</div>
    <p>Java is a high-level, class-based, object-oriented programming language that is designed to have as few implementation dependencies as possible. It is a widely used language for developing applications for web, mobile, and desktop platforms.</p>
    
    <div class="question">Q2. What are the features of Java?</div>
    <p>Key features of Java include platform independence, object-orientation, security, robustness, simplicity, multithreading support, and garbage collection.</p>
    
    <div class="question">Q3. What is JVM and why is it important?</div>
    <p>JVM stands for Java Virtual Machine, which is the part of the Java Run-time Environment that executes Java byte code. It is important because it provides a platform-independent way of executing Java code.</p>
    
    <div class="question">Q4. What is the difference between JDK, JRE, and JVM?</div>
    <p>JDK (Java Development Kit) is the full software development kit required to develop Java applications, JRE (Java Runtime Environment) is a subset of JDK that is required to run Java applications, and JVM (Java Virtual Machine) is the component of JRE that executes Java bytecode.</p>
    
    <div class="question">Q5. What is the use of the public static void main(String[] args) method?</div>
    <p>This method is the entry point for any Java application. It is the method called by the JVM to run the program.</p>
    
    <div class="question">Q6. Explain the concept of Object-Oriented Programming in Java.</div>
    <p>Object-Oriented Programming (OOP) in Java is a programming paradigm based on the concept of "objects", which can contain data in the form of fields (attributes) and code in the form of procedures (methods). Java uses OOP principles including inheritance, encapsulation, polymorphism, and abstraction.</p>
    
    <div class="question">Q7. What is inheritance in Java?</div>
    <p>Inheritance is a fundamental OOP concept where one class can inherit fields and methods from another class. In Java, inheritance is achieved using the extends keyword.</p>
    
    <div class="question">Q8. What is polymorphism in Java?</div>
    <p>Polymorphism in Java is the ability of an object to take on many forms. It is typically achieved through method overriding and method overloading.</p>
    
    <div class="question">Q9. Explain encapsulation with an example in Java.</div>
    <p>Encapsulation in Java is the bundling of data (variables) and methods that operate on the data into a single unit, or class, and restricting access to some of the object's components. This is usually done by making fields private and providing public getter and setter methods.</p>
    
    <div class="question">Q10. What is an interface in Java?</div>
    <p>An interface in Java is a reference type, similar to a class, that can contain only constants, method signatures, default methods, static methods, and nested types. Interfaces cannot contain instance fields. The methods in interfaces are abstract by default.</p>
    
    <div class="question">Q11. Explain the concept of an abstract class.</div>
    <p>An abstract class in Java is a class that cannot be instantiated and may contain abstract methods, which do not have an implementation and must be implemented in subclasses.</p>
    
    <div class="question">Q12. What are constructors in Java?</div>
    <p>Constructors in Java are special methods used to initialize objects. The constructor is called when an object of a class is created and has the same name as the class.</p>
    
    <div class="question">Q13. What is method overloading?</div>
    <p>Method overloading is a feature in Java that allows a class to have more than one method having the same name, if their parameter lists are different. It is a way of implementing compile-time polymorphism.</p>
    
    <div class="question">Q14. What is method overriding?</div>
    <p>Method overriding, in Java, is a feature that allows a subclass to provide a specific implementation of a method that is already provided by one of its super-classes or parent classes.</p>
    
    <div class="question">Q15. What is a package in Java?</div>
    <p>In Java, a package is a namespace that organizes a set of related classes and interfaces. Conceptually, packages are similar to different folders on your computer.</p>
    
    <div class="question">Q16. Explain the final keyword in Java.</div>
    <p>The final keyword in Java can be used to mark a variable as constant (not changeable), a method as not overrideable, or a class as not inheritable.</p>
    
    <div class="question">Q17. What are Java Exceptions?</div>
    <p>Exceptions in Java are events that disrupt the normal flow of the program. They are objects that wrap an error event that occurred within a method and are either caught or propagated further up the calling chain.</p>
    
    <div class="question">Q18. What is the difference between checked and unchecked exceptions?</div>
    <p>Checked exceptions are exceptions that are checked at compile-time, meaning that the code must handle or declare them. Unchecked exceptions are checked at runtime, meaning they can be thrown without being caught or declared.</p>
    
    <div class="question">Q19. What is the static keyword used for in Java?</div>
    <p>The static keyword in Java is used to indicate that a particular field, method, or block of code belongs to the class, rather than instances of the class. Static members are shared among all instances of a class.</p>
    
    <div class="question">Q20. What is a thread in Java?</div>
    <p>A thread in Java is a lightweight process that allows concurrent execution of code. Java provides built-in support for multithreading using the Thread class and Runnable interface.</p>
    
    <div class="question">Q21. What is the difference between == and .equals()?</div>
    <p>The == operator compares memory addresses, while the .equals() method checks for value equality in objects.</p>
    
    <div class="question">Q22. What is garbage collection in Java?</div>
    <p>Garbage collection in Java is an automatic memory management process that removes unused objects to free up memory. The JVM performs garbage collection to avoid memory leaks.</p>
    
    <div class="question">Q23. What is the Collections Framework?</div>
    <p>The Collections Framework in Java is a set of classes and interfaces that provide data structures like Lists, Sets, and Maps for handling collections of objects.</p>
    
    <div class="question">Q24. Explain the synchronized keyword.</div>
    <p>The synchronized keyword in Java is used to control access to critical sections of code by multiple threads, preventing race conditions.</p>
    
    <div class="question">Q25. What are generics in Java?</div>
    <p>Generics allow the creation of classes, interfaces, and methods with type parameters to provide type safety and code reusability.</p>
    
    <div class="question">Q26. What is the this keyword in Java?</div>
    <p>The this keyword in Java refers to the current instance of a class and is used to access instance variables and methods.</p>
    
    <div class="question">Q27. What is an Enum in Java?</div>
    <p>An Enum in Java is a special data type that defines a fixed set of constants.</p>
    
    <div class="question">Q28. What is multithreading in Java?</div>
    <p>Multithreading in Java allows multiple threads to run simultaneously, improving efficiency and performance.</p>
    
    <div class="question">Q29. Explain the volatile keyword in Java.</div>
    <p>The volatile keyword ensures that a variable is read directly from memory rather than from a thread's local cache, ensuring visibility across multiple threads.</p>
    
    <div class="question">Q30. Explain volatile keyword in Java.</div>
    <p>The volatile keyword in Java is used to indicate that a variable's value will be modified by different threads. Declaring a variable volatile ensures that its value is read from the main memory and not from the thread's cache memory.</p>


    <h1 style="background-color: blue;">Paper 2</h1>

<p><b>Can you tell me the difference between JVM, JRE, and JDK?</b></p>
<p>The JVM is the engine that runs Java bytecode and making Java platform-independent. The JRE contains the JVM and the standard libraries that Java programs need to run. The JDK is development kit for developers that contains everything in the JRE plus tools like compilers and debuggers to create Java applications.</p>
<p><b>What are the key components of JVM Architecture?</b></p>
<p>JVM has three components, the ClassLoader, the runtime data areas and the execution engine.
The Class Loader loads class files into the JVM. The Runtime Data Areas store data needed while the program runs, like memory for variables and code. The Execution Engine actually runs the instructions in the class files.</p>
<p><b>Can a Java application be run without installing the JRE?</b></p>
<p>We can't run a Java application without having the JRE (Java Runtime Environment) because it has the essential tools and libraries the application needs to work. But, there's a cool tool called jlink in newer Java versions that lets us bundle our Java application with its own little version of the JRE</p>
<p><b>Is it possible to have the JDK installed without having the JRE?</b></p>
<p>No, the JDK contains the JRE. It's not possible to have a JDK without a JRE, as the JRE contains essential components for running Java applications, which the JDK also uses for development.</p>

<p><b>What are Memory storages available with JVM?</b></p>
<p>JVM memory is divided into Heap Space, Stack Memory, Method Area (Metaspace in Java 8 and above), and Native Method Stacks.
Heap space in Java is where the program stores objects and data that it creates and shares.
Stack memory is used for keeping track of what happens inside each function call, including variable values.
The Method Area, or Metaspace in newer Java versions, stores information about the program's classes, like methods and constants.
</p>
<p><b>Which is faster to access between heap and stack, and why?</b></p>
The stack is faster to access because it stores method calls and local variables in a Last-In-First-Out (LIFO) structure. The heap, used for dynamic memory allocation (objects), is slower due to its more complex management.

<p><b>How does garbage collection work in Java?</b></p>
<p>Garbage collection in Java automatically frees memory by removing objects that are no longer used. It frees the memory by unused objects, making space for new objects.</p>

<p><b>Whats the role of finalized() method in garbage collection?</b></p>
<p>The finalize() method is called by the garbage collector on an object when it determines that there are no more references to the object. It's meant to give the object a chance to clean up resources before it's collected, such as closing file streams or releasing network connections.
</p>
	<p><b>Can you tell me what algorithm JVM uses for garbage collection?</b></p>
<p>JVM uses multiple garbage collection algorithms such as Mark-Sweep, Mark- Compact, and Generational Copying, depending on the collector chosen
</p>
<p><b>How can memory leaks occur in Java even we have automatic garbage collection?</b></b>
<p>Memory leaks in Java occur when objects are no longer needed but still referenced from other reachable objects, and hence preventing the garbage collector from reclaiming their memory.
</p>

<b><p>Java Fundamentals</b></p>

<p><b>Is java 100% object oriented programming language ?</b></p>
No, Java is not considered 100% object-oriented because it uses primitive types (like int, char, etc.) that are not objects. In a fully object-oriented language, everything is treated as an object.
<p><b>What are the advantages of Java being partially object-oriented?</b></p>
1.	Using simple, non-object types like integers and booleans helps Java run faster and use less memory.
2.	The mix of features allows Java to work well with other technologies and systems, which might not be fully object-oriented.
<p><b>What is the use of object-oriented programming languages in the enterprise projects?</b></p>



 
Object-oriented programming (OOP) is used in big projects to make coding easier to handle. It helps organize code better, makes it easier to update and scale, and lets programmers reuse code, saving time and effort.

<p><b>Explain public static void main(string args[])?</b></p>
In Java, public static void main(String[] args) is the entry point of any standalone Java application.

public makes this method accessible from anywhere, static means I don't need
to create an object to call this method, void means it doesn't return any value, and main is the name of this method.

The String[] args part is an array that holds any command-line arguments passed to the program. So, when I run a Java program, this is the first method that gets called
<p><b>What will happen if we declare don’t declare the main as static?</b></p>
If I don't declare the main method as static in a Java program, the JVM won't be able to launch the application.
As aresult, the program will compile, but it will fail to run, giving an error like "Main method is not static in class myClass, please define the main method as: public static void main(String[] args)."
<p><b>Can we override the main method?</b></p>
No, we cannot override main method of java because a static method cannot be overridden.
The static method in java is associated with class whereas the non-static method is
associated with an object. Static belongs to the class area, static methods don’t need an
object to be called.
<p><b>Can we oveload the main method?</b></p>
Yes, We can overload the main method in java by just changing its argument
<p><b>Can JVM execute our overloaded main method ?</b></p>
No, JVM only calls the original main method, it will never call our overloaded main method.


<p><b>Whats the difference between primitive data types and non primitive data types ?</b></p>
 Primitive data types in Java are the basic types of data predefined by the language and named by a keyword. They have a fixed size and are not objects. Examples include int, double, char, and boolean.
Non-primitive data types, on the other hand, are objects and classes that are not defined by Java itself but rather by the programmer or the Java API. They can be used to call methods

 
to perform certain operations, and their size is not fixed. Examples include String, arrays, and any class instances.
<p><b>Can primitive data types be NULL ?</b></p>
No, primitive data types in Java cannot be null. They have default values (e.g., 0 for int, false for boolean, 0.0 for double) and must always have a value.
<p><b>Can we declare pointer in java ?</b></p>
No, Java doesn’t provide the support of Pointer. As Java needed to be more secure
because which feature of the pointer is not provided in Java.
<p><b>What is the difference between == and .equals() in Java?</b></p>
== compares object references (whether two references point to the same object), while equals() compares object content (whether two objects are logically equal).

<p><b>What are wrapper classes?</b></p>
In Java, a wrapper class is an object that encapsulates a primitive data type. It allows primitives to be treated as objects. Each primitive data type has a corresponding wrapper class (e.g., Integer for int, Double for double).
<p><b>Why do we need wrapper classes?</b></p>
1.	Wrapper classes are final and immutable
2.	Provides methods like valueOf(), parseInt(), etc.
3.	It provides the feature of autoboxing and unboxing.
<p><b>Why we use wrapper class in collections</b></p>
Because Java collections, such as ArrayList, HashMap, and others in the Java Collections Framework, can only hold objects and not primitive types. Wrapper classes allow primitive values to be treated as objects, enabling them to be stored and managed within these collections.


<p><b>Can you explain the difference between unboxing and autoboxing in Java?</b></p>
Autoboxing automatically converts a primitive type (like int) to its corresponding wrapper class (Integer). Unboxing does the reverse, converting an Integer back to an int.

<p><b>Can you provide an example where autoboxing could lead to unexpected behavior?</b></p>
When comparing two Integer instances using ==, autoboxing might lead to false results because it compares object references, not values, for integers outside the cache range of -128 to 127.
<p><b>Is there a scenario where autoboxing and unboxing could cause a NullPointerException?</b></p>


 
A NullPointerException can occur if you unbox a null object; for example, assigning null to an Integer and then using it in a context where an int is expected.

<p><b>Can you explain the role of each try, catch, and finally block in exception handling?</b></p>
try block conatins code that might throw exceptions. catch handles those exceptions. finally executes code after try/catch, regardless of an exception, typically for cleanup.

<p><b>What happens if a return statement is executed inside the try or catch block? Does the finally block still execute?</b></p>
The finally block executes even if a return statement is used in the try or catch block, ensuring cleanup runs.

<p><b>Is it possible to execute a program without a catch block? If so, how would you use try and finally together?</b></p>
Yes, we can use try with finally without a catch block to ensure cleanup occurs even if we allow the exception to propagate up.
<p><b>How does exception handling with try-catch-finally affect the performance of a Java application?</b></p>
Using try-catch-finally can affect performance slightly due to overhead of managing exceptions but is generally minimal unless exceptions are thrown frequently.

<p><b>Can you tell me a condition where the finally block will not be executed?</b></p>
The finally block will not execute if the JVM exits via System.exit() during try or catch execution.
<p><b>Can we write multiple finally blocks in Java?</b></p>
No, each try can only have one finally block. Multiple finally blocks are not allowed within a single try-catch-finally structure.
<p><b>What is the exception and the differences between checked and unchecked exceptions?</b></p>
Exception is the unwanted even that occurs during the execution of program and disrupts the flow.
Checked exceptions must be declared or handled (IOException); unchecked do not need to be declared or caught (NullPointerException).
<p><b>How would you handle multiple exceptions in a single catch block</b></p>
Use a single catch block for multiple exceptions by separating them with a pipe (|), e.g., catch (IOException | SQLException e), to handle both exceptions with the same logic.
<p><b>What is the difference between a Throwable and an Exception in Java?</b></p>
 Throwable is the superclass for all errors and exceptions. Exception is a subclass of Throwable representing recoverable conditions, while Error (another subclass) represents serious issues the application should not attempt to recover from.

 
<p><b>Discuss the difference between finalize() and finally. Under what circumstances might finalize() not get called in a Java application?</b></p>
finalize() is called by the garbage collector before an object is destroyed, while finally is used in a try-catch block to execute code regardless of exceptions. finalize() may not get called if the garbage collector doesn't run or the JVM shuts down.


<p><b>What is string pool?</b></p>
A Java String Pool is a place in heap memory where all the strings defined in the program are stored. Whenever we create a new string object, JVM checks for the presence of the object in the String pool, If String is available in the pool, the same object reference is shared with the variable, else a new object is created.

<p><b>Are there any scenarios where using the string pool might not be beneficial?</b></p>
 It will not be beneficial when there are a lot of uique string because it will be complex situate to check each string.

<p><b>Can you please tell me about String and string buffer?</b></p>
'String; in Java is immutable, meaning once created, its value cannot be changed. 'StringBuffer' is mutable, allowing for modification of its contents and is thread-safe, making it suitable for use in multithreaded environments where strings need to be altered.

<p><b>How does StringBuilder differ from StringBuffer, and when should each be used? </b></p>
StringBuilder is similar to StringBuffer but is not thread-safe, making it faster for single-threaded scenarios.

<p><b>Give a scenario where StringBuffer is better than the String?</b></p>
A scenario where StringBuffer is more appropriate than String is in a multi-threaded server application where multiple threads modify a shared string, such as constructing a complex log entry concurrently from different threads.
<p><b>What is the difference between a String literal and a String object?</b></p>
A String literal is stored in the String pool for reusability. A String object, created using new String(), is stored in the heap, even if it has the same value as a literal.

<p><b>Why is String immutable?</b></p>
String is immutable to improve security, caching, and performance by ensuring that its value cannot be changed once created.

<p><b>What are the packages in Java?</b></p>
In Java, packages are namespaces that organize classes and interfaces into groups, preventing naming conflicts and managing access control. They provide a structured way to manage Java code, allowing related classes to be grouped together logically.


 
<p><b>Why packages are used?</b></p>
1.	They help in organizing code
2.	Packages prevent naming conflicts by providing a unique namespace
3.	Packages support modularity by allowing developers to separate the program
4.	Organizing classes into packages makes it easier to locate related classes


Object Oriented Programming Concepts


<p><b>What are access modifies in java?</b></p>
ava uses public, protected, default (no modifier), and private to control access to classes, methods, and fields, ensuring appropriate visibility and encapsulation.
<p><b>Can you provide examples of when to use each type of access modifier?</b></p>
1.	Public: Used when members should be accessible from any other class.
2.	Protected: Ideal for members that should be accessible to subclasses and classes within the same package.
3.	Default: Use when members should be accessible only within the same package.
4.	Private: Best for members intended only for use within their own class.

<p><b>Why do we use getters setter when we can make fields publick and setting getting directly?</b></p>
Using getters and setters instead of public variables allows us to control how values are set and accessed, add validation, and keep the ability to change how data is stored without affecting other parts of your program.
<p><b>Can a top-level class be private or protected in Java?</b></p>
No, a top-level class cannot be private or protected because it restricts access, making it unusable from any other classes, contrary to the purpose of a top-level class.


<p><b>Explain the concepts of classes and objects in Java.</b></p>
Classes are blueprints for objects in Java, defining the state and behavior that the objects of the class can have. Objects are instances of classes, representing entities with states and behaviors defined by their class.
<p><b>What are the ways to create an object?</b></p>
1.	Using the new Keyword, example: MyClass object = new MyClass();


 
2.	Using Class Factory Methods, example: Calendar calendar = Calendar.getInstance();
3.	Using the clone()
<p><b>Can a class in Java be without any methods or fields?</b></p>
Yes, a class in Java can be declared without any methods or fields. Such a class can still be used to create objects, although these objects would have no specific behavior or state
<p><b>What are the methods available in the Object class, and how are they used?</b></p>
The key methods are equals(), hashCode(), toString(), clone(), finalize(), wait(), notify(), and notifyAll(). These provide basic operations like equality checks, memory management, and thread coordination.

<p><b>What are anonymous classes and their advantages?</b></p>
Anonymous classes in Java are classes without a name, defined and instantiated in one place. They are useful when you need to create a subclass or implement an interface for a one-time use. The advantages include reduced boilerplate code, encapsulation of specific functionality, and the ability to override methods on the fly. This results in more compact and localized code, particularly in scenarios like event handling or passing behavior as an argument.

<p><b>What is Singleton Class?</b></p>
A singleton class in Java is a special class that can have only one instance (or object) at any time. It's like having only one key of the room. This is useful when we want to make sure there's just one shared resource, like a configuration setting or a connection to a database.

<p><b>How can we create this singleton class?</b></p>
In order to make singleton class, first we have a to make a constructor as private, next we have to create a private static instance of the class and finally we have to provide static method instance so that’s how we can create the singleton class
<p><b>Are these threads safe?</b></p>
Singleton classes are not thread-safe by default. If multiple threads try to create an instance at the same time, it could result in multiple instances. To prevent this, we can synchronize the method that creates the instance or use a static initializer


<p><b>What is a constructor in Java?</b></p>
A constructor in Java is a special method used to initialize new objects. It has the same name as the class and may take arguments to set initial values for the object's attributes.

<p><b>Can we use a private constructor?</b></p>
Yes, we can use private constructors in Java. They are mostly used in classes that provide static methods or contain only static fields. A common use is in the Singleton design pattern, where the goal is to limit the class to only one object.

 
<p><b>Can constructor be overloaded?</b></p>
Yes, you can have multiple constructors in a Java class, each with a different set of parameters. This lets you create objects in various ways depending on what information you have at the time.

<p><b>What is immutability mean in Java?</b></p>
Immutability in Java means that once an object's state is created, it cannot be changed.

<p><b>Why immutable objects are useful for concorrent programming?</b></p>
These are useful in concurrent programming because they can be shared between threads without needing synchronization.

<p><b>What are immutable classes?</b></p>
Immutable classes in Java are classes whose objects cannot be modified after they are created. This means all their fields are final and set only once, typically through the constructor.
<p><b>How can we create immutable class?</b></p>
1.	Declare the class as final so it can’t be extended.
2.	Make all of the fields final and private so that direct access is not allowed.
3.	Don’t provide setter methods for variables
4.	Initialize all fields using a constructor method


<p><b>What does Java's inheritance mean?</b></p>
Inheritance in Java means a class can use the features of another class. This helps to reuse code and make things simpler.
<p><b>Can a class extends on its own</b></p>
No, a class in Java cannot extend itself. If it tries, it will cause an error
<p><b>Why multiple inheritance is not possible in java?</b></p>
Java avoids using multiple inheritance because it can make things complicated, such as when two parent classes have methods that conflict.

<p><b>What is the difference between inheritance and composition?</b></p>
Inheritance is when one class gets its features from another class. Composition is when a class is made using parts from other classes, which can be more flexible.
<p><b>Discuss the principle of "composition over inheritance".</b></p>
	Provide an example where this principle should be applied in Java application design.
"Composition over inheritance" means using objects within other objects
(composition) instead of inheriting from a parent class. It’s applied when classes

 
have a "has-a" relationship. For example, a Car class can have an Engine class as a field rather than inheriting from an Engine.
<p><b>What is the difference between association, aggregation, and composition in Java?</b></p>
 Association is a general relationship between two classes. Aggregation is a weak association (has-a) where the child can exist independently of the parent.
Composition is a strong association where the child cannot exist without the parent.

<p><b>Explain the IS-A (inheritance) and Has-A (composition) relationships in Java.</b></p>
IS-A refers to inheritance, where a subclass is a type of the superclass. Has-A refers to composition, where a class contains references to other classes as fields.
<p><b>What does mean by polymorphism in Java?</b></p>
Polymorphism in Java means that the same piece of code can do different things depending on what kind of object it's dealing with. For example, if you have a method called "draw," it might make a circle for a Circle object and a square for a Square object.

<p><b>How does method overloading relate to polymorphism?</b></p>
Method overloading is using the same method name with different inputs in the same class. It's a simple way to use polymorphism when you're writing your code.
<p><b>What is dynamic method dispatch in Java?</b></p>
Dynamic method dispatch is a way Java decides which method to use at runtime when methods are overridden in subclasses. It ensures the correct method is used based on the type of object.

<p><b>Can constructors be polymorphic?</b></p>
No, constructors cannot be polymorphic. We can have many constructors in a class with different inputs, but they don’t behave differently based on the object type like methods do.

<p><b>What does mean by abstraction in java?</b></p>
Abstraction in Java means focusing on what needs to be done, not how to do it. You create a kind of blueprint that tells other parts of the program what actions they can perform without explaining the details.

<p><b>Can you provide examples of where abstraction is effectively used in Java libraries?</b></p>
 Java uses abstraction in its collection tools. For example, when you use a List, you don't need to know how it stores data, whether as an ArrayList or a LinkedList.
<p><b>What happens if a class includes an abstract method?</b></p>
A class with an abstract method must itself be abstract. We can't create objects directly from an abstract class; it's meant to be a blueprint for other classes.
<p><b>How does abstraction help in achieving loose coupling in software applications?</b></p>


 
Abstraction lets us hide complex details and only show what's necessary. This makes it easier to change parts of your program without affecting others, keeping different parts independent and easier to manage.

<p><b>What is interface in Java?</b></p>
interface is like a blueprint for a class. It defines a set of methods that the class must implement, without specifying how these methods should work

<p><b>What is the difference between an interface and an abstract class in Java?</b></p>
 abstract class achieves partial abstraction (0 to 100%) whereas interface achieves fully abstraction. Abstract class can have abstract and non-abstract methods
whereas Interface can have only abstract methods. (Since Java 8, it can have default and static methods also.)
<p><b>Can you provide examples of when to use an interface versus when to extend a class?</b></p>
Use an interface when we want to list the methods a class should have, without detailing how they work. Use class extension when we want a new class to inherit features and behaviors from an existing class and possibly modify them.
<p><b>How do you use multiple inheritance in Java using interfaces?</b></p>
In Java, we can't inherit features from multiple classes directly, but we can use interfaces for a similar effect. A class can follow the guidelines of many interfaces at once, which lets it combine many sets of capabilities.
<p><b>Can an interface in Java contain static methods, and if so, how can they be used?</b></p>
 Yes, interfaces in Java can have static methods, which you can use without creating an instance of the class.

<p><b>When would you use an interface, and when would you use an abstract class?</b></p>
 Use an interface when you need multiple classes to share a contract without implementation. Use an abstract class when you need shared behavior (method implementations) along with method declarations.
<p><b>Explain the difference between Comparable and Comparator interfaces. When would you use one over the other?</b></p>
Comparable is used for natural ordering and is implemented by the class itself, while Comparator is used for custom ordering and can be implemented externally. Use Comparable when objects have a single logical ordering; use Comparator when you need multiple ways to order objects.
<p><b>What is a static method in an Interface, and how is it different from a default method in an interface?</b></p>
A static method in an interface belongs to the interface itself and cannot be overridden. A default method provides a default implementation for classes that implement the interface, and it can be overridden.
 
<p><b>What is the diamond problem in Java and how does Java address it?</b></p>
The diamond problem occurs in multiple inheritance where a class inherits from two classes with a common ancestor. Java resolves this by not allowing multiple inheritance with classes, but interfaces can use default methods to avoid this issue.
<p><b>How does the concept of default methods in interfaces help resolve the diamond problem?</b></p>
Default methods allow interfaces to provide method implementations, and in case of conflicts (multiple interfaces with the same default method), the implementing class must override the method, resolving ambiguity.


<p><b>What does mean by encapsulation in java?</b></p>
Encapsulation in Java is like putting important information into a safe. We store data and the methods inside a class, and we control who can access or change the data by using specific methods.
<p><b>How Encapsulation Enhances Software Security and Integrity:</b></p>
Encapsulation keeps important data hidden and safe. It only lets certain parts of our program use this data, which helps prevent mistakes and keeps the data secure from unwanted changes.

<p><b>What is the concept of Serialization in Java?</b></p>
Serialization is the process of converting an object into a byte stream for storage or transmission. It allows objects to be saved and restored later or transferred over a network.
<p><b>What is the purpose of the serialVersionUID in Java serialization?</b></p>
The serialVersionUID is a unique identifier for Serializable classes. It ensures that the serialized and deserialized objects are compatible by checking version consistency. If the serialVersionUID of the class doesn’t match during deserialization, an InvalidClassException is thrown, preventing incompatible class versions from being used.
<p><b>What happens if the serialVersionUID of a class changes during deserialization?</b></p>
 If the serialVersionUID changes between serialization and deserialization, the JVM considers the class as incompatible with the serialized object. This results in an InvalidClassException, as the runtime expects the version of the serialized class to match with the version defined in the deserialized class.

<p><b>How can you prevent certain fields from being serialized in Java</b></p>
You can prevent specific fields from being serialized by marking them with the transient keyword. When a field is declared as transient, it is excluded from the serialization process, meaning its value will not be saved when the object is serialized.
<p><b>Can a class be serialized if one of its member fields is not serializable?</b></p>

 
A class can still be serialized even if one of its member fields is not serializable. However, you must mark the non-serializable field as transient. If the field is not transient and is not serializable, attempting to serialize the object will result in a NotSerializableException.
<p><b>What is the difference between writeObject() and readObject() methods in Java serialization?</b></p>
The writeObject() and readObject() methods allow customization of the serialization and deserialization processes. writeObject() is used to customize how an object is serialized, while readObject() customizes how it is deserialized. These methods can be overridden to handle complex scenarios, such as serializing transient fields or managing class versioning.

<p><b>Is it possible to serialize static fields in Java? Why or why not?</b></p>
No, static fields are not serialized in Java because they belong to the class, not to individual instances. Serialization is intended to capture the state of an object, and static fields are part of the class's state, not the object's state.
<p><b>How do you serialize an object with circular references in Java?</b></p>
Java handles circular references during serialization by keeping track of references that have already been serialized. When the same object reference appears again, Java writes a reference to the already serialized object rather than serializing it again. This prevents infinite recursion and maintains the object graph structure.


<p><b>What is method overloading in Java?</b></p>
Polymorphism in Java means that the same piece of code can do different things depending on what kind of object it's dealing with. For example, if you have a method called "draw," it might make a circle for a Circle object and a square for a Square object.
<p><b>How does the Java compiler determine which overloaded method to call?</b></p>
When we call an overloaded method, the Java compiler looks at the number and type of arguments you've provided and picks the method that matches these arguments best.
<p><b>Is it possible to overload methods that differ only by their return type in Java?</b></p>
In Java, we cannot overload methods just by changing their return type. The methods must differ by their parameters for overloading to be valid.

<p><b>What are the rules for method overloading in Java?</b></p>
The parameters must differ in how many there are, what type they are, or the order they are in.

<p><b>What is method overriding in Java?</b></p>



 
To override a method, the new method in the subclass must have the same name, return type, and parameters as the method in the parent class. Also, the new method should not be less accessible than the original.
<p><b>What are the rules and conditions for method overriding in Java?</b></p>
In Java, method overriding occurs when a subclass has a method with the same name, return type, and parameters as one in its parent class. The method in the subclass replaces the one in the parent class when called.

<p><b>How does the @Override annotation influence method overriding?</b></p>
The @Override annotation tells the compiler that the method is supposed to replace one from its superclass. It's useful because it helps find mistakes if the method does not actually override an existing method from the parent class.

<p><b>What happens if a superclass method is overridden by more than one subclass in Java?</b></p>
If different subclasses override the same method from a superclass, each subclass will have its own version of that method.
<p><b>What is 'this' and 'super' keyword in java?</b></p>
'this' is used to refer current class's instance as well as static members. 'super' keyword is used to access methods of the parent class.

<p><b>Can 'this' keyword be assigned a new value in Java?</b></p>
No, this keyword cannot be assigned a new value in Java. It is a read-only reference that always points to the current object.
<p><b>What happens if you attempt to use the "super" keyword in a class that doesn't have a superclass?</b></p>
If we attempt to use the "super" keyword in a class that doesn't have a superclass, a compilation error occurs. The "super" keyword is only applicable within subclasses to refer to members of the superclass.
<p><b>Can the this or super keyword be used in a static method?</b></p>
No, the this and super keyword cannot be used in static methods. Static methods belong to the class, not instances, and super refers to the superclass's object context, which does not exist in a static context.
<p><b>How does 'super' play a role in polymorphism ?</b></p>
In Java, the super keyword lets a subclass use methods from its parent class, helping it behave in different ways and that is nothing but a polymorphic behavior


<p><b>What is the static keyword in Java?</b></p>
The static keyword in Java is used to indicate that a particular member (variable or method) belongs to the class, rather than any instance of the class. This means that the static member can be accessed without creating an instance of the class.

 
<p><b>Can a static block throw an exception?</b></p>
Yes, a static block can throw an exception, but if it does, the exception must be handled within the block itself or declared using a throws clause in the class.
<p><b>Can we override static methods in Java?</b></p>
No, static methods cannot be overridden in Java because method overriding is based on dynamic binding at runtime and static methods are bound at compile time.

<p><b>Is it possible to access non-static members from within a static method?</b></p>
No, it's not possible to access non-static members (instance variables or methods) directly from within a static method. This is because static methods belong to the class itself, not to any specific instance. To access non-static members, you need to create an instance of the class and use that object to reference the non-static members.
<p><b>What is static block?</b></p>
To initialize static variables, the statements inside static block are executed only once, when the class is loaded in the memory.

<p><b>Can we print something on console without main method in java?</b></p>
Prior to Java 8, yes, we can print something without main method buts its not possible from java 8 onwards

<p><b>What is final keyword in java?</b></p>
the 'final' keyword is used to declare constants, making variables unchangeable once assigned, or to prevent method overriding or class inheritance
<p><b>What are some common use cases for using final variables in Java programming?</b></p>
 Common use cases for using final variables in Java programming include defining constants, parameters passed to methods, and local variables in lambdas or anonymous inner classes.
<p><b>How does the "final" keyword contribute to immutability and thread safety in Java?</b></p>
The "final" keyword contributes to immutability and thread safety in Java by ensuring that the value of a variable cannot be changed once assigned, preventing unintended modifications and potential concurrency issues.

<p><b>Can you describe any performance considerations related to using final?</b></p>
The final keyword improves the performance by reducing call overhead?

<p><b>What is functional interfaces?</b></p>



 
Functional interfaces in Java are interfaces with just one abstract method. They are used to create lambda expressions and instances of these interfaces can be created with lambdas, method references, or constructor references.
<p><b>Can functional interface extend another interface?</b></p>
No, as functional interface allows to have only single abstract method. However functional interface can inherit another interface if it contains only static and default methods in it

<p><b>Advantages of using a functional interface.</b></p>
Functional interfaces, which contain only one abstract method, are key to enabling functional programming in Java. They offer concise and readable code through lambda expressions and method references, improving code simplicity. Functional interfaces allow easy parallel processing, better abstraction, and reusability, especially in scenarios like streams and event handling, promoting a cleaner and more expressive programming style.


</b></p>Java 8 Basics</b></p>
<p><b>Can you tell me some new features that were introduced in Java 8?</b></p>
Lambda Expressions, Stream API, Method References , Default Methods , Optional Class, New Date-Time API are the new features that were introduced in java 8

<p><b>Why optional class, lambda expressions and stream API were introduced in java 8?</b></p>
 Optional class was introduced in Java 8 as a way to address the problem of null references
Lambda expressions were introduced in Java 8 to make it easier to write code for interfaces that have only one method, using a simpler and more direct style.
The Stream API was introduced in Java 8 to help developers process collections of data in a more straightforward and efficient way, especially for bulk operations like filtering or sorting.
<p><b>Difference between filter and map function of stream API?</b></p>
filter() eliminates elements of collection where the condition is not satisfied whereas map() is used to perform operation on all elements hence, it returns all elements of collection

<p><b>Can you tell me some new features that were introduced in Java 11?</b></p>
HTTP Client, Epsilon Garbage Collector, Z Garbage Collector, Local-Variable Syntax for Lambda Parameters are some of the new features and along with these new features, isBlank(), strip(), stripLeading(), stripTrailing(), and repeat() were also introduced for strings
<p><b>Can you tell me some new features that were introduced in Java 17?</b></p>
Sealed Classes, Pattern Matching for switch, Foreign Function and Memory API are some of the examples
 
<p><b>Can you tell me some new features that were introduced in Java 21?</b></p>
Virtual Threads, Structured Concurrency, Scoped Values, Sequenced Collections, Record Pattern are some of the examples
<p><b>Which is faster, traditional for loop or Streams?</b></p>
Traditional for loops are generally faster due to less overhead, but Streams provide better readability and are optimized for parallel processing in large datasets.

<p><b>In which scenarios would you prefer traditional for loops and streams?</b></p>
Use traditional loops for simple, small datasets requiring maximum performance. Use Streams for more complex data transformations or when working with large datasets where readability, maintainability, and potential parallelism are prioritized.

<p><b>Explain intermediate and terminal operations in streams.</b></p>
Intermediate operations (e.g., filter(), map()) return another stream and are lazy (executed only when a terminal operation is called). Terminal operations (e.g., forEach(), collect()) trigger the actual processing of the stream and produce a result or side effect.
<p><b>Differences in Interface from Java 7 to Java 8.</b></p>
In Java 7, interfaces could only have abstract methods. Java 8 introduced default and static methods, allowing interfaces to have method implementations.
<p><b>Use of String.join(….) in Java 8?</b></p>
String.join() concatenates a sequence of strings with a specified delimiter, simplifying string joining operations.


<p><b>Collection Framework</b></p>
<p><b>What is collection framework in java?</b></p>
The Java Collection Framework is a set of tools that helps us organize, store, and manage groups of data easily. It includes various types of collections like lists, sets, and maps.
<p><b>What are the main interfaces of the Java Collection Framework?</b></p>
The main parts of the Java Collection Framework are interfaces like Collection, List, Set, Queue, and Map. Each one helps manage data in different ways.
<p><b>Can you explain how Iterator works within the Java Collection Framework?</b></p>
An Iterator is a tool in the Collection Framework that lets you go through a collection's elements one by one.
<p><b>What are some common methods available in all Collection types?</b></p>
Some common methods all collection types have are add, remove, clear, size, and isEmpty. These methods let us add and remove items, check the size, and see if the collection is empty.
 
<p><b>How does Java Collection Framework handle concurrency?</b></p>
The Collection Framework deals with multiple threads using special collection classes like ConcurrentHashMap and CopyOnWriteArrayList, which let different parts of our program modify the collection at the same time safely.
<p><b>How do you choose the right collection type for a specific problem?</b></p>
To pick the right collection type, think about what we need: List if you want an ordered collection that can include duplicates, Set if you need unique elements, Queue for processing elements in order, and Map for storing pairs of keys and values.

<p><b>What enhancements were made to the Java Collection Framework in Java 8?</b></p>
Java 8 made improvements to the Collection Framework by adding Streams, which make it easier to handle collections in bulk, and lambda expressions, which simplify writing code for operations on collections.
<p><b>What is the difference between Iterator and listIterator?</b></p>
Iterator allows forward traversal of a collection, while ListIterator extends Iterator functionality to allow bidirectional traversal of lists and also supports element modification.

<p><b>Name of algorithm used by Arrays.sort(..) and Collections.sort(..)?</b></p>
Arrays.sort() uses a Dual-Pivot Quicksort algorithm for primitive types and TimSort for object arrays. Collections.sort() uses TimSort, a hybrid sorting algorithm combining merge sort and insertion sort.
<p><b>How do you store elements in a set to preserve insertion order?</b></p>
Use a LinkedHashSet, which preserves the insertion order of elements.

<p><b>How do you store elements in a way that they are sorted?</b></p>
Use a TreeSet or a TreeMap, which automatically sorts elements based on their natural ordering or a specified comparator.

<p><b>Whats the use case of arrayList, linkedList and Hashset?</b></p>
We use arrayList where we need efficient random access to elements via indices, like retrieving elements frequently from a list without altering it.

We use LinkedList where you frequently add and remove elements from the beginning or middle of the list, such as implementing queues or stacks.

We use HashSet where we need to ensure that there are no duplicates and we require fast lookups, additions, and deletions. It is ideal for scenarios like checking membership existence, such as in a set of unique items or keys.
<p><b>How does a HashSet ensure that there are no duplicates?</b></p>

 
A HashSet in Java uses a HashMap under the hood. Each element you add is treated as a key in this HashMap. Since keys in a HashMap are unique, HashSet automatically prevents any duplicate entries.
<p><b>Can you describe how hashCode() and equals() work together in a collection</b></p>
 hashCode() determines which bucket an object goes into, while equals() checks equality between objects in the same bucket to handle collisions, ensuring that each key is unique.

<p><b>Why is it important to override the hashCode method when you override equals?</b></p>
What would be the consequence if we don’t?
Overriding hashCode() is crucial because hash-based collections like HashMap and HashSet use the hashcode to locate objects. Without consistent hashCode() and equals(), objects may not be found or stored correctly.
<p><b>Can you give an example where a TreeSet is more appropriate than HashSet?</b></p>
 A TreeSet is more appropriate than a HashSet when you need to maintain the elements in a sorted order. For example, if we are managing a list of customer names that must be displayed alphabetically, using a TreeSet would be ideal.
<p><b>What is the internal implementation of ArrayList and LinkedList?</b></p>
ArrayList is backed by a dynamic array, which provides O(1) access time but requires resizing. LinkedList is implemented as a doubly-linked list, providing O(1) insertion and deletion at both ends but O(n) access time.


<p><b>Can you explain internal working of HashMap in Java?</b></p>
A HashMap in Java stores key-value pairs in an array where each element is a bucket. It uses a hash function to determine which bucket a key should go into for efficient data retrieval. If two keys end up in the same bucket, a Collison happened then the HashMap manages these collisions by maintaining a linked list or a balanced tree depend upon the java version in each bucket.
<p><b>What happens when two keys have the same hash code? How would you handle this scenario?</b></p>
When two different Java objects have the same hashcode, it's called a hash collision. In this case, Java handles it by storing both objects in the same bucket in a hash- based collection, like a HashMap. It then compares the objects using the equals() method to differentiate them.

<p><b>How does a HashMap handle collisions in Java?</b></p>
In Java, when a HashMap encounters a collision (two keys with the same hashcode), it stores both entries in the same bucket. Prior to Java 8, it linked them in a simple list structure. In Java 8, if the number of entries in a bucket grows large, the list is converted to a balanced tree for faster lookups.



 
<p><b>Can you please tell me what changes were done for the HashMap in Java 8 because before java 8 hashMap behaved differently ?</b></p>
Before Java 8, HashMap dealt with collisions by using a simple linked list. Starting from Java 8, when too many items end up in the same bucket, the list turns into a balanced tree, which helps speed up searching.
<p><b>Can we include class as a key in hashmap?</b></p>
No, as functional interface allows to have only single abstract method. However functional interface can inherit another interface if it contains only static and default methods in it

<p><b>Can you please explain ConcurrentHashMap</b></p>
ConcurrentHashMap is a version of HashMap that's safe to use by many threads at once without needing to lock the entire map. It divides the map into parts that can be locked separately, allowing better performance.
<p><b>How does it(ConcurrentHashMap ) improve performance in a multi-threaded environment?</b></p>
ConcurrentHashMap boosts performance in multi-threaded settings by letting different threads access and modify different parts of the map simultaneously, reducing waiting times and improving efficiency.

<p><b>What is time complexities insertions, deletion and retrieval of hashSet and HashMap?</b></p>
1.	Insertion:
2.	Average: O(1)
3.	Worst case: O(n) when rehashing occurs
4.	Deletion:
5.	Average: O(1)
6.	Worst case: O(n) when rehashing occurs
7.	Retrieval:
8.	Average: O(1)
9.	Worst case: O(n) when rehashing occurs (due to hash collisions) NOTE: HashSet and HashMap are not internally sorted
<p><b>What is time complexities insertions, deletion and retrieval of TreeSet and TreeMap?</b></p>
O(log n) for operations like insertions, deletion and retrieval NOTE: HashSet and HashMap are not internally sorted
<p><b>What techniques did hashMap, treeMap, hashSet and TreeSet uses internally for performing operations?</b></p>
HashMap uses an array of nodes, where each node is a linked list or Tree depend upon the collisions and java versions ( From Java 8 onwards, if there is high hash collisons then linkedList gets converted to Balanced Tree).
TreeMap uses a Red-Black tree, which is a type of self-balancing binary search tree. Each node in the Red-Black tree stores a key-value pair.
HashSet internally uses a HashMap whereas TreeSet internally uses TreeMap

<p><b>Design Patterns and Principles Basics</b></p>

<p><b>What is a design pattern in Java and why do we use this?</b></p>
Design patterns are proven solutions for common software design problems. They provide standardized approaches to organize code in a way that is maintainable, scalable, and understandable.

<p><b>Can you list and explain a few common design patterns used in Java programming?</b></p>
Common design patterns in Java:
1.	Singleton: Ensures a class has only one instance, with a global access point.
2.	Observer: Allows objects to notify others about changes in their state.
3.	Factory Method: Delegates the creation of objects to subclasses, promoting flexibility.
<p><b>How can design patterns affect the performance of a Java application?</b></p>
Design patterns can impact performance by adding complexity, but they improve system architecture and maintainability. The long-term benefits often outweigh the initial performance cost.
<p><b>Which design pattern would you use to manage database connections efficiently in a Java application?</b></p>
The Singleton pattern is commonly used to manage database connections, ensuring a single shared connection instance is reused efficiently.
<p><b>How do you choose the appropriate design pattern for a particular problem in Java?</b></p>
Understand the problem fully, identify similar problems solved by design patterns, and consider the implications of each pattern on the application’s design and performance.

<p><b>Difference between HashMap and TreeMap.</b></p>
HashMap stores key-value pairs without ordering, while TreeMap sorts the entries by keys. TreeMap has O(log n) operations due to its tree structure, whereas HashMap has O(1) operations under ideal conditions.
<p><b>In what scenarios would you prefer to use a TreeMap over a HashMap?</b></p>
Use a TreeMap when you need to maintain a sorted order of keys, such as when iterating over sorted data. A HashMap is preferable for fast lookups without concern for ordering.
<p><b>Can we add objects as a key in TreeMap?</b></p>
 
Yes, objects can be used as keys in a TreeMap if they implement the Comparable interface or a Comparator is provided for sorting the keys.

<p><b>What are SOLID Principles?</b></p>

'S' stands for Single Responsibility Principle: It means a class should only have one reason to change, meaning it should handle just one part of the functionality.
For Example: A class VehicleRegistration should only handle vehicle registration details. If it also takes care of vehicle insurance, then it will violates this.
'O' stands for Open/Closed Principle: It means Classes should be open for extension but closed for modification.
For Example: We have a VehicleService class that provides maintenance services. Later, we need to add a new service type for electric vehicles and if without modifying VehicleService, we are able to extend it from a subclass ElectricVehicleService then it follows this priciple. 'L' stands for Liskov Substitution Principle: It means Objects of a superclass should be
replaceable with objects of its subclasses without affecting the program’s correctness.
For Example: If we have a superclass Vehicle with a method startEngine(), and subclasses like Car and ElectricCar, we should be able to replace Vehicle with Car or ElectricCar in our system without any functionality breaking. If ElectricCar can't implement startEngine() because it doesn’t have a traditional engine, it should still work with the interface to not break the system.
'I' for Interface Segregation Principle: It means do not force any client to depend on methods it does not use; split large interfaces into smaller ones.
For Example: Instead of one large interface VehicleOperations with methods like drive, refuel, charge, and navigate, split it into focused interfaces like Drivable, Refuelable, and Navigable. An ElectricCar wouldn't need to implement Refuelable, just Chargeable and Navigable.
'D' stands for Dependency Inversion Principle: It means High-level modules should not depend directly on low-level modules but should communicate through abstractions like interfaces.
For Example: If a VehicleTracker class needs to log vehicle positions, it shouldn't depend directly on a specific GPS device model. Instead, it should interact through a GPSDevice interface, allowing any GPS device that implements this interface to be used without changing the VehicleTracker class.


<b><p>Concurrency and multi-threading</b></p>
<p><b>What is a thread in Java and how can we create it?</b></p>
A thread in Java is a pathway of execution within a program. You can create a thread by extending the Thread class or implementing the Runnable interface.
<p><b>Can you explain the lifecycle of a Java thread?</b></p>
A Java thread lifecycle includes states: New, Runnable, Blocked, Waiting, Timed Waiting, and Terminated.

 
<p><b>How would you handle a scenario where two threads need to update the same data structure?</b></p>
Use synchronized blocks or methods to ensure that only one thread can access the data structure at a time, preventing concurrent modification issues.
<p><b>Can we strat thread twice?</b></p>
No, a thread in Java cannot be started more than once. Attempting to restart a thread that has already run will throw an IllegalThreadStateException.

<p><b>What is the difference between Thread class and Runnable interface in Java?</b></p>
The Thread class defines a thread of execution, whereas the Runnable interface should be implemented by any class whose instances are intended to be executed by a thread.

<p><b>How can you ensure a method is thread-safe in Java?</b></p>
To ensure thread safety, use synchronization mechanisms like synchronized blocks, volatile variables, or concurrent data structures.
<p><b>What are volatile variables?</b></p>
Volatile variables in Java are used to indicate that a variable's value will be modified by different threads, ensuring that the value read is always the latest written.

<p><b>What is thread synchronization and why is it important?</b></p>
Thread synchronization controls the access of multiple threads to shared resources to prevent data inconsistency and ensure thread safety.
<p><b>Can you describe a scenario where you would use wait() and notify() methods in thread communication?</b></p>
Use wait() and notify() for inter-thread communication, like when one thread needs to wait for another to complete a task before proceeding.
<p><b>What challenges might you face with multithreaded programs in Java?</b></p>
In Java, multithreaded programming can lead to issues like deadlocks, race conditions, and resource contention, which complicate debugging and affect performance. Managing thread safety and synchronization efficiently is also a significant challenge.

<p><b>What is Java memory model and how it is linked to threads?</b></p>
The Java Memory Model (JMM) defines the rules by which Java programs achieve consistency when reading and writing variables across multiple threads, ensuring all threads have a consistent view of memory.



</b></p>Miscellaneous questions (Not too much important)</b></p>


 
<p><b>what is transient?</b></p>
The transient keyword in Java is used to indicate that a field should not be serialized. This means it will be ignored when objects are serialized and deserialized.

<p><b>Can we create a server in java application without creating spring or any other framework?</b></p>
Yes, you can create a server in a Java application using only Java SE APIs, such as by utilizing the ServerSocket class for a simple TCP server or the HttpServer class for HTTP services.


<p><b>What is exchanger class</b></p>
The Exchanger class in Java is a synchronization point at which threads can pair and swap elements within pairs. Each thread presents some object on exchange and receives another object in return from another thread.
<p><b>What is reflection in java?</b></p>
Reflection in Java is a capability to inspect and modify the runtime behavior of applications. It allows programs to manipulate internal properties of classes, methods, interfaces, and dynamically call them at runtime.
<p><b>What is the weak reference and soft reference in java?</b></p>
Weak references in Java are garbage collected when no strong references exist. Soft references are only cleared at the discretion of the garbage collector, typically when memory is low.

<p><b>What is Java Flight Recorder?</b></p>
Java Flight Recorder (JFR) is a tool for collecting diagnostic and profiling data about a running Java application without significant performance overhead.
<p><b>Discuss Java Generics.</b></p>
Generics provide type safety by allowing classes and methods to operate on objects of specific types, preventing runtime ClassCastException and reducing code duplication
<p><b>What is the difference between Young Generation and Old Generation memory spaces?</b></p>
The Young Generation stores newly created objects. The Old Generationholds objects that have survived several garbage collection cycles in the Young Generation


<h1 style="background-color: blue;">Paper 3</h1>
    
</body>
</html>
