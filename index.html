
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Java</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; line-height: 1.6; background-color: #f4f4f4;}
        h1 { color: #fff; text-align: center; background-color: #3498db; padding: 15px; border-radius: 8px; }
        .question { font-weight: bold; margin-top: 20px; color: #000; background-color: white; padding: 10px; border-radius: 5px; }
        p { background: white; padding: 10px; border-radius: 5px; color: green; font-weight: bold; }
    </style>
</head>
<body>
 <div class="qa-container">
        <h1 style="background-color: blue;">Java-1</h1>

	 <style>
        body {
            background-color: #121212;
            color: white;
            font-family: Arial, sans-serif;
            text-align: center;
        }
        h1 {
            text-align: left;
            padding-left: 20px;
        }
        .grid-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 20px;
            max-width: 900px;
            margin: auto;
            padding: 20px;
        }
        .grid-item {
            background-color: #1e1e1e;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            transition: transform 0.3s;
        }
        .grid-item:hover {
            transform: scale(1.1);
        }
        .grid-item img {
            width: 80px;
            height: 80px;
        }
        .grid-item a {
            color: #76ff03;
            text-decoration: none;
            display: block;
            margin-top: 10px;
            font-size: 16px;
        }
    </style>
</head>
<body>
    <div class="grid-container">
        <div class="grid-item">
            <img src="java-icon.png" alt="Java 1">
            <a href="Step-1-Core-Java-Level-1.pdf" target="_blank">View Java-1</a>
        </div>
        <div class="grid-item">
            <img src="java-icon.png" alt="Java 2">
            <a href="Step-2-Core-Java-Level-2.pdf" target="_blank">View Java-2</a>
        </div>
        <div class="grid-item">
            <img src="java-icon.png" alt="Java 3">
            <a href="Step-3-Core-Java-Level-3.pdf" target="_blank">View Java-3</a>
        </div>
        <div class="grid-item">
            <img src="spring-icon.png" alt="Springboot 1">
            <a href="Step-6-Spring-Boot-Level-1.pdf" target="_blank">View Springboot-1</a>
        </div>
        <div class="grid-item">
            <img src="spring-icon.png" alt="Springboot 2">
            <a href="Step-7-Spring-Boot-Level-2.pdf" target="_blank">View Springboot-2</a>
        </div>
        <div class="grid-item">
            <img src="spring-icon.png" alt="Springboot 3">
            <a href="Step-8-Spring-Boot-Level-3-Scenario-Based.pdf" target="_blank">View Springboot-3</a>
        </div>
        <div class="grid-item">
            <img src="microservices-icon.png" alt="Microservices 1">
            <a href="Step-14-Microservices-Level-1.pdf" target="_blank">View Microservices-1</a>
        </div>
        <div class="grid-item">
            <img src="zenz-icon.png" alt="Zenz">
            <a href="zenz.pdf" target="_blank">View Zenz</a>
        </div>
    </div>
	 
		<div id="java1" class="tab active">
        <div class="question">Q1. What is Java?</div>
        <div class="answer">Java is a high-level, class-based, object-oriented programming language that is designed to have as 
few implementation dependencies as possible. It is a widely used language for developing 
applications for web, mobile, and desktop platforms.</div>
        <div id="java1" class="tab active">
        <div class="question">Q2. What are the features of Java?</div>
        <div class="answer">Key features of Java include platform independence, object-orientation, security, robustness, 
simplicity, multithreading support, and garbage collection.</div>
        
        <div class="question">Q3. What is JVM and why is it important?</div>
        <div class="answer">JVM stands for Java Virtual Machine, which is the part of the Java Run-time Environment that 
executes Java byte code. It is important because it provides a platform-independent way of executing 
Java code.</div>
        
        <div class="question">Q4. What is the difference between JDK, JRE, and JVM?</div>
        <div class="answer">JDK (Java Development Kit) is the full software development kit required to develop Java 
applications, JRE (Java Runtime Environment) is a subset of JDK that is required to run Java 
applications, and JVM (Java Virtual Machine) is the component of JRE that executes Java bytecode.</div>
        
        <div class="question">Q5. What is the use of the public static void main(String[] args) method?</div>
        <div class="answer">This method is the entry point for any Java application. It is the method called by the JVM to run the program.</div>
        
        <div class="question">Q6. Explain the concept of Object-Oriented Programming in Java.</div>
        <div class="answer">Object-Oriented Programming (OOP) in Java is a programming paradigm based on the concept of 
"objects", which can contain data in the form of fields (attributes) and code in the form of 
procedures (methods). Java uses OOP principles including inheritance, encapsulation, polymorphism, 
and abstraction. </div>
        
        <div class="question">Q7. What is inheritance in Java?</div>
        <div class="answer">Inheritance is a fundamental OOP concept where one class can inherit fields and methods from 
another class. In Java, inheritance is achieved using the extends keyword. </div>
        
        <div class="question">Q8. What is polymorphism in Java?</div>
        <div class="answer">Polymorphism in Java is the ability of an object to take on many forms. It is typically achieved 
through method overriding and method overloading.</div>
        
        <div class="question">Q9. Explain encapsulation with an example in Java.</div>
        <div class="answer">Encapsulation in Java is the bundling of data (variables) and methods that operate on the data into a 
single unit, or class, and restricting access to some of the object's components. This is usually done 
by making fields private and providing public getter and setter methods. For example: 
public class Employee { 
private String name; 
public String getName() { 
return name; 
} 
public void setName(String newName) { 
this.name = newName; 
} 
}.</div>
        
        <div class="question">Q10. What is an interface in Java?</div>
        <div class="answer">An interface in Java is a reference type, similar to a class, that can contain only constants, method 
signatures, default methods, static methods, and nested types. Interfaces cannot contain instance 
f
 ields. The methods in interfaces are abstract by default.</div>
        
        <div class="question">Q11. Explain the concept of an abstract class.</div>
        <div class="answer">An abstract class in Java is a class that cannot be instantiated and may contain abstract methods, 
which do not have an implementation and must be implemented in subclasses.</div>
        
        <div class="question">Q12. What are constructors in Java?</div>
        <div class="answer">Constructors in Java are special methods used to initialize objects. The constructor is called when an 
object of a class is created and has the same name as the class.</div>
        
        <div class="question">Q13. What is method overloading?</div>
        <div class="answer">Method overloading is a feature in Java that allows a class to have more than one method having the 
same name, if their parameter lists are different. It is a way of implementing compile-time 
polymorphism.</div>
        
        <div class="question">Q14. What is method overriding?</div>
        <div class="answer">Method overriding, in Java, is a feature that allows a subclass to provide a specific implementation of 
a method that is already provided by one of its super-classes or parent classes.</div>
        
        <div class="question">Q15. What is a package in Java?</div>
        <div class="answer">In Java, a package is a namespace that organizes a set of related classes and interfaces. Conceptually, 
packages are similar to different folders on your computer</div>
        
        <div class="question">Q16. Explain the final keyword in Java.</div>
        <div class="answer">The final keyword in Java can be used to mark a variable as constant (not changeable), a method as 
not overrideable, or a class as not inheritable.</div>
        
        <div class="question">Q17. What are Java Exceptions?</div>
        <div class="answer">Exceptions in Java are events that disrupt the normal flow of the program. They are objects that wrap 
an error event that occurred within a method and are either caught or propagated further up the 
calling chain. </div>
        
        <div class="question">Q18. What is the difference between checked and unchecked exceptions?</div>
        <div class="answer">Checked exceptions are exceptions that are checked at compile-time, meaning that the code must 
handle or declare them. Unchecked exceptions are checked at runtime, meaning they can be thrown 
without being caught or declared. </div>
        
        <div class="question">Q19. What is the static keyword used for in Java?</div>
        <div class="answer">The static keyword in Java is used to indicate that a particular field, method, or block of code belongs 
to the class, rather than instances of the class. Static members are shared among all instances of a 
class.</div>
        
        <div class="question">Q20. What is a thread in Java?</div>
        <div class="answer">A thread in Java is a lightweight subprocess, the smallest unit of processing. Multithreading is a Java 
feature that allows concurrent execution of two or more parts of a program for maximum utilization 
of CPU. </div>
        
    
    <div class="question">Q21. What is the difference between == and .equals()?</div>
        <div class="answer">In Java, == operator is used to compare primitive data types and checks if two references point to the 
same object in memory. .equals() method is used to compare the contents of two objects. </div>
        
        <div class="question">Q22. What is garbage collection in Java?</div>
        <div class="answer">Garbage collection in Java is the process by which Java programs perform automatic memory 
management. Java programs compile to bytecode that is run on the Java Virtual Machine (JVM). 
When objects are no longer in use, the garbage collector attempts to reclaim memory on the JVM for 
reuse.</div>
        
        <div class="question">Q23. What is the Collections Framework?</div>
        <div class="answer">The Collections Framework in Java is a unified architecture for representing and manipulating 
collections. All collections frameworks contain interfaces, implementations, and algorithms to help 
Java programmers handle data efficiently.</div>
        
        <div class="question">Q24. Explain the synchronized keyword.</div>
        <div class="answer">The synchronized keyword in Java is used to control the access of multiple threads to any shared 
resource. It is used to prevent thread interference and consistency problems.</div>
        
        <div class="question">Q25. What are generics in Java?</div>
        <div class="answer">Generics are a feature that allows you to write and use parameterized types and methods in Java. 
Generics provide compile-time type safety that allows programmers to catch invalid types at compile 
t
 ime. </div>
        
        <div class="question">Q26. What is the this keyword in Java?</div>
        <div class="answer">In Java, ‘this’ is a reference variable that refers to the current object. It can be used to refer current 
class instance variable, invoke current class method, pass as an argument in the method call, pass as 
argument in the constructor call, and return the current class instance. </div>
        
        <div class="question">Q27. What is an Enum in Java?</div>
        <div class="answer">Enum in Java is a data type that consists of a fixed set of constants. Enums are used to create our 
own data types (Enumerated Data Types). It is used when we know all possible values at compile 
t
 ime, such as choices on a menu, rounding modes, command line flags, etc. </div>
        
        <div class="question">Q28. What is multithreading in Java?</div>
        <div class="answer">In Java, threads are lightweight processes that allow a program to perform multiple tasks 
simultaneously. Each thread runs a separate path of execution within the program. Java provides 
built-in support for threads through the Thread class and the Runnable interface. 
By using threads, you can improve the performance of applications by handling tasks such as 
background operations, parallel processing, and asynchronous tasks more efficiently. Threads share 
the same memory space, which makes communication between them easier but also requires 
careful synchronization to avoid conflicts. </div>
        
        <div class="question">Q29. Explain the volatile keyword in Java.</div>
        <div class="answer">Multithreading in Java is a process of executing multiple threads simultaneously. Thread is a 
lightweight sub-process, a smallest unit of processing. It allows the concurrent execution of two or 
more parts of a program to maximize the utilization of CPU time. </div>
        
        <div class="question">Q30. Explain volatile keyword in Java.</div>
        <div class="answer">The volatile keyword in Java is used to indicate that a variable's value will be modified by different 
threads. Declaring a variable volatile ensures that its value is read from the main memory and not 
from the thread's cache memory.</div>
        


    <h1 style="background-color: blue;">Java-2</h1>
	
	<h2>Java Architecture and Memory Management</h2>

<div class="question">Q1. What is the difference between JVM, JRE, and JDK?</div>
    <div class="answer">
        The JVM is the engine that runs Java bytecode, making Java platform-independent.  
        The JRE contains the JVM and the standard libraries needed to run Java programs.  
        The JDK is a development kit containing the JRE plus tools like compilers and debuggers.
    </div>

    <div class="question">Q2. What are the key components of JVM Architecture?</div>
    <div class="answer">
        The JVM has three components: the ClassLoader, runtime data areas, and the execution engine.  
        - The ClassLoader loads class files into the JVM.  
        - The Runtime Data Areas store data needed while the program runs.  
        - The Execution Engine runs the instructions in the class files.
    </div>

    <div class="question">Q3. Can a Java application run without installing the JRE?</div>
    <div class="answer">
        No, a Java application needs the JRE because it contains essential tools and libraries.  
        However, newer Java versions offer <code>jlink</code>, which allows bundling an application with a minimal JRE.
    </div>

    <div class="question">Q4. Is it possible to have the JDK installed without having the JRE?</div>
    <div class="answer">
        No, the JDK includes the JRE. It’s not possible to have a JDK without the JRE since the JRE contains essential runtime components.
    </div>

    <div class="question">Q5. What are the memory storages available in JVM?</div>
    <div class="answer">
        JVM memory is divided into:  
        - **Heap Space:** Stores objects and shared data.  
        - **Stack Memory:** Manages method calls and local variables.  
        - **Method Area (Metaspace in Java 8+):** Stores class metadata and constants.  
        - **Native Method Stacks:** Used for native method execution.
    </div>

    <div class="question">Q6. Which is faster to access between heap and stack, and why?</div>
    <div class="answer">
        Stack memory is faster because it uses a Last-In-First-Out (LIFO) structure for method calls and local variables.  
        The heap, used for dynamic memory allocation, is slower due to complex memory management.
    </div>

    <div class="question">Q7. How does garbage collection work in Java?</div>
    <div class="answer">
        Garbage collection in Java automatically frees memory by removing objects that are no longer referenced,  
        making space for new objects.
    </div>

    <div class="question">Q8. What is the role of the <code>finalize()</code> method in garbage collection?</div>
    <div class="answer">
        The <code>finalize()</code> method is called by the garbage collector when an object has no more references.  
        It allows the object to clean up resources before being collected.
    </div>

    <div class="question">Q9. What garbage collection algorithms does the JVM use?</div>
    <div class="answer">
        JVM uses multiple garbage collection algorithms, including:  
        - **Mark-Sweep**  
        - **Mark-Compact**  
        - **Generational Copying**, depending on the chosen collector.
    </div>

    <div class="question">Q10. How can memory leaks occur in Java despite automatic garbage collection?</div>
    <div class="answer">
        Memory leaks occur when objects are no longer needed but still referenced,  
        preventing the garbage collector from reclaiming their memory.
    </div>

		<h2>Java Fundamentals</h2>
		
   <div class="question">Q1. Is Java 100% object-oriented programming language?</div>
    <div class="answer">
        No, Java is not considered 100% object-oriented because it uses primitive types (like int, char, etc.) that are not objects. 
        In a fully object-oriented language, everything is treated as an object.
    </div>

    <div class="question">Q2. What are the advantages of Java being partially object-oriented?</div>
    <div class="answer">
        1. Using simple, non-object types like integers and booleans helps Java run faster and use less memory.<br>
        2. The mix of features allows Java to work well with other technologies and systems, which might not be fully object-oriented.
    </div>

    <div class="question">Q3. What is the use of object-oriented programming languages in enterprise projects?</div>
    <div class="answer">
        Object-oriented programming (OOP) is used in big projects to make coding easier to handle. It helps organize code better, 
        makes it easier to update and scale, and lets programmers reuse code, saving time and effort.
    </div>

    <div class="question">Q4. Explain <code>public static void main(String args[])</code>?</div>
    <div class="answer">
        In Java, <code>public static void main(String[] args)</code> is the entry point of any standalone Java application.<br><br>
        - <b>public</b>: Makes this method accessible from anywhere.<br>
        - <b>static</b>: Means we don't need to create an object to call this method.<br>
        - <b>void</b>: It doesn’t return any value.<br>
        - <b>main</b>: The name of the method.<br>
        - <b>String[] args</b>: An array that holds any command-line arguments passed to the program.
    </div>

    <div class="question">Q5. What happens if we don’t declare the main method as static?</div>
    <div class="answer">
        If we don't declare the main method as static in a Java program, the JVM won't be able to launch the application. 
        The program will compile, but it will fail to run, giving an error like:  
        <i>"Main method is not static in class MyClass, please define the main method as: public static void main(String[] args)."</i>
    </div>

    <div class="question">Q6. Can we override the main method?</div>
    <div class="answer">
        No, we cannot override the main method in Java because a static method cannot be overridden. 
        Static methods are associated with the class itself, not instances of the class.
    </div>

    <div class="question">Q7. Can we overload the main method?</div>
    <div class="answer">
        Yes, we can overload the main method in Java by changing its argument list.
    </div>

    <div class="question">Q8. Can JVM execute our overloaded main method?</div>
    <div class="answer">
        No, the JVM only calls the original main method (<code>public static void main(String[] args)</code>), not any overloaded versions.
    </div>

    <div class="question">Q9. What’s the difference between primitive data types and non-primitive data types?</div>
    <div class="answer">
        - <b>Primitive data types</b> in Java are the basic types of data predefined by the language and named by a keyword. 
          They have a fixed size and are not objects. Examples include <code>int</code>, <code>double</code>, <code>char</code>, and <code>boolean</code>.<br><br>
        - <b>Non-primitive data types</b>, on the other hand, are objects and classes that are not defined by Java itself but rather 
          by the programmer or the Java API. They can be used to call methods to perform certain operations, and their size is not fixed. 
          Examples include <code>String</code>, <code>arrays</code>, and any class instances.
    </div>

    <div class="question">Q10. Can primitive data types be NULL?</div>
    <div class="answer">
        No, primitive data types in Java cannot be null. They have default values (e.g., 0 for int, false for boolean, 0.0 for double) and must always have a value.
    </div>

    <div class="question">Q11. Can we declare pointers in Java?</div>
    <div class="answer">
        No, Java does not support pointers. This is because pointers can lead to security vulnerabilities and unsafe memory access.
    </div>

    <div class="question">Q12. What is the difference between <code>==</code> and <code>.equals()</code> in Java?</div>
    <div class="answer">
        - <b><code>==</code></b> compares object references (checks if two references point to the same memory location).<br>
        - <b><code>.equals()</code></b> compares object content (checks if two objects have the same logical value).
    </div>
        
         <div class="question">Q13. Why do we use wrapper classes in collections?</div>
    <div class="answer">
        Java collections, such as ArrayList, HashMap, and others in the Java Collections Framework, can only hold objects and not primitive types. 
        Wrapper classes allow primitive values to be treated as objects, enabling them to be stored and managed within these collections.
    </div>
    
    <div class="question">Q14. What is the difference between unboxing and autoboxing?</div>
    <div class="answer">
        <b>Autoboxing:</b> Automatically converts a primitive type (like int) to its corresponding wrapper class (Integer).<br>
        <b>Unboxing:</b> Converts a wrapper class back to a primitive type (e.g., Integer to int).
    </div>
    
    <div class="question">Q15. Can autoboxing lead to unexpected behavior?</div>
    <div class="answer">
        Yes, when comparing two Integer instances using <code>==</code>, autoboxing might lead to false results because it compares object references, 
        not values, for integers outside the cache range of -128 to 127.
    </div>
    
    <div class="question">Q16. Can autoboxing and unboxing cause a NullPointerException?</div>
    <div class="answer">
        Yes, a NullPointerException can occur if you unbox a null object; for example, assigning null to an Integer and then using it in a context 
        where an int is expected.
    </div>
    
    <div class="question">Q17. What is the role of try, catch, and finally in exception handling?</div>
    <div class="answer">
        <b>try:</b> Contains code that might throw exceptions.<br>
        <b>catch:</b> Handles those exceptions.<br>
        <b>finally:</b> Executes code after try/catch, regardless of an exception, typically for cleanup operations.
    </div>
    
    <div class="question">Q18. Does the finally block execute if return is used in try or catch?</div>
    <div class="answer">
        Yes, the finally block executes even if a return statement is used in the try or catch block, ensuring cleanup runs.
    </div>
    
    <div class="question">Q19. Can we use try with finally without a catch block?</div>
    <div class="answer">
        Yes, we can use try with finally without a catch block to ensure cleanup occurs even if we allow the exception to propagate up.
    </div>
    
    <div class="question">Q20. Does exception handling affect Java application performance?</div>
    <div class="answer">
        Using try-catch-finally can affect performance slightly due to the overhead of managing exceptions but is generally minimal unless exceptions are thrown frequently.
    </div>
    
    <div class="question">Q21. When will the finally block not execute?</div>
    <div class="answer">
        The finally block will not execute if the JVM exits via <code>System.exit()</code> during try or catch execution.
    </div>
    
    <div class="question">Q22. Can we write multiple finally blocks?</div>
    <div class="answer">
        No, each try can only have one finally block. Multiple finally blocks are not allowed within a single try-catch-finally structure.
    </div>
    
    <div class="question">Q23. What is an exception? Difference between checked and unchecked exceptions?</div>
    <div class="answer">
        <b>Exception:</b> An unwanted event that occurs during the execution of a program and disrupts the flow.<br>
        <b>Checked Exceptions:</b> Must be declared or handled (e.g., IOException).<br>
        <b>Unchecked Exceptions:</b> Do not need to be declared or caught (e.g., NullPointerException).
    </div>
    
    <div class="question">Q24. How do we handle multiple exceptions in a single catch block?</div>
    <div class="answer">
        Use a single catch block for multiple exceptions by separating them with a pipe (<code>|</code>), e.g., <code>catch (IOException | SQLException e)</code>, 
        to handle both exceptions with the same logic.
    </div>
    
    <div class="question">Q25. What is the difference between Throwable and Exception?</div>
    <div class="answer">
        <b>Throwable:</b> The superclass for all errors and exceptions.<br>
        <b>Exception:</b> A subclass of Throwable representing recoverable conditions, while <b>Error</b> (another subclass) represents serious issues the application should not attempt to recover from.
    </div>

         <div class="question">Q26. What is the difference between finalize() and finally?</div>
    <div class="answer">
        <b>finalize():</b> Called by the garbage collector before an object is destroyed.<br>
        <b>finally:</b> Used in a try-catch block to execute code regardless of exceptions.<br>
        <b>When might finalize() not get called?</b> If the garbage collector doesn't run or the JVM shuts down.
    </div>
    
    <div class="question">Q27. What is the String pool?</div>
    <div class="answer">
        A Java String Pool is a place in heap memory where all the strings defined in the program are stored. 
        Whenever a new string is created, JVM checks if it exists in the pool; if yes, it reuses the existing object, otherwise, it creates a new one.
    </div>
    
    <div class="question">Q28. When is using the String pool not beneficial?</div>
    <div class="answer">
        The String pool may not be beneficial when there are a lot of unique strings, as checking each string increases complexity and memory usage.
    </div>
    
    <div class="question">Q29. What is the difference between String and StringBuffer?</div>
    <div class="answer">
        <b>String:</b> Immutable, meaning once created, its value cannot be changed. 
        <b>StringBuffer:</b> Mutable, allowing modification of contents and is thread-safe.
    </div>
    
    <div class="question">Q30. How does StringBuilder differ from StringBuffer?</div>
    <div class="answer">
        StringBuilder is similar to StringBuffer but is not thread-safe, making it faster for single-threaded scenarios.
    </div>
    
    <div class="question">Q31. Give a scenario where StringBuffer is better than String?</div>
    <div class="answer">
        StringBuffer is better when dealing with a lot of string modifications, especially in a multi-threaded environment, such as logging messages from different threads.
    </div>
    
    <div class="question">Q32. What is the difference between a String literal and a String object?</div>
    <div class="answer">
        A String literal is stored in the String pool for reusability, whereas a String object created using <code>new String()</code> is stored in the heap separately.
    </div>
    
    <div class="question">Q33. Why is String immutable?</div>
    <div class="answer">
        String is immutable to improve security, caching, and performance by ensuring that its value cannot be changed once created.
    </div>
    
    <div class="question">Q34. What are packages in Java?</div>
    <div class="answer">
        Packages are namespaces that organize classes and interfaces into groups, preventing naming conflicts and managing access control. They provide a structured way to manage Java code.
    </div>
    
    <div class="question">Q35. Why are packages used?</div>
    <div class="answer">
        <ul>
            <li>They help in organizing code efficiently.</li>
            <li>Packages prevent naming conflicts by providing a unique namespace.</li>
            <li>They support modularity by allowing developers to separate programs logically.</li>
            <li>Organizing classes into packages makes it easier to locate related classes.</li>
        </ul>
    </div> <div class="question">Q26. What is the difference between finalize() and finally?</div>
    <div class="answer">
        <b>finalize():</b> Called by the garbage collector before an object is destroyed.<br>
        <b>finally:</b> Used in a try-catch block to execute code regardless of exceptions.<br>
        <b>When might finalize() not get called?</b> If the garbage collector doesn't run or the JVM shuts down.
    </div>
    
    <div class="question">Q27. What is the String pool?</div>
    <div class="answer">
        A Java String Pool is a place in heap memory where all the strings defined in the program are stored. 
        Whenever a new string is created, JVM checks if it exists in the pool; if yes, it reuses the existing object, otherwise, it creates a new one.
    </div>
    
    <div class="question">Q28. When is using the String pool not beneficial?</div>
    <div class="answer">
        The String pool may not be beneficial when there are a lot of unique strings, as checking each string increases complexity and memory usage.
    </div>
    
    <div class="question">Q29. What is the difference between String and StringBuffer?</div>
    <div class="answer">
        <b>String:</b> Immutable, meaning once created, its value cannot be changed. 
        <b>StringBuffer:</b> Mutable, allowing modification of contents and is thread-safe.
    </div>
    
    <div class="question">Q30. How does StringBuilder differ from StringBuffer?</div>
    <div class="answer">
        StringBuilder is similar to StringBuffer but is not thread-safe, making it faster for single-threaded scenarios.
    </div>
    
    <div class="question">Q31. Give a scenario where StringBuffer is better than String?</div>
    <div class="answer">
        StringBuffer is better when dealing with a lot of string modifications, especially in a multi-threaded environment, such as logging messages from different threads.
    </div>
    
    <div class="question">Q32. What is the difference between a String literal and a String object?</div>
    <div class="answer">
        A String literal is stored in the String pool for reusability, whereas a String object created using <code>new String()</code> is stored in the heap separately.
    </div>
    
    <div class="question">Q33. Why is String immutable?</div>
    <div class="answer">
        String is immutable to improve security, caching, and performance by ensuring that its value cannot be changed once created.
    </div>
    
    <div class="question">Q34. What are packages in Java?</div>
    <div class="answer">
        Packages are namespaces that organize classes and interfaces into groups, preventing naming conflicts and managing access control. They provide a structured way to manage Java code.
    </div>
    
    <div class="question">Q35. Why are packages used?</div>
    <div class="answer">
        <ul>
            <li>They help in organizing code efficiently.</li>
            <li>Packages prevent naming conflicts by providing a unique namespace.</li>
            <li>They support modularity by allowing developers to separate programs logically.</li>
            <li>Organizing classes into packages makes it easier to locate related classes.</li>
        </ul>
    </div> <div class="question">Q26. What is the difference between finalize() and finally?</div>
    <div class="answer">
        <b>finalize():</b> Called by the garbage collector before an object is destroyed.<br>
        <b>finally:</b> Used in a try-catch block to execute code regardless of exceptions.<br>
        <b>When might finalize() not get called?</b> If the garbage collector doesn't run or the JVM shuts down.
    </div>
    
    <div class="question">Q27. What is the String pool?</div>
    <div class="answer">
        A Java String Pool is a place in heap memory where all the strings defined in the program are stored. 
        Whenever a new string is created, JVM checks if it exists in the pool; if yes, it reuses the existing object, otherwise, it creates a new one.
    </div>
    
    <div class="question">Q28. When is using the String pool not beneficial?</div>
    <div class="answer">
        The String pool may not be beneficial when there are a lot of unique strings, as checking each string increases complexity and memory usage.
    </div>
    
    <div class="question">Q29. What is the difference between String and StringBuffer?</div>
    <div class="answer">
        <b>String:</b> Immutable, meaning once created, its value cannot be changed. 
        <b>StringBuffer:</b> Mutable, allowing modification of contents and is thread-safe.
    </div>
    
    <div class="question">Q30. How does StringBuilder differ from StringBuffer?</div>
    <div class="answer">
        StringBuilder is similar to StringBuffer but is not thread-safe, making it faster for single-threaded scenarios.
    </div>
    
    <div class="question">Q31. Give a scenario where StringBuffer is better than String?</div>
    <div class="answer">
        StringBuffer is better when dealing with a lot of string modifications, especially in a multi-threaded environment, such as logging messages from different threads.
    </div>
    
    <div class="question">Q32. What is the difference between a String literal and a String object?</div>
    <div class="answer">
        A String literal is stored in the String pool for reusability, whereas a String object created using <code>new String()</code> is stored in the heap separately.
    </div>
    
    <div class="question">Q33. Why is String immutable?</div>
    <div class="answer">
        String is immutable to improve security, caching, and performance by ensuring that its value cannot be changed once created.
    </div>
    
    <div class="question">Q34. What are packages in Java?</div>
    <div class="answer">
        Packages are namespaces that organize classes and interfaces into groups, preventing naming conflicts and managing access control. They provide a structured way to manage Java code.
    </div>
    
    <div class="question">Q35. Why are packages used?</div>
    <div class="answer">
        <ul>
            <li>They help in organizing code efficiently.</li>
            <li>Packages prevent naming conflicts by providing a unique namespace.</li>
            <li>They support modularity by allowing developers to separate programs logically.</li>
            <li>Organizing classes into packages makes it easier to locate related classes.</li>
        </ul>
    </div>
	<div class="question">Q26. What is the difference between finalize() and finally?</div>
    <div class="answer">
        <b>finalize():</b> Called by the garbage collector before an object is destroyed.<br>
        <b>finally:</b> Used in a try-catch block to execute code regardless of exceptions.<br>
        <b>When might finalize() not get called?</b> If the garbage collector doesn't run or the JVM shuts down.
    </div>
    
    <div class="question">Q27. What is the String pool?</div>
    <div class="answer">
        A Java String Pool is a place in heap memory where all the strings defined in the program are stored. 
        Whenever a new string is created, JVM checks if it exists in the pool; if yes, it reuses the existing object, otherwise, it creates a new one.
    </div>
    
    <div class="question">Q28. When is using the String pool not beneficial?</div>
    <div class="answer">
        The String pool may not be beneficial when there are a lot of unique strings, as checking each string increases complexity and memory usage.
    </div>
    
    <div class="question">Q29. What is the difference between String and StringBuffer?</div>
    <div class="answer">
        <b>String:</b> Immutable, meaning once created, its value cannot be changed. 
        <b>StringBuffer:</b> Mutable, allowing modification of contents and is thread-safe.
    </div>
    
    <div class="question">Q30. How does StringBuilder differ from StringBuffer?</div>
    <div class="answer">
        StringBuilder is similar to StringBuffer but is not thread-safe, making it faster for single-threaded scenarios.
    </div>
    
    <div class="question">Q31. Give a scenario where StringBuffer is better than String?</div>
    <div class="answer">
        StringBuffer is better when dealing with a lot of string modifications, especially in a multi-threaded environment, such as logging messages from different threads.
    </div>
    
    <div class="question">Q32. What is the difference between a String literal and a String object?</div>
    <div class="answer">
        A String literal is stored in the String pool for reusability, whereas a String object created using <code>new String()</code> is stored in the heap separately.
    </div>
    
    <div class="question">Q33. Why is String immutable?</div>
    <div class="answer">
        String is immutable to improve security, caching, and performance by ensuring that its value cannot be changed once created.
    </div>
    
    <div class="question">Q34. What are packages in Java?</div>
    <div class="answer">
        Packages are namespaces that organize classes and interfaces into groups, preventing naming conflicts and managing access control. They provide a structured way to manage Java code.
    </div>
    
    <div class="question">Q35. Why are packages used?</div>
    <div class="answer">
        <ul>
            <li>They help in organizing code efficiently.</li>
            <li>Packages prevent naming conflicts by providing a unique namespace.</li>
            <li>They support modularity by allowing developers to separate programs logically.</li>
            <li>Organizing classes into packages makes it easier to locate related classes.</li>
        </ul>
    </div>

<h2>Object Oriented Programming Concepts</h2>
<div class="question">Q1. What are access modifiers in Java?</div>
        <div class="answer">Java uses public, protected, default (no modifier), and private to control access to classes, methods, and fields, ensuring appropriate visibility and encapsulation.</div>
        
        <div class="question">Q2. Can you provide examples of when to use each type of access modifier?</div>
        <div class="answer">
            1. <b>Public:</b> Used when members should be accessible from any other class.<br>
            2. <b>Protected:</b> Ideal for members that should be accessible to subclasses and classes within the same package.<br>
            3. <b>Default:</b> Use when members should be accessible only within the same package.<br>
            4. <b>Private:</b> Best for members intended only for use within their own class.
        </div>
        
        <div class="question">Q3. Why do we use getters and setters when we can make fields public and set/get directly?</div>
        <div class="answer">Using getters and setters instead of public variables allows us to control how values are set and accessed, add validation, and keep the ability to change how data is stored without affecting other parts of your program.</div>
        
        <div class="question">Q4. Can a top-level class be private or protected in Java?</div>
        <div class="answer">No, a top-level class cannot be private or protected because it restricts access, making it unusable from any other classes, contrary to the purpose of a top-level class.</div>
        
        <div class="question">Q5. Explain the concepts of classes and objects in Java.</div>
        <div class="answer">Classes are blueprints for objects in Java, defining the state and behavior that the objects of the class can have. Objects are instances of classes, representing entities with states and behaviors defined by their class.</div>
        
        <div class="question">Q6. What are the ways to create an object?</div>
        <div class="answer">
            1. Using the <b>new</b> Keyword, example: <code>MyClass object = new MyClass();</code><br>
            2. Using <b>Class Factory Methods</b>, example: <code>Calendar calendar = Calendar.getInstance();</code><br>
            3. Using the <b>clone()</b> method.
        </div>
        
        <div class="question">Q7. Can a class in Java be without any methods or fields?</div>
        <div class="answer">Yes, a class in Java can be declared without any methods or fields. Such a class can still be used to create objects, although these objects would have no specific behavior or state.</div>
        
        <div class="question">Q8. What are the methods available in the Object class, and how are they used?</div>
        <div class="answer">The key methods are <code>equals()</code>, <code>hashCode()</code>, <code>toString()</code>, <code>clone()</code>, <code>finalize()</code>, <code>wait()</code>, <code>notify()</code>, and <code>notifyAll()</code>. These provide basic operations like equality checks, memory management, and thread coordination.</div>
        
        <div class="question">Q9. What are anonymous classes and their advantages?</div>
        <div class="answer">Anonymous classes in Java are classes without a name, defined and instantiated in one place. They are useful when you need to create a subclass or implement an interface for a one-time use. The advantages include reduced boilerplate code, encapsulation of specific functionality, and the ability to override methods on the fly.</div>
        
        <div class="question">Q10. What is a Singleton Class?</div>
        <div class="answer">A singleton class in Java is a special class that can have only one instance (or object) at any time. It's useful when we want to make sure there's just one shared resource, like a configuration setting or a connection to a database.</div>
        
        <div class="question">Q11. How can we create a Singleton class?</div>
        <div class="answer">To create a singleton class, make the constructor private, create a private static instance of the class, and provide a static method to return the instance.</div>
        
        <div class="question">Q12. Are singleton classes thread-safe?</div>
        <div class="answer">Singleton classes are not thread-safe by default. If multiple threads try to create an instance at the same time, it could result in multiple instances. To prevent this, we can synchronize the method that creates the instance or use a static initializer.</div>
        
        <div class="question">Q13. What is a constructor in Java?</div>
        <div class="answer">A constructor in Java is a special method used to initialize new objects. It has the same name as the class and may take arguments to set initial values for the object's attributes.</div>
        
        <div class="question">Q14. Can we use a private constructor?</div>
        <div class="answer">Yes, we can use private constructors in Java. They are mostly used in classes that provide static methods or contain only static fields. A common use is in the Singleton design pattern.</div>
        
        <div class="question">Q15. Can a constructor be overloaded?</div>
        <div class="answer">Yes, you can have multiple constructors in a Java class, each with a different set of parameters. This lets you create objects in various ways depending on what information you have at the time.</div>
        
        <div class="question">Q16. What does immutability mean in Java?</div>
        <div class="answer">Immutability in Java means that once an object's state is created, it cannot be changed.</div>
        
        <div class="question">Q17. Why are immutable objects useful for concurrent programming?</div>
        <div class="answer">Immutable objects are useful in concurrent programming because they can be shared between threads without needing synchronization.</div>
        
        <div class="question">Q18. What are immutable classes?</div>
        <div class="answer">Immutable classes in Java are classes whose objects cannot be modified after they are created. This means all their fields are final and set only once, typically through the constructor.</div>
        
        <div class="question">Q19. How can we create an immutable class?</div>
        <div class="answer">
            1. Declare the class as <b>final</b> so it can't be extended.<br>
            2. Make all of the fields <b>final</b> and <b>private</b> so that direct access is not allowed.<br>
            3. Don’t provide setter methods for variables.<br>
            4. Initialize all fields using a constructor.
        </div>
        
        <div class="question">Q20. What does Java's inheritance mean?</div>
        <div class="answer">Inheritance in Java means a class can use the features of another class. This helps to reuse code and make things simpler.</div>
     <div class="question">Q21. Can a class extend on its own?</div>
        <div class="answer">No, a class in Java cannot extend itself. If it tries, it will cause an error.</div>

        <div class="question">Q22. Why multiple inheritance is not possible in Java?</div>
        <div class="answer">Java avoids using multiple inheritance because it can make things complicated, such as when two parent classes have methods that conflict.</div>

        <div class="question">Q23. What is the difference between inheritance and composition?</div>
        <div class="answer">Inheritance is when one class gets its features from another class. Composition is when a class is made using parts from other classes, which can be more flexible.</div>

        <div class="question">Q24. Discuss the principle of "composition over inheritance". Provide an example where this principle should be applied in Java application design.</div>
        <div class="answer">"Composition over inheritance" means using objects within other objects (composition) instead of inheriting from a parent class. It’s applied when classes have a "has-a" relationship. For example, a Car class can have an Engine class as a field rather than inheriting from an Engine.</div>

        <div class="question">Q25. What is the difference between association, aggregation, and composition in Java?</div>
        <div class="answer">Association is a general relationship between two classes. Aggregation is a weak association (has-a) where the child can exist independently of the parent. Composition is a strong association where the child cannot exist without the parent.</div>

        <div class="question">Q26. Explain the IS-A (inheritance) and Has-A (composition) relationships in Java.</div>
        <div class="answer">IS-A refers to inheritance, where a subclass is a type of the superclass. Has-A refers to composition, where a class contains references to other classes as fields.</div>

        <div class="question">Q27. What does polymorphism mean in Java?</div>
        <div class="answer">Polymorphism in Java means that the same piece of code can do different things depending on what kind of object it's dealing with. For example, if you have a method called "draw," it might make a circle for a Circle object and a square for a Square object.</div>

        <div class="question">Q28. How does method overloading relate to polymorphism?</div>
        <div class="answer">Method overloading is using the same method name with different inputs in the same class. It's a simple way to use polymorphism when you're writing your code.</div>

        <div class="question">Q29. What is dynamic method dispatch in Java?</div>
        <div class="answer">Dynamic method dispatch is a way Java decides which method to use at runtime when methods are overridden in subclasses. It ensures the correct method is used based on the type of object.</div>

        <div class="question">Q30. Can constructors be polymorphic?</div>
        <div class="answer">No, constructors cannot be polymorphic. We can have many constructors in a class with different inputs, but they don’t behave differently based on the object type like methods do.</div>
   <div class="question">Q31. What does abstraction mean in Java?</div>
        <div class="answer">Abstraction in Java means focusing on what needs to be done, not how to do it. You create a kind of blueprint that tells other parts of the program what actions they can perform without explaining the details.</div>
        
        <div class="question">Q32. Can you provide examples of where abstraction is effectively used in Java libraries?</div>
        <div class="answer">Java uses abstraction in its collection tools. For example, when you use a List, you don't need to know how it stores data, whether as an ArrayList or a LinkedList.</div>
        
        <div class="question">Q33. What happens if a class includes an abstract method?</div>
        <div class="answer">A class with an abstract method must itself be abstract. We can't create objects directly from an abstract class; it's meant to be a blueprint for other classes.</div>
        
        <div class="question">Q34. How does abstraction help in achieving loose coupling in software applications?</div>
        <div class="answer">Abstraction lets us hide complex details and only show what's necessary. This makes it easier to change parts of your program without affecting others, keeping different parts independent and easier to manage.</div>
        
        <div class="question">Q35. What is an interface in Java?</div>
        <div class="answer">An interface is like a blueprint for a class. It defines a set of methods that the class must implement, without specifying how these methods should work.</div>
        
        <div class="question">Q36. What is the difference between an interface and an abstract class in Java?</div>
        <div class="answer">An abstract class achieves partial abstraction (0 to 100%), whereas an interface achieves full abstraction. An abstract class can have abstract and non-abstract methods, whereas an interface can have only abstract methods. (Since Java 8, it can have default and static methods also.)</div>
        
        <div class="question">Q37. Can you provide examples of when to use an interface versus when to extend a class?</div>
        <div class="answer">Use an interface when we want to list the methods a class should have, without detailing how they work. Use class extension when we want a new class to inherit features and behaviors from an existing class and possibly modify them.</div>
        
        <div class="question">Q38. How do you use multiple inheritance in Java using interfaces?</div>
        <div class="answer">In Java, we can't inherit features from multiple classes directly, but we can use interfaces for a similar effect. A class can follow the guidelines of many interfaces at once, which lets it combine many sets of capabilities.</div>
        
        <div class="question">Q39. Can an interface in Java contain static methods, and if so, how can they be used?</div>
        <div class="answer">Yes, interfaces in Java can have static methods, which you can use without creating an instance of the class.</div>
        
        <div class="question">Q40. When would you use an interface, and when would you use an abstract class?</div>
        <div class="answer">Use an interface when you need multiple classes to share a contract without implementation. Use an abstract class when you need shared behavior (method implementations) along with method declarations.</div>
        
        <div class="question">Q41. Explain the difference between Comparable and Comparator interfaces. When would you use one over the other?</div>
        <div class="answer">Comparable is used for natural ordering and is implemented by the class itself, while Comparator is used for custom ordering and can be implemented externally. Use Comparable when objects have a single logical ordering; use Comparator when you need multiple ways to order objects.</div>
     <div class="question">Q41. What is a static method in an Interface, and how is it different from a default method in an interface?</div>
    <div class="answer">A static method in an interface belongs to the interface itself and cannot be overridden. A default method provides a default implementation for classes that implement the interface, and it can be overridden.</div>
    
    <div class="question">Q42. What is the diamond problem in Java and how does Java address it?</div>
    <div class="answer">The diamond problem occurs in multiple inheritance where a class inherits from two classes with a common ancestor. Java resolves this by not allowing multiple inheritance with classes, but interfaces can use default methods to avoid this issue.</div>
    
    <div class="question">Q43. How does the concept of default methods in interfaces help resolve the diamond problem?</div>
    <div class="answer">Default methods allow interfaces to provide method implementations, and in case of conflicts (multiple interfaces with the same default method), the implementing class must override the method, resolving ambiguity.</div>
    
    <div class="question">Q44. What does mean by encapsulation in java?</div>
    <div class="answer">Encapsulation in Java is like putting important information into a safe. We store data and the methods inside a class, and we control who can access or change the data by using specific methods.</div>
    
    <div class="question">Q45. How Encapsulation Enhances Software Security and Integrity:</div>
    <div class="answer">Encapsulation keeps important data hidden and safe. It only lets certain parts of our program use this data, which helps prevent mistakes and keeps the data secure from unwanted changes.</div>
    
    <div class="question">Q46. What is the concept of Serialization in Java?</div>
    <div class="answer">Serialization is the process of converting an object into a byte stream for storage or transmission. It allows objects to be saved and restored later or transferred over a network.</div>
    
    <div class="question">Q47. What is the purpose of the serialVersionUID in Java serialization?</div>
    <div class="answer">The serialVersionUID is a unique identifier for Serializable classes. It ensures that the serialized and deserialized objects are compatible by checking version consistency. If the serialVersionUID of the class doesn’t match during deserialization, an InvalidClassException is thrown, preventing incompatible class versions from being used.</div>
    
    <div class="question">Q48. What happens if the serialVersionUID of a class changes during deserialization?</div>
    <div class="answer">If the serialVersionUID changes between serialization and deserialization, the JVM considers the class as incompatible with the serialized object. This results in an InvalidClassException, as the runtime expects the version of the serialized class to match with the version defined in the deserialized class.</div>
    
    <div class="question">Q49. How can you prevent certain fields from being serialized in Java?</div>
    <div class="answer">You can prevent specific fields from being serialized by marking them with the transient keyword. When a field is declared as transient, it is excluded from the serialization process, meaning its value will not be saved when the object is serialized.</div>
    
    <div class="question">Q50. Can a class be serialized if one of its member fields is not serializable?</div>
    <div class="answer">A class can still be serialized even if one of its member fields is not serializable. However, you must mark the non-serializable field as transient. If the field is not transient and is not serializable, attempting to serialize the object will result in a NotSerializableException.</div>
    
    <div class="question">Q51. What is the difference between writeObject() and readObject() methods in Java serialization?</div>
    <div class="answer">The writeObject() and readObject() methods allow customization of the serialization and deserialization processes. writeObject() is used to customize how an object is serialized, while readObject() customizes how it is deserialized. These methods can be overridden to handle complex scenarios, such as serializing transient fields or managing class versioning.</div>
    
    <div class="question">Q52. Is it possible to serialize static fields in Java? Why or why not?</div>
    <div class="answer">No, static fields are not serialized in Java because they belong to the class, not to individual instances. Serialization is intended to capture the state of an object, and static fields are part of the class's state, not the object's state.</div>
    
    <div class="question">Q53. How do you serialize an object with circular references in Java?</div>
    <div class="answer">Java handles circular references during serialization by keeping track of references that have already been serialized. When the same object reference appears again, Java writes a reference to the already serialized object rather than serializing it again. This prevents infinite recursion and maintains the object graph structure.</div>
    
    <div class="question">Q54. What is method overloading in Java?</div>
    <div class="answer">Method overloading allows multiple methods in the same class to have the same name but different parameters. It provides flexibility by enabling multiple ways to call a method with different arguments.</div>
    
    <div class="question">Q55. How does the Java compiler determine which overloaded method to call?</div>
    <div class="answer">When we call an overloaded method, the Java compiler looks at the number and type of arguments provided and picks the method that matches these arguments best.</div>
    
    <div class="question">Q56. Is it possible to overload methods that differ only by their return type in Java?</div>
    <div class="answer">In Java, we cannot overload methods just by changing their return type. The methods must differ by their parameters for overloading to be valid.</div>
    
    <div class="question">Q57. What are the rules for method overloading in Java?</div>
    <div class="answer">The parameters must differ in how many there are, what type they are, or the order they are in.</div>
    
    <div class="question">Q58. What is method overriding in Java?</div>
    <div class="answer">To override a method, the new method in the subclass must have the same name, return type, and parameters as the method in the parent class. Also, the new method should not be less accessible than the original.</div>
<div class="question">Q58. What is method overriding in Java?</div>
    <div class="answer">To override a method, the new method in the subclass must have the same name, return type, and parameters as the method in the parent class. Also, the new method should not be less accessible than the original.</div>
   
   <div class="question">Q59. What are the rules and conditions for method overriding in Java?</div>
    <div class="answer">In Java, method overriding occurs when a subclass has a method with the same name, return type, and parameters as one in its parent class. The method in the subclass replaces the one in the parent class when called.</div>
   
   <div class="question">Q60. How does the @Override annotation influence method overriding?</div>
    <div class="answer">The @Override annotation tells the compiler that the method is supposed to replace one from its superclass. It's useful because it helps find mistakes if the method does not actually override an existing method from the parent class.</div>
   
   <div class="question">Q61. What happens if a superclass method is overridden by more than one subclass in Java?</div>
    <div class="answer">If different subclasses override the same method from a superclass, each subclass will have its own version of that method.</div>
   
   <div class="question">Q62. What is 'this' and 'super' keyword in Java?</div>
    <div class="answer">'this' is used to refer current class's instance as well as static members. 'super' keyword is used to access methods of the parent class.</div>
   
   <div class="question">Q63. Can 'this' keyword be assigned a new value in Java?</div>
    <div class="answer">No, this keyword cannot be assigned a new value in Java. It is a read-only reference that always points to the current object.</div>
   
   <div class="question">Q64. What happens if you attempt to use the "super" keyword in a class that doesn't have a superclass?</div>
    <div class="answer">If we attempt to use the "super" keyword in a class that doesn't have a superclass, a compilation error occurs. The "super" keyword is only applicable within subclasses to refer to members of the superclass.</div>
   
   <div class="question">Q65. Can the this or super keyword be used in a static method?</div>
    <div class="answer">No, the this and super keyword cannot be used in static methods. Static methods belong to the class, not instances, and super refers to the superclass's object context, which does not exist in a static context.</div>
   
   <div class="question">Q66. How does 'super' play a role in polymorphism?</div>
    <div class="answer">In Java, the super keyword lets a subclass use methods from its parent class, helping it behave in different ways and that is nothing but a polymorphic behavior.</div>
   
   <div class="question">Q67. What is the static keyword in Java?</div>
    <div class="answer">The static keyword in Java is used to indicate that a particular member (variable or method) belongs to the class, rather than any instance of the class. This means that the static member can be accessed without creating an instance of the class.</div>
   
   <div class="question">Q68. Can a static block throw an exception?</div>
    <div class="answer">Yes, a static block can throw an exception, but if it does, the exception must be handled within the block itself or declared using a throws clause in the class.</div>
   
   <div class="question">Q69. Can we override static methods in Java?</div>
    <div class="answer">No, static methods cannot be overridden in Java because method overriding is based on dynamic binding at runtime and static methods are bound at compile time.</div>
   
   <div class="question">Q70. Is it possible to access non-static members from within a static method?</div>
    <div class="answer">No, it's not possible to access non-static members (instance variables or methods) directly from within a static method. This is because static methods belong to the class itself, not to any specific instance. To access non-static members, you need to create an instance of the class and use that object to reference the non-static members.</div>
	<div class="question">Q71. What is static block?</div>
    <div class="answer">To initialize static variables, the statements inside static block are executed only once, when the class is loaded in the memory.</div>
    
    <div class="question">Q72. Can we print something on console without main method in Java?</div>
    <div class="answer">Prior to Java 8, yes, we can print something without main method but it's not possible from Java 8 onwards.</div>
    
    <div class="question">Q73. What is final keyword in Java?</div>
    <div class="answer">The 'final' keyword is used to declare constants, making variables unchangeable once assigned, or to prevent method overriding or class inheritance.</div>
    
    <div class="question">Q74. What are some common use cases for using final variables in Java programming?</div>
    <div class="answer">Common use cases for using final variables in Java programming include defining constants, parameters passed to methods, and local variables in lambdas or anonymous inner classes.</div>
    
    <div class="question">Q75. How does the "final" keyword contribute to immutability and thread safety in Java?</div>
    <div class="answer">The "final" keyword contributes to immutability and thread safety in Java by ensuring that the value of a variable cannot be changed once assigned, preventing unintended modifications and potential concurrency issues.</div>
    
    <div class="question">Q76. Can you describe any performance considerations related to using final?</div>
    <div class="answer">The final keyword improves the performance by reducing call overhead.</div>
    
    <div class="question">Q77. What is a functional interface?</div>
    <div class="answer">Functional interfaces in Java are interfaces with just one abstract method. They are used to create lambda expressions, and instances of these interfaces can be created with lambdas, method references, or constructor references.</div>
    
    <div class="question">Q78. Can a functional interface extend another interface?</div>
    <div class="answer">No, as a functional interface allows only a single abstract method. However, a functional interface can inherit another interface if it contains only static and default methods.</div>
    
    <div class="question">Q79. Advantages of using a functional interface.</div>
    <div class="answer">Functional interfaces, which contain only one abstract method, are key to enabling functional programming in Java. They offer concise and readable code through lambda expressions and method references, improving code simplicity. Functional interfaces allow easy parallel processing, better abstraction, and reusability, especially in scenarios like streams and event handling, promoting a cleaner and more expressive programming style.</div>


<h2>Java 8 basics</h2>

 <div class="question">Q1. Can you tell me some new features that were introduced in Java 8?</div>
    <div class="answer">Lambda Expressions, Stream API, Method References, Default Methods, Optional Class, New Date-Time API are the new features that were introduced in Java 8.</div>

    <div class="question">Q2. Why optional class, lambda expressions, and stream API were introduced in Java 8?</div>
    <div class="answer">Optional class was introduced in Java 8 as a way to address the problem of null references. Lambda expressions were introduced in Java 8 to make it easier to write code for interfaces that have only one method, using a simpler and more direct style. The Stream API was introduced in Java 8 to help developers process collections of data in a more straightforward and efficient way, especially for bulk operations like filtering or sorting.</div>

    <div class="question">Q3. Difference between filter and map function of Stream API?</div>
    <div class="answer">filter() eliminates elements of a collection where the condition is not satisfied, whereas map() is used to perform an operation on all elements; hence, it returns all elements of the collection.</div>

    <div class="question">Q4. Can you tell me some new features that were introduced in Java 11?</div>
    <div class="answer">HTTP Client, Epsilon Garbage Collector, Z Garbage Collector, Local-Variable Syntax for Lambda Parameters are some of the new features. Additionally, methods like isBlank(), strip(), stripLeading(), stripTrailing(), and repeat() were introduced for strings.</div>

    <div class="question">Q5. Can you tell me some new features that were introduced in Java 17?</div>
    <div class="answer">Sealed Classes, Pattern Matching for switch, and the Foreign Function and Memory API are some examples.</div>

    <div class="question">Q6. Can you tell me some new features that were introduced in Java 21?</div>
    <div class="answer">Virtual Threads, Structured Concurrency, Scoped Values, Sequenced Collections, and Record Pattern are some examples.</div>

    <div class="question">Q7. Which is faster, traditional for loop or Streams?</div>
    <div class="answer">Traditional for loops are generally faster due to less overhead, but Streams provide better readability and are optimized for parallel processing in large datasets.</div>

    <div class="question">Q8. In which scenarios would you prefer traditional for loops and streams?</div>
    <div class="answer">Use traditional loops for simple, small datasets requiring maximum performance. Use Streams for more complex data transformations or when working with large datasets where readability, maintainability, and potential parallelism are prioritized.</div>

    <div class="question">Q9. Explain intermediate and terminal operations in Streams.</div>
    <div class="answer">Intermediate operations (e.g., filter(), map()) return another stream and are lazy (executed only when a terminal operation is called). Terminal operations (e.g., forEach(), collect()) trigger the actual processing of the stream and produce a result or side effect.</div>

    <div class="question">Q10. Differences in Interface from Java 7 to Java 8.</div>
    <div class="answer">In Java 7, interfaces could only have abstract methods. Java 8 introduced default and static methods, allowing interfaces to have method implementations.</div>

    <div class="question">Q11. Use of String.join(….) in Java 8?</div>
    <div class="answer">String.join() concatenates a sequence of strings with a specified delimiter, simplifying string joining operations.</div>

<h2>Java 8 advance</h2>

 <div class="question">Q1. What are the new features introduced in Java 8?</div>
    <div class="answer">Java 8 introduced several significant features that enhanced the language's capabilities and performance. Key additions include Lambda Expressions for concise and functional-style programming, the Stream API for efficient data processing, and the new Date and Time API for improved date handling. Java 8 also introduced default and static methods in interfaces, allowing more complex interface designs, and the Optional class to better handle null values. These features collectively made Java more flexible and powerful, especially for handling collections and concurrency.</div>

    <div class="question">Q2. What is a lambda expression in Java 8, and what are its benefits?</div>
    <div class="answer">Lambda expressions in Java 8 are a way to implement methods from functional interfaces (interfaces with a single abstract method) in a clear and concise manner, using an arrow syntax. The benefits of lambda expressions include reducing the amount of boilerplate code, enhancing readability, and making it easier to use functional programming patterns. They are particularly useful for simplifying code when using collections and APIs that support concurrency, such as the Stream API.</div>

    <div class="question">Q3. What is the difference between a Lambda Expression and an Anonymous Inner Class?</div>
    <div class="answer">Lambda expressions and anonymous inner classes in Java both enable you to implement methods without declaring a formal class, but they differ significantly in simplicity and functionality. Lambda expressions are more concise and focus on passing a single piece of functionality, typically to a single method in a functional interface. In contrast, anonymous inner classes are more verbose and can implement multiple methods from an interface or subclass. Lambda expressions also do not have their own scope, unlike anonymous inner classes, which can shadow variables from the enclosing class.</div>

    <div class="question">Q4. What is a Functional Interface in Java 8?</div>
    <div class="answer">In Java 8, a Functional Interface is an interface that contains only one abstract method. These interfaces are intended for use with lambda expressions, which provide the implementation of the abstract method. Functional Interfaces can include other default or static methods without affecting their status. The @FunctionalInterface annotation, although not required, can be used to indicate that an interface is intended to be a Functional Interface, helping to avoid accidental addition of abstract methods in the future.</div>

    <div class="question">Q5. What are some of the predefined functional interfaces in Java 8?</div>
    <div class="answer">Java 8 introduced several predefined functional interfaces to facilitate lambda expressions and method references. Key examples include Consumer, which accepts a single input and returns no result; Supplier, which provides a result without accepting any input; Function, which takes one argument and returns a result; Predicate, which takes one argument and returns a boolean; and BiFunction, which takes two arguments and returns a result. These interfaces streamline the creation of lambda expressions for common functional programming patterns.</div>

    <div class="question">Q6. What is the Streams API in Java 8? How does it work?</div>
    <div class="answer">The Streams API in Java 8 is a powerful tool for processing sequences of elements in a declarative way. It works by providing a high-level abstraction for performing operations like filtering, mapping, sorting, and more, on collections of objects without modifying the underlying data source. Streams can be sequential or parallel, allowing for efficient data processing. The API emphasizes readability and simplicity, using functional-style operations that leverage lambda expressions for concise and expressive coding.</div>

    <div class="question">Q7. Explain the difference between map() and flatMap() in Streams.</div>
    <div class="answer">In Java Streams, map() and flatMap() are both transformation functions but serve different purposes. map() takes a function and applies it to each element in the stream, returning a stream of the results—essentially transforming each element into a new form. Conversely, flatMap() also applies a function to elements, but each function result is expected to be a stream itself; flatMap() then "flattens" these multiple streams into a single stream. This is particularly useful for handling nested collections or arrays.</div>

    <div class="question">Q8. How can you filter a collection using Streams in Java 8?</div>
    <div class="answer">In Java 8, you can filter a collection using the Streams API by converting the collection to a stream, applying a filter() method, and then specifying a condition within the filter method. The filter() method takes a predicate, which is a functional interface representing a condition that each element of the stream must meet. Elements that satisfy the predicate are retained in the stream, while others are discarded. You can then collect these filtered elements into a new collection if needed.</div>

<div class="question">Q9. What are Default Methods in Java 8, and why were they introduced?</div>
    <div class="answer">Default methods in Java 8 are methods added to interfaces that include an implementation. They were introduced to enable new functionality in interfaces without breaking existing implementations of these interfaces. This feature allows Java to add enhancements to the standard libraries (like the Collections API) while ensuring backward compatibility with older versions. Default methods help evolve interfaces over time without disrupting the classes that implement these interfaces.</div>

    <div class="question">Q10. How are Static Methods in interfaces different from Default Methods in Java 8?</div>
    <div class="answer">In Java 8, static methods in interfaces allow the interface to define methods that can be called on the interface itself, not on instances of classes that implement the interface. This is similar to static methods in classes. Conversely, default methods are methods within an interface that have an implementation. They can be called on instances of classes that implement the interface, providing default behavior without requiring the implementing class to override the method. Static methods help in utility or helper functionality, while default methods aid in enhancing interfaces without breaking existing implementations.</div>

    <div class="question">Q11. What is Optional in Java 8, and how is it used?</div>
    <div class="answer">Optional in Java 8 is a container object used to represent the presence or absence of a value, effectively reducing the problems caused by null references (often termed the billion-dollar mistake). It provides a way to express optional values without using null. This approach helps prevent NullPointerExceptions when accessing values that might not exist. Optional is commonly used in situations where a method might return a meaningful value or no value at all, allowing developers to handle the absence of a value gracefully using methods like isPresent(), ifPresent(), and orElse().</div>

    <div class="question">Q12. How do you handle null values in Java 8 using Optional?</div>
    <div class="answer">In Java 8, Optional is used to handle null values gracefully. You can create an Optional object that may or may not contain a non-null value by using methods like Optional.ofNullable(). This method returns an Optional object that is either empty (if the value is null) or contains the value. You can then use methods like orElse() to provide a default value if the Optional is empty, or ifPresent() to execute a block of code only if a value is present. This approach helps avoid NullPointerException and makes your code cleaner and safer.</div>

    <div class="question">Q13. What is the difference between findFirst() and findAny() in Streams?</div>
    <div class="answer">In Java Streams, findFirst() and findAny() are terminal operations that return an Optional describing an element of the stream. findFirst() returns the first element in the stream according to the encounter order, which is particularly useful in sequential streams. On the other hand, findAny() can return any element from the stream and is more performance-efficient in parallel streams, as it allows more flexibility in which element is returned, potentially reducing the time spent on synchronous operations.</div>

    <div class="question">Q14. Explain the purpose of the Collectors class in Java 8.</div>
    <div class="answer">The Collectors class in Java 8 serves as a utility to help with common mutable reductions and collection operations on streams, like grouping elements, summarizing elements, or converting them into collections like Lists, Sets, or Maps. It provides a set of pre-defined static methods that can be used with the collect() method of the Stream API. This makes it easy to perform complex tasks like joining strings, averaging numbers, or categorizing items in a streamlined and efficient manner.</div>
 <div class="question">Q15. What is the significance of the forEach() method in Java 8?</div>
    <div class="answer">The forEach() method in Java 8 is significant for its ability to simplify iterations over collections, including those that are part of the Java Collections Framework or arrays. Implemented as a default method in the Iterable interface and as a terminal operation in the Stream API, forEach() allows you to execute a specific action on each element of a collection or stream. This method enhances readability and reduces boilerplate code associated with traditional for-loops, making operations more concise and expressive, especially when combined with lambda expressions.</div>
    
    <div class="question">Q16. How does Java 8 handle parallel processing with the Streams API?</div>
    <div class="answer">Java 8 enhances parallel processing capabilities through the Streams API, which allows for easy parallelization of operations on collections. By invoking the parallelStream() method on a collection, you can create a parallel stream that divides the data into multiple parts, which are processed concurrently across different threads. This leverages multicore processors effectively to improve performance for large data sets. The framework handles the decomposition and merging of data, simplifying parallel execution without the need for explicit thread management.</div>
    
    <div class="question">Q17. What is the purpose of the Predicate functional interface in Java 8?</div>
    <div class="answer">The Predicate functional interface in Java 8 is designed to represent a boolean-valued function of one argument. Its primary purpose is to evaluate a given predicate (a condition that returns true or false) on objects of a specific type. Predicates are often used for filtering or matching objects. For example, in the Streams API, the filter() method uses a Predicate to determine which elements should be included in the resulting stream based on whether they satisfy the predicate. This functionality is crucial for conditional operations in collection processing.</div>
    
    <div class="question">Q18. How do you create an infinite stream in Java 8?</div>
    <div class="answer">In Java 8, you can create an infinite stream using the Stream.iterate or Stream.generate methods. Stream.iterate repeatedly applies a given function to a seed value to produce an infinite sequence, for example, generating an infinite stream of natural numbers by successively adding one. Stream.generate takes a Supplier to provide new values and produces an infinite stream of those values. Both methods yield infinite streams that require limiting actions to prevent endless processing.</div>
    
    <div class="question">Q19. What is the Function interface in Java 8, and how is it used?</div>
    <div class="answer">The Function interface in Java 8 is a functional interface that represents a function that accepts one argument and produces a result. It is commonly used for transforming objects of one type into another, such as converting strings to integers or applying mathematical operations to numbers. The interface is generic, allowing for flexibility in specifying the types of the input and output. In the Streams API, the Function interface is often passed to the map() method to transform stream elements.</div>
    
    <div class="question">Q20. What are method references in Java 8, and how do they relate to Lambda Expressions?</div>
    <div class="answer">Method references in Java 8 are a shorthand notation of lambda expressions that refer directly to methods by their names. They serve as a clean and concise way to express instances where lambda expressions simply call existing methods. For example, instead of using a lambda like (x) -> System.out.println(x), you can use the method reference System.out::println. This syntax directly points to the println method, improving code clarity and reducing verbosity when interfacing with functional interfaces.</div>
    
    <div class="question">Q21. How can you sort a collection using Streams in Java 8?</div>
    <div class="answer">In Java 8, you can sort a collection using the Streams API by converting the collection into a stream, applying the sorted() method, and then collecting the results back into a collection. The sorted() method can be used without arguments to sort in natural order, or with a comparator if a specific sorting order is needed. Finally, you use the collect(Collectors.toList()) (or another appropriate collector) to gather the sorted elements back into a collection like a list or set. This method provides a fluent, functional approach to sorting data.</div>
    
    <div class="question">Q22. What is the use of reduce() in Java 8 Streams?</div>
    <div class="answer">The reduce() method in Java 8 Streams is used to combine all elements of the stream into a single result. This method takes a binary operator as a parameter, which is used to accumulate the elements of the stream. Reduce() is useful for performing operations like summing all numbers in a list, finding the maximum or minimum value, or accumulating elements into a single result. This method essentially reduces a stream of elements to one summary result based on the provided operation.</div>
  <div class="question">Q23. How does the filter() method work in Java 8?</div>
    <div class="answer">The filter() method in Java 8's Streams API is used to evaluate each element in a stream against a given predicate, which is a functional interface that defines a condition returning a boolean value. Elements that pass this condition (i.e., for which the predicate returns true) are included in the resulting stream, while those that do not pass are discarded. This method is particularly useful for extracting subsets of data from collections based on specific criteria.</div>
    
    <div class="question">Q24. What is the significance of Collectors.toList() in Java 8 Streams?</div>
    <div class="answer">In Java 8, Collectors.toList() is a collector used in the Stream API to gather stream elements into a new list. This method is typically used with the collect() terminal operation to accumulate the elements of a stream into a list after performing operations like filtering, mapping, or sorting. It simplifies the process of converting a stream back into a collection, making it highly useful for collecting processed data conveniently and efficiently into a commonly used data structure.</div>
    
    <div class="question">Q25. Can you explain how Stream.of() works in Java 8?</div>
    <div class="answer">In Java 8, Stream.of() is a static method used to create a stream from a set of individual objects. You can pass one or more objects to this method, and it will return a stream containing the elements you provided. This is particularly useful for quickly turning a few elements into a stream without needing to create a collection first. It's a convenient way to work with a fixed number of elements for stream operations like filtering, mapping, or collecting.</div>
    
    <div class="question">Q26. How is Java 8 backward-compatible with earlier versions of Java?</div>
    <div class="answer">Java 8 maintains backward compatibility with earlier versions by ensuring that existing interfaces can be expanded with new features—like lambda expressions, method references, and stream APIs— without breaking the implementations that depend on older versions. For example, the introduction of default methods in interfaces allows new methods to be added without requiring changes in the implementing classes. This design approach ensures that older Java applications can still run without modification in the newer Java 8 environment.</div>
    
    <div class="question">Q27. What is the difference between limit() and skip() in Java 8 Streams?</div>
    <div class="answer">In Java 8 Streams, limit() and skip() are two intermediate operations that manage the size of the stream. limit(n) is used to truncate the stream so that it contains no more than n elements, effectively limiting the number of items processed downstream. On the other hand, skip(n) discards the first n elements of the stream, allowing the stream to start processing from the element that follows. Together, these methods help in controlling stream flow for specific processing needs.</div>
    
    <div class="question">Q28. Explain how to convert a list to a map using Streams in Java 8.</div>
    <div class="answer">In Java 8, you can convert a list to a map using the Streams API by utilizing the collect(Collectors.toMap()) method. First, convert the list into a stream. Then, use toMap() where you specify functions for determining the keys and values for the map. For example, if you have a list of objects, you might use an attribute of the objects as the key and the objects themselves as values. This method effectively organizes elements of a list into a map based on defined criteria.</div>
    
    <div class="question">Q29. What is the difference between Stream.iterate() and Stream.generate()?</div>
    <div class="answer">Stream.iterate() and Stream.generate() in Java 8 are both methods for creating infinite streams, but they do so in different ways. Stream.iterate() takes a seed (initial value) and a function, applying the function repeatedly to generate a sequence (e.g., creating a stream of powers of two). Stream.generate(), on the other hand, uses a supplier to provide new values, which doesn't depend on the previous element. This makes Stream.generate() suitable for generating streams where each element is independent of the others.</div>
    
    <div class="question">Q30. How can you apply a custom comparator in a stream pipeline in Java 8?</div>
    <div class="answer">In Java 8, you can apply a custom comparator in a stream pipeline using the sorted() method. First, define your comparator, which dictates how the elements should be compared based on your custom criteria. Then, pass this comparator to the sorted() method within your stream pipeline. For example, if you're streaming a list of objects, you can sort them by a specific attribute using a comparator that compares that attribute. This method integrates seamlessly into the stream, allowing for flexible sorting within the pipeline.</div>
<div class="question">Q31. Can you explain why Java 8 introduced the concept of Default Methods in interfaces, and what problem does it solve?</div>
    <div class="answer">Java 8 introduced default methods in interfaces to enable interfaces to evolve while maintaining backward compatibility with older versions. Previously, adding a new method to an interface required all implementing classes to define that method, potentially breaking existing applications. Default methods allow new functionalities to be added to interfaces without obligating implementing classes to change. This helps in enhancing interfaces with new methods while ensuring that existing implementations do not fail.</div>

    <div class="question">Q32. Is it possible to use this and super in a Lambda expression? Explain why or why not.</div>
    <div class="answer">In Java, within lambda expressions, this and super keywords do not refer to the lambda expression itself but rather to the enclosing instance where the lambda is defined. This means this refers to the instance of the class where the lambda is created, and super refers to the superclass of this instance. Therefore, while you can use this and super in lambda expressions, they do not behave as they might be expected to within traditional methods or anonymous inner classes, where they refer directly to the current or parent class object respectively.</div>

    <div class="question">Q33. How can a Lambda expression access variables outside its scope? What is the concept behind it?</div>
    <div class="answer">Lambda expressions in Java can access variables outside their scope, specifically final or effectively final variables from their enclosing scope. An effectively final variable is one that is not modified after initialization. This restriction ensures that the lambda expression is state-consistent and can be safely called multiple times without side effects that could arise from modifying external variables. This capability allows lambda expressions to capture and use local variables in a functional-style programming approach, enhancing their utility and flexibility.</div>

    <div class="question">Q34. Can a Lambda expression throw an exception? How can you handle exceptions in a Lambda?</div>
    <div class="answer">Yes, lambda expressions in Java can throw exceptions, just like regular methods. However, if the functional interface the lambda is implementing does not declare an exception, any checked exceptions thrown within the lambda must either be caught or converted to unchecked exceptions. To handle exceptions directly within a lambda, you can use a try-catch block surrounding the code that might throw the exception. This approach allows the lambda to manage exceptions internally without affecting the external execution flow.</div>

    <div class="question">Q35. What is the difference between Optional.of() and Optional.ofNullable()?</div>
    <div class="answer">In Java, Optional.of() and Optional.ofNullable() are methods used to create Optional objects, but they handle null values differently. Optional.of(value) requires a non-null value and throws a NullPointerException if passed a null. This is suitable when you are certain the value is not null. In contrast, Optional.ofNullable(value) is safe for use with values that might be null. It returns an empty Optional if the value is null, thus avoiding any exceptions.</div>

    <div class="question">Q36. How does the internal working of Stream.sorted() differ when using natural ordering versus custom comparator?</div>
    <div class="answer">The Stream.sorted() method in Java sorts the elements of a stream either using natural ordering or a custom comparator. When using natural ordering, it assumes that the stream elements implement the Comparable interface and sorts them according to their compareTo method. With a custom comparator, you provide a Comparator object that defines a different sorting logic. This allows for flexibility in sorting based on attributes or rules that do not adhere to the natural order of the elements. Both methods internally use efficient sorting algorithms optimized for performance and stability.</div>

    <div class="question">Q37. Can you use Optional as a method parameter? Why should or shouldn’t you do this?</div>
    <div class="answer">Using Optional as a method parameter in Java is technically possible but generally discouraged. The primary purpose of Optional is to provide a more expressive alternative to null references and to enhance readability and safety in APIs by clearly indicating that a method might not return a value. Using Optional as a parameter complicates method signatures and usage, potentially obscuring intent and leading to less clean code. Instead, it's better to use Optional for return types where it clarifies that a method might not produce a value.</div>
	
 <div class="question">Q38. What will happen if you try to modify a local variable inside a Lambda expression?</div>
    <div class="answer">In Java, if you try to modify a local variable inside a lambda expression, you'll encounter a compile-time error. Local variables accessed from within a lambda must be final or effectively final—meaning once they are initialized, they cannot be modified. This restriction ensures that the lambda does not introduce side effects by altering the local environment, preserving thread safety and functional programming principles where functions do not modify the state outside their scope.</div>

    <div class="question">Q39. Can you use the synchronized keyword inside a Lambda expression?</div>
    <div class="answer">No, you cannot directly use the synchronized keyword inside the body of a lambda expression in Java. Lambda expressions are meant to be short, stateless, and concise blocks of code. They do not have an intrinsic lock object to synchronize on, unlike methods in a class. If synchronization is necessary within a lambda, you must handle it externally, such as synchronizing on an external object or using higher-level concurrency utilities provided by Java.</div>

    <div class="question">Q40. What is the difference between count(), sum(), and reduce() in Java 8 Streams?</div>
    <div class="answer">In Java 8 Streams, count(), sum(), and reduce() serve different purposes: count() simply returns the number of elements in the stream, useful for tallying items. sum(), available in specialized stream types like IntStream, LongStream, and DoubleStream, calculates the total of the elements. reduce(), on the other hand, is a more general method that combines all elements in the stream using a provided binary operator to produce a single result, allowing for more complex accumulations beyond just summing.</div>
	
<h2>Concurrency and multi-threading</h2>

	 <div class="question">Q1. What is a thread in Java and how can we create it?</div>
    <div class="answer">A thread in Java is a pathway of execution within a program. You can create a thread by extending the Thread class or implementing the Runnable interface.</div>

    <div class="question">Q2. Can you explain the lifecycle of a Java thread?</div>
    <div class="answer">A Java thread lifecycle includes states: New, Runnable, Blocked, Waiting, Timed Waiting, and Terminated.</div>

    <div class="question">Q3. How would you handle a scenario where two threads need to update the same data structure?</div>
    <div class="answer">Use synchronized blocks or methods to ensure that only one thread can access the data structure at a time, preventing concurrent modification issues.</div>

    <div class="question">Q4. Can we start a thread twice?</div>
    <div class="answer">No, a thread in Java cannot be started more than once. Attempting to restart a thread that has already run will throw an IllegalThreadStateException.</div>

    <div class="question">Q5. What is the difference between Thread class and Runnable interface in Java?</div>
    <div class="answer">The Thread class defines a thread of execution, whereas the Runnable interface should be implemented by any class whose instances are intended to be executed by a thread.</div>

    <div class="question">Q6. How can you ensure a method is thread-safe in Java?</div>
    <div class="answer">To ensure thread safety, use synchronization mechanisms like synchronized blocks, volatile variables, or concurrent data structures.</div>

    <div class="question">Q7. What are volatile variables?</div>
    <div class="answer">Volatile variables in Java are used to indicate that a variable's value will be modified by different threads, ensuring that the value read is always the latest written.</div>

    <div class="question">Q8. What is thread synchronization and why is it important?</div>
    <div class="answer">Thread synchronization controls the access of multiple threads to shared resources to prevent data inconsistency and ensure thread safety.</div>

    <div class="question">Q9. Can you describe a scenario where you would use wait() and notify() methods in thread communication?</div>
    <div class="answer">Use wait() and notify() for inter-thread communication, like when one thread needs to wait for another to complete a task before proceeding.</div>

    <div class="question">Q10. What challenges might you face with multithreaded programs in Java?</div>
    <div class="answer">In Java, multithreaded programming can lead to issues like deadlocks, race conditions, and resource contention, which complicate debugging and affect performance. Managing thread safety and synchronization efficiently is also a significant challenge.</div>

    <div class="question">Q11. What is the Java Memory Model (JMM) and how is it linked to threads?</div>
    <div class="answer">The Java Memory Model (JMM) defines the rules by which Java programs achieve consistency when reading and writing variables across multiple threads, ensuring all threads have a consistent view of memory. It governs how changes to variables are propagated and how synchronization constructs like volatile and synchronized affect visibility and ordering of operations.</div>

<h2>Concurrency and Multithreading Advance</h2>

<div class="question">Q1. How would you ensure that a shared resource is accessed safely by multiple threads?</div>
    <div class="answer">To ensure safe access to a shared resource by multiple threads in Java, you can use synchronization. This involves using the synchronized keyword to lock an object or a method while a thread is using it. Only one thread can hold the lock at a time, preventing other threads from accessing the locked code until the lock is released. This mechanism helps avoid conflicts and data corruption by ensuring that only one thread can modify the shared resource at any given time.</div>

    <div class="question">Q2. Explain the synchronized keyword in Java. How does it work?</div>
    <div class="answer">The synchronized keyword in Java is used to control access to a critical section of code by locking an object or method so that only one thread can execute it at a time. When a thread enters a synchronized block or method, it obtains a lock on the specified object or class, preventing other threads from entering any synchronized blocks or methods that lock the same object or class until the lock is released. This ensures that the shared data is accessed in a thread-safe manner.</div>

    <div class="question">Q3. What are the differences between using synchronized on a method versus on a block of code?</div>
    <div class="answer">Using synchronized on a method locks the entire method, so when a thread enters this method, no other thread can enter any synchronized method of that object until the lock is released. However, using synchronized on a block of code only locks that specific block. This allows finer control over which parts of the code need synchronization, potentially improving performance by reducing the scope of locking to just critical sections of the code.</div>

    <div class="question">Q4. What is the significance of the volatile keyword in Java concurrency?</div>
    <div class="answer">The volatile keyword in Java concurrency is crucial for ensuring visibility and preventing caching of variables across threads. When a variable is declared as volatile, it tells the JVM that every read or write to that variable should go directly to main memory, bypassing any intermediate caches. This ensures that changes made to a volatile variable by one thread are immediately visible to other threads, maintaining data consistency across threads without using synchronized blocks.</div>

    <div class="question">Q5. How does the introduction of Lambda expressions change the way Java handles concurrency?</div>
    <div class="answer">Lambda expressions in Java simplify the way concurrency is handled primarily by reducing the verbosity and complexity of anonymous classes, making code more readable and concise. They facilitate the use of functional programming techniques within Java, particularly in dealing with concurrency frameworks like Streams and CompletableFuture, which rely heavily on passing behaviors (functions) as arguments. Lambdas enable cleaner and more maintainable concurrent processing by allowing developers to focus on the logic rather than boilerplate code.</div>

    <div class="question">Q6. Explain the Java concurrency model.</div>
    <div class="answer">The Java concurrency model is built around threads, which are units of execution within a process. Java provides a rich set of tools and APIs, like Thread class, Runnable interface, and concurrency utilities in the java.util.concurrent package, to manage and synchronize these threads. This model allows multiple threads to run in parallel, enhancing performance especially in multi-core processors. Synchronization and coordination between threads are achieved through mechanisms like locks, synchronized blocks/methods, and concurrent data structures, ensuring safe communication between threads.</div>

    <div class="question">Q7. What are the challenges associated with Java’s thread management?</div>
    <div class="answer">Java's thread management presents several challenges, including the complexity of ensuring thread safety, which requires careful synchronization to avoid issues like data corruption and deadlocks. Managing thread life cycles and resource allocation efficiently can also be difficult, as threads consume system resources. Overuse of threading can lead to high CPU usage and slower application performance. Additionally, debugging multithreaded applications is often more complex due to the unpredictable nature of thread execution.</div>

    <div class="question">Q8. Can volatile variables be used as a replacement for synchronization?</div>
    <div class="answer">Volatile variables cannot fully replace synchronization in Java. While they ensure that the value of a variable is consistently updated across all threads (ensuring visibility), they do not provide the mutual exclusion necessary for complex synchronization. For operations that go beyond the simple reading and writing of a single variable, such as incrementing a counter or checking and modifying multiple variables, synchronized blocks or locks are necessary to prevent race conditions and ensure data integrity.</div>
	<div class="question">Q9. Can a deadlock occur with a single thread?</div>
    <div class="answer">A deadlock typically involves two or more threads, where each thread is waiting for another to release a resource they need. However, a single thread can experience a similar issue called a self-deadlock or resource starvation if it recursively acquires a non-reentrant lock it already holds without releasing it first.</div>
    
    <div class="question">Q10. What is a synchronized collection, and how does it differ from a concurrent collection?</div>
    <div class="answer">A synchronized collection in Java is a standard collection that has been wrapped with synchronization to make it thread-safe. A concurrent collection, like those in java.util.concurrent, is designed for simultaneous access with better performance using finer-grained locking or lock-free mechanisms.</div>
    
    <div class="question">Q11. How does Java handle multi-threading?</div>
    <div class="answer">Java handles multi-threading by allowing multiple threads to run concurrently within a single application using the Thread class and Runnable interface. Java provides built-in support for thread lifecycle management, synchronization, and inter-thread communication.</div>
    
    <div class="question">Q12. What are the differences between Runnable and Callable in Java concurrency?</div>
    <div class="answer">Runnable has a run() method that does not return a result, while Callable includes a call() method that returns a result and can throw checked exceptions, making it more suitable for tasks requiring outcomes.</div>
    
    <div class="question">Q13. How do you handle thread interruption in Java?</div>
    <div class="answer">Thread interruption in Java is handled by checking the interrupted status using Thread.interrupted() or isInterrupted(). A thread should properly clean up resources before stopping execution upon detecting an interruption.</div>
    
    <div class="question">Q14. How do you check if a Thread holds a lock or not?</div>
    <div class="answer">You can check if a thread holds a lock using Thread.holdsLock(Object obj), which returns true if the current thread holds the monitor lock on the specified object.</div>
    
    <div class="question">Q15. What are use cases of ThreadLocal variables in Java?</div>
    <div class="answer">ThreadLocal variables provide thread-specific data storage without synchronization. They are useful for maintaining per-thread user sessions, transaction IDs, or temporary credentials.</div>
    
    <div class="question">Q16. What is the role of ExecutorService in the Executor Framework? What methods does it provide?</div>
    <div class="answer">ExecutorService manages and controls thread execution efficiently. It provides methods such as submit() for executing callable tasks, execute() for running runnable tasks, and shutdown() to stop the executor service gracefully.</div>
	 <div class="question">Q17. What is the difference between submit() and execute() methods in the Executor Framework?</div>
    <div class="answer">In the Java Executor Framework, the submit() and execute() methods both schedule tasks for execution, but they differ in key aspects. The execute() method is used to run Runnable tasks and does not return any result. Conversely, the submit() method can accept both Runnable and Callable tasks, returning a Future object that can be used to retrieve the Callable task’s result or check the status of the Runnable. This makes submit() more flexible and useful for handling tasks that produce results.</div>

    <div class="question">Q18. What is the RejectedExecutionHandler in ThreadPoolExecutor? How can you customize it?</div>
    <div class="answer">The RejectedExecutionHandler in a ThreadPoolExecutor in Java is an interface that handles tasks that cannot be executed by the thread pool, typically when the pool is fully utilized and the task queue is full. You can customize it by implementing this interface and defining your own rejectedExecution method. This method decides what to do with the rejected tasks, such as logging them, running them on a different executor, or implementing a backoff and retry mechanism. This customization allows for more robust handling of task overflows in applications.</div>

    <div class="question">Q19. How does ConcurrentHashMap work internally?</div>
    <div class="answer">The ConcurrentHashMap in Java is designed for concurrent access without the extensive use of synchronization. Internally, it divides the data into segments, effectively a hashtable-like structure. Each segment manages its own lock, reducing contention by allowing multiple threads to concurrently access different segments of the map. This means that read operations can generally be performed without locking, and writes require minimal locking, significantly increasing performance over a Hashtable or synchronized Map under concurrent access scenarios.</div>

    <div class="question">Q20. Difference Between synchronized and ReentrantLock?</div>
    <div class="answer">The synchronized keyword and ReentrantLock both provide locking mechanisms in Java, but they differ in functionality and flexibility. synchronized is easier to use and automatically handles locking and unlocking, but offers less control. In contrast, ReentrantLock provides more advanced features, such as the ability to try to acquire a lock without waiting forever, lock interruptibility, and support for fairness policies. Additionally, ReentrantLock allows multiple condition variables per lock, facilitating more complex synchronization scenarios.</div>

    <div class="question">Q21. What happens when an exception occurs inside a synchronized block?</div>
    <div class="answer">When an exception occurs inside a synchronized block in Java, the lock that was acquired when entering the synchronized block is automatically released. This allows other threads to enter the synchronized block or method once the current thread has exited due to the exception. Essentially, the synchronized mechanism ensures that locks are managed cleanly, even in the event of an exception, preventing deadlocks and allowing program execution to continue in other threads.</div>

    <div class="question">Q22. How do you get a thread dump in Java?</div>
    <div class="answer">To obtain a thread dump in Java, you can use several methods depending on the environment. One common way is to send a SIGQUIT signal by pressing Ctrl+\ in Unix/Linux or Ctrl+Break in Windows on the command line where the Java application is running. Alternatively, you can use tools like jstack with the process ID to generate a thread dump. This tool is part of the JDK and provides detailed information about the threads running in your Java application.</div>

    <div class="question">Q23. How to get a thread dump in Java?</div>
    <div class="answer">To obtain a thread dump in Java, you can use several methods depending on the environment. One common way is to send a SIGQUIT signal by pressing Ctrl+\ in Unix/Linux or Ctrl+Break in Windows on the command line where the Java application is running. Alternatively, you can use tools like jstack with the process ID to generate a thread dump. This tool is part of the JDK and provides detailed information about the threads running in your Java application.</div>

    <div class="question">Q24. What are the different ways to achieve synchronization in Java?</div>
    <div class="answer">In Java, synchronization can be achieved through several methods to ensure thread safety. The primary way is using the synchronized keyword, which can be applied to methods or blocks of code to restrict access to a resource to one thread at a time. Additionally, Java provides volatile variables to ensure visibility of changes to variables across threads. More sophisticated synchronization can involve using classes from the java.util.concurrent package, like ReentrantLock, Semaphore, and CountDownLatch, which offer more control and flexibility than synchronized.</div>

    <div class="question">Q25. What is the difference between synchronized method and synchronized block?</div>
    <div class="answer">In Java, a synchronized method locks the entire method at the object or class level, depending on whether the method is an instance method or static, ensuring that only one thread can access it at a time. In contrast, a synchronized block provides more granular control by only locking a specific section of a method or a specific object, which can minimize waiting times for threads and improve performance by reducing the scope of the lock.</div>

<h2>Collection Framework Basics</h2>

<div class="question">Q1. What is collection framework in Java?</div>
    <div class="answer">The Java Collection Framework is a set of tools that helps us organize, store, and manage groups of data easily. It includes various types of collections like lists, sets, and maps.</div>
    
    <div class="question">Q2. What are the main interfaces of the Java Collection Framework?</div>
    <div class="answer">The main parts of the Java Collection Framework are interfaces like Collection, List, Set, Queue, and Map. Each one helps manage data in different ways.</div>
    
    <div class="question">Q3. Can you explain how Iterator works within the Java Collection Framework?</div>
    <div class="answer">An Iterator is a tool in the Collection Framework that lets you go through a collection's elements one by one.</div>
    
    <div class="question">Q4. What are some common methods available in all Collection types?</div>
    <div class="answer">Some common methods all collection types have are add, remove, clear, size, and isEmpty. These methods let us add and remove items, check the size, and see if the collection is empty.</div>
    
    <div class="question">Q5. How does Java Collection Framework handle concurrency?</div>
    <div class="answer">The Collection Framework deals with multiple threads using special collection classes like ConcurrentHashMap and CopyOnWriteArrayList, which let different parts of our program modify the collection at the same time safely.</div>
    
    <div class="question">Q6. How do you choose the right collection type for a specific problem?</div>
    <div class="answer">To pick the right collection type, think about what we need: List if you want an ordered collection that can include duplicates, Set if you need unique elements, Queue for processing elements in order, and Map for storing pairs of keys and values.</div>
    
    <div class="question">Q7. What enhancements were made to the Java Collection Framework in Java 8?</div>
    <div class="answer">Java 8 made improvements to the Collection Framework by adding Streams, which make it easier to handle collections in bulk, and lambda expressions, which simplify writing code for operations on collections.</div>
    
    <div class="question">Q8. What is the difference between Iterator and ListIterator?</div>
    <div class="answer">Iterator allows forward traversal of a collection, while ListIterator extends Iterator functionality to allow bidirectional traversal of lists and also supports element modification.</div>
    
    <div class="question">Q9. Name of algorithm used by Arrays.sort(..) and Collections.sort(..)?</div>
    <div class="answer">Arrays.sort() uses a Dual-Pivot Quicksort algorithm for primitive types and TimSort for object arrays. Collections.sort() uses TimSort, a hybrid sorting algorithm combining merge sort and insertion sort.</div>
    
    <div class="question">Q10. How do you store elements in a set to preserve insertion order?</div>
    <div class="answer">Use a LinkedHashSet, which preserves the insertion order of elements.</div>
    
    <div class="question">Q11. How do you store elements in a way that they are sorted?</div>
    <div class="answer">Use a TreeSet or a TreeMap, which automatically sorts elements based on their natural ordering or a specified comparator.</div>
    
    <div class="question">Q12. What's the use case of ArrayList, LinkedList, and HashSet?</div>
    <div class="answer"><strong>ArrayList:</strong> Use it when you need efficient random access to elements via indices, like retrieving elements frequently from a list without altering it.</div>
    <div class="answer"><strong>LinkedList:</strong> Use it when you frequently add and remove elements from the beginning or middle of the list, such as implementing queues or stacks.</div>
    <div class="answer"><strong>HashSet:</strong> Use it when you need to ensure that there are no duplicates and require fast lookups, additions, and deletions. It is ideal for scenarios like checking membership existence, such as in a set of unique items or keys.</div>
    
    <div class="question">Q13. How does a HashSet ensure that there are no duplicates?</div>
    <div class="answer">A HashSet in Java uses a HashMap under the hood. Each element you add is treated as a key in this HashMap. Since keys in a HashMap are unique, HashSet automatically prevents any duplicate entries.</div>
	<div class="question">Q13. Can you describe how hashCode() and equals() work together in a collection?</div>
    <div class="answer">hashCode() determines which bucket an object goes into, while equals() checks equality between objects in the same bucket to handle collisions, ensuring that each key is unique.</div>
    
    <div class="question">Q14. Why is it important to override the hashCode method when you override equals? What would be the consequence if we don’t?</div>
    <div class="answer">Overriding hashCode() is crucial because hash-based collections like HashMap and HashSet use the hashcode to locate objects. Without consistent hashCode() and equals(), objects may not be found or stored correctly.</div>
    
    <div class="question">Q15. Can you give an example where a TreeSet is more appropriate than HashSet?</div>
    <div class="answer">A TreeSet is more appropriate than a HashSet when you need to maintain the elements in a sorted order. For example, if we are managing a list of customer names that must be displayed alphabetically, using a TreeSet would be ideal.</div>
    
    <div class="question">Q16. What is the internal implementation of ArrayList and LinkedList?</div>
    <div class="answer">ArrayList is backed by a dynamic array, which provides O(1) access time but requires resizing. LinkedList is implemented as a doubly-linked list, providing O(1) insertion and deletion at both ends but O(n) access time.</div>
    
    <div class="question">Q17. Can you explain the internal working of HashMap in Java?</div>
    <div class="answer">A HashMap in Java stores key-value pairs in an array where each element is a bucket. It uses a hash function to determine which bucket a key should go into for efficient data retrieval. If two keys end up in the same bucket, a collision happens. The HashMap manages these collisions by maintaining a linked list or a balanced tree depending on the Java version in each bucket.</div>
    
    <div class="question">Q18. What happens when two keys have the same hash code? How would you handle this scenario?</div>
    <div class="answer">When two different Java objects have the same hashcode, it's called a hash collision. In this case, Java handles it by storing both objects in the same bucket in a hash-based collection, like a HashMap. It then compares the objects using the equals() method to differentiate them.</div>
    
    <div class="question">Q19. How does a HashMap handle collisions in Java?</div>
    <div class="answer">In Java, when a HashMap encounters a collision (two keys with the same hashcode), it stores both entries in the same bucket. Prior to Java 8, it linked them in a simple list structure. In Java 8, if the number of entries in a bucket grows large, the list is converted to a balanced tree for faster lookups.</div>
    
    <div class="question">Q20. Can you please tell me what changes were done for the HashMap in Java 8?</div>
    <div class="answer">Before Java 8, HashMap dealt with collisions by using a simple linked list. Starting from Java 8, when too many items end up in the same bucket, the list turns into a balanced tree, which helps speed up searching.</div>
    
    <div class="question">Q21. Can we include a class as a key in HashMap?</div>
    <div class="answer">No, as a functional interface allows only a single abstract method. However, a functional interface can inherit another interface if it contains only static and default methods in it.</div>
    
    <div class="question">Q22. Can you please explain ConcurrentHashMap?</div>
    <div class="answer">ConcurrentHashMap is a version of HashMap that's safe to use by many threads at once without needing to lock the entire map. It divides the map into parts that can be locked separately, allowing better performance.</div>
    
    <div class="question">Q23. How does ConcurrentHashMap improve performance in a multi-threaded environment?</div>
    <div class="answer">ConcurrentHashMap boosts performance in multi-threaded settings by letting different threads access and modify different parts of the map simultaneously, reducing waiting times and improving efficiency.</div>
	 <div class="question">Q1. What is collection framework in Java?</div>
    <div class="answer">The Java Collection Framework is a set of tools that helps us organize, store, and manage groups of data easily. It includes various types of collections like lists, sets, and maps.</div>
    
    <div class="question">Q24. What is the time complexity of insertions, deletions, and retrievals in HashSet and HashMap?</div>
    <div class="answer">
        <ul>
            <li><strong>Insertion:</strong></li>
            <ul>
                <li>Average: O(1)</li>
                <li>Worst case: O(n) when rehashing occurs</li>
            </ul>
            <li><strong>Deletion:</strong></li>
            <ul>
                <li>Average: O(1)</li>
                <li>Worst case: O(n) when rehashing occurs</li>
            </ul>
            <li><strong>Retrieval:</strong></li>
            <ul>
                <li>Average: O(1)</li>
                <li>Worst case: O(n) when rehashing occurs (due to hash collisions)</li>
            </ul>
            <p>Note: HashSet and HashMap are not internally sorted.</p>
        </ul>
    </div>
    
    <div class="question">Q25. What is the time complexity of insertions, deletions, and retrievals in TreeSet and TreeMap?</div>
    <div class="answer">O(log n) for operations like insertions, deletions, and retrievals.<br>Note: TreeSet and TreeMap maintain elements in sorted order.</div>
    
    <div class="question">Q26. What techniques do HashMap, TreeMap, HashSet, and TreeSet use internally for performing operations?</div>
    <div class="answer">
        <ul>
            <li><strong>HashMap</strong> uses an array of nodes, where each node is a linked list or a tree depending on collisions and Java versions. From Java 8 onwards, if there are high hash collisions, the linked list gets converted to a balanced tree.</li>
            <li><strong>TreeMap</strong> uses a Red-Black tree, which is a type of self-balancing binary search tree. Each node in the Red-Black tree stores a key-value pair.</li>
            <li><strong>HashSet</strong> internally uses a HashMap.</li>
            <li><strong>TreeSet</strong> internally uses a TreeMap.</li>
        </ul>
    </div>
	<h2>Design Patterns and Principles Basics</h2>

<div class="question">Q1. What is a design pattern in Java and why do we use it?</div>
    <div class="answer">Design patterns are best practices and solutions to common software design problems. They provide a structured approach to coding, improving maintainability, scalability, and reusability.</div>

    <div class="question">Q2. Can you list and explain a few common design patterns used in Java programming?</div>
    <div class="answer">Common design patterns in Java:
        <ul>
            <li><strong>Singleton:</strong> Ensures a class has only one instance, with a global access point.</li>
            <li><strong>Observer:</strong> Allows objects to notify others about changes in their state.</li>
            <li><strong>Factory Method:</strong> Delegates the creation of objects to subclasses, promoting flexibility.</li>
            <li><strong>Builder:</strong> Separates object construction from its representation, making it easier to create complex objects.</li>
        </ul>
    </div>

    <div class="question">Q3. How can design patterns affect the performance of a Java application?</div>
    <div class="answer">Design patterns can introduce slight performance overhead due to abstraction layers, but they enhance modularity, maintainability, and scalability, which are critical for long-term software development.</div>

    <div class="question">Q4. Which design pattern would you use to manage database connections efficiently in a Java application?</div>
    <div class="answer">The <strong>Singleton</strong> pattern is commonly used for managing database connections, ensuring a single shared connection instance is reused efficiently, preventing unnecessary resource consumption.</div>

    <div class="question">Q5. How do you choose the appropriate design pattern for a particular problem in Java?</div>
    <div class="answer">Understanding the problem domain, evaluating common design patterns, and assessing their impact on maintainability, performance, and extensibility help in choosing the right pattern.</div>

    <div class="question">Q6. What is the difference between HashMap and TreeMap?</div>
    <div class="answer">HashMap stores key-value pairs without ordering, providing O(1) lookup time in ideal cases. TreeMap, on the other hand, maintains keys in sorted order and has a time complexity of O(log n) for operations.</div>

    <div class="question">Q7. In what scenarios would you prefer to use a TreeMap over a HashMap?</div>
    <div class="answer">Use TreeMap when you need to maintain a sorted order of keys, such as implementing a navigation system or a ranking system. HashMap is preferable for fast, unordered key-value lookups.</div>

    <div class="question">Q8. Can we add objects as keys in a TreeMap?</div>
    <div class="answer">Yes, objects can be used as keys in a TreeMap if they implement the <strong>Comparable</strong> interface or a custom <strong>Comparator</strong> is provided to define the sorting logic.</div>
	
	<div class="question">Q9. What are SOLID Principles?</div>
<div class="answer">
    <ul>
        <li><strong>S - Single Responsibility Principle:</strong> A class should have only one reason to change, meaning it should handle only one functionality.<br>
            <em>Example:</em> A class <code>VehicleRegistration</code> should only handle vehicle registration details. If it also manages vehicle insurance, it violates this principle.
        </li>
        <li><strong>O - Open/Closed Principle:</strong> Classes should be open for extension but closed for modification.<br>
            <em>Example:</em> A <code>VehicleService</code> class providing maintenance services should allow extension through subclasses like <code>ElectricVehicleService</code> without modifying the original class.
        </li>
        <li><strong>L - Liskov Substitution Principle:</strong> Subtypes must be substitutable for their base types without altering the correctness of the program.<br>
            <em>Example:</em> A superclass <code>Vehicle</code> with a method <code>startEngine()</code> should allow substitution with subclasses like <code>Car</code> and <code>ElectricCar</code> without breaking the system.
        </li>
        <li><strong>I - Interface Segregation Principle:</strong> Clients should not be forced to depend on interfaces they do not use; large interfaces should be split into smaller ones.<br>
            <em>Example:</em> Instead of one large interface <code>VehicleOperations</code> with methods like <code>drive()</code>, <code>refuel()</code>, <code>charge()</code>, and <code>navigate()</code>, split it into focused interfaces like <code>Drivable</code>, <code>Refuelable</code>, and <code>Navigable</code>.
        </li>
        <li><strong>D - Dependency Inversion Principle:</strong> High-level modules should depend on abstractions rather than concrete implementations.<br>
            <em>Example:</em> A <code>VehicleTracker</code> class that logs vehicle positions should interact through a <code>GPSDevice</code> interface instead of depending directly on a specific GPS device model.
        </li>
    </ul>
</div>

<h2>Miscellaneous questions </h2>
<div class="question">Q1. What is transient?</div>
<div class="answer">
    The <code>transient</code> keyword in Java is used to indicate that a field should not be serialized. This means it will be ignored when objects are serialized and deserialized.
</div>

<div class="question">Q2. Can we create a server in a Java application without using Spring or any other framework?</div>
<div class="answer">
    Yes, you can create a server in a Java application using only Java SE APIs, such as by utilizing the <code>ServerSocket</code> class for a simple TCP server or the <code>HttpServer</code> class for HTTP services.
</div>

<div class="question">Q3. What is the Exchanger class?</div>
<div class="answer">
    The <code>Exchanger</code> class in Java is a synchronization point at which threads can pair and swap elements within pairs. Each thread presents some object on exchange and receives another object in return from another thread.
</div>

<div class="question">Q4. What is reflection in Java?</div>
<div class="answer">
    Reflection in Java is a capability to inspect and modify the runtime behavior of applications. It allows programs to manipulate internal properties of classes, methods, and interfaces, and dynamically call them at runtime.
</div>

<div class="question">Q5. What is the difference between weak reference and soft reference in Java?</div>
<div class="answer">
    Weak references in Java are garbage collected when no strong references exist. Soft references are only cleared at the discretion of the garbage collector, typically when memory is low.
</div>

<div class="question">Q6. What is Java Flight Recorder?</div>
<div class="answer">
    Java Flight Recorder (JFR) is a tool for collecting diagnostic and profiling data about a running Java application without significant performance overhead.
</div>

<div class="question">Q7. Discuss Java Generics.</div>
<div class="answer">
    Generics provide type safety by allowing classes and methods to operate on objects of specific types, preventing runtime <code>ClassCastException</code> and reducing code duplication.
</div>

<div class="question">Q8. What is the difference between Young Generation and Old Generation memory spaces?</div>
<div class="answer">
    The Young Generation stores newly created objects. The Old Generation holds objects that have survived several garbage collection cycles in the Young Generation.
</div>

 <h2>Exception Handling </h2>
 
<div class="question">Q1. What happens when an exception is thrown in a static initialization block?</div>
<div class="answer">
    When an exception is thrown in a static initialization block in Java, it prevents the class from being loaded properly. This results in a <code>java.lang.ExceptionInInitializerError</code>. If an attempt is made to use the class afterwards, the JVM will throw a <code>NoClassDefFoundError</code> because the class initialization previously failed. This mechanism ensures that no class is used unless it has been correctly and fully initialized.
</div>

<div class="question">Q2. Provide an example of when you would purposely use a checked exception over an unchecked one.</div>
<div class="answer">
    You would purposely use a checked exception when you want to enforce error handling by the caller of a method. For instance, in situations where a method deals with reading from a file or querying a database, you might use a checked exception like <code>IOException</code> or <code>SQLException</code>. These exceptions alert the developer that there must be logic to handle these potential issues, ensuring that such problems are acknowledged and addressed at compile time, preventing overlooked errors that could occur at runtime.
</div>

<div class="question">Q3. Have you ever used a finally block? If yes, can you provide a scenario where you have used it?</div>
<div class="answer">
    In Java, a <code>finally</code> block is crucial for resource management, ensuring resources like streams, connections, or files are properly closed regardless of whether an exception occurs. For example, when working with file handling, even if an <code>IOException</code> occurs, the <code>finally</code> block ensures that the file stream is closed to avoid resource leaks, thus maintaining system stability and performance.
</div>

<div class="question">Q4. Was there ever a time when the finally block caused any unexpected behavior or side effects?</div>
<div class="answer">
    A <code>finally</code> block in Java generally executes reliably, but unexpected behavior can arise if a new exception is thrown within the <code>finally</code> block itself. For instance, if an exception occurs while closing a resource in the <code>finally</code> block, it can obscure an exception that was thrown in the <code>try</code> block, leading to the loss of the original exception's details. This is why it's essential to handle exceptions within the <code>finally</code> block carefully to prevent such issues.
</div>

<div class="question">Q5. What is a deadlock in multithreading? How can you prevent it?</div>
<div class="answer">
    A deadlock in multithreading occurs when two or more threads are each waiting for the other to release a resource they need to continue, resulting in all involved threads being blocked indefinitely. To prevent deadlocks, ensure that all threads acquire locks in a consistent order, avoid holding multiple locks if possible, and use timeout options with lock attempts. Another strategy is to use a lock hierarchy or a try-lock method to manage resources dynamically without stalling.
</div>

<div class="question">Q6. What issues might arise when both method overloading and overriding are used in the same class hierarchy?</div>
<div class="answer">
    Using both method overloading and overriding in the same class hierarchy can lead to confusion and errors in Java. Overloading methods within a class allows multiple methods with the same name but different parameters. Overriding changes the behavior of a method in a subclass. When these concepts are combined, it can be unclear whether a method call is invoking an overloaded method or an overridden one, especially if the signatures are similar. This ambiguity can make the code harder to read and maintain, and increase the likelihood of bugs.
</div>

<div class="question">Q7. Why might it be bad practice to catch Throwable?</div>
<div class="answer">
    Catching <code>Throwable</code> in Java is generally considered bad practice because <code>Throwable</code> is the superclass of all errors and exceptions. Catching it means catching both <code>Exception</code> and <code>Error</code> classes. Errors, such as <code>OutOfMemoryError</code> or <code>StackOverflowError</code>, are typically serious problems that a normal application should not attempt to handle because they are often related to system-level issues. Catching <code>Throwable</code> may prevent the propagation of errors that should naturally cause the program to terminate, potentially leading to system instability or corrupting application state.
</div>

<h1 style="background-color: blue;">Java-3</h1>


<div class="question">Q1. Describe a scenario where you used a PriorityQueue, and explain why it was chosen over other types of queues.</div>
<div class="answer">
    I used a <code>PriorityQueue</code> in a scenario where I needed to manage tasks by their priority, not just by the order they arrived. This type of queue helped in automatically sorting tasks such that the most critical ones were handled first. Unlike regular queues that process tasks in the order they come (FIFO), <code>PriorityQueue</code> sorts them based on their urgency, making it ideal for situations where some tasks are more important than others.
</div>

<div class="question">Q2. What are enums in Java and how are they useful?</div>
<div class="answer">
    Enums in Java are special types used to define a set of fixed constants, like days of the week or directions (<code>NORTH</code>, <code>SOUTH</code>, etc.). They are useful because they make the code more readable and prevent errors by limiting the possible values for a variable. Instead of using random numbers or strings, enums ensure only predefined values are used, improving code clarity and safety.
</div>

<div class="question">Q3. What is the Builder Pattern in Java? How is it different from the Factory Pattern?</div>
<div class="answer">
    The <code>Builder Pattern</code> in Java is used to construct complex objects step by step, allowing different parts of an object to be built independently and then assembled as a final step. It's different from the <code>Factory Pattern</code>, which is used to create objects without exposing the creation logic to the client. The <code>Builder Pattern</code> gives more control over the construction process, whereas the <code>Factory Pattern</code> focuses on creating a finished object in a single step.
</div>

<div class="question">Q4. What is the impact of declaring a method as final on inheritance?</div>
<div class="answer">
    Declaring a method as <code>final</code> in Java prevents it from being overridden in any subclass. This is useful when you want to ensure that the functionality of a method remains consistent and unchanged, regardless of inheritance. It provides a safeguard that the method will behave the same way, even in derived classes, maintaining the original behavior and preventing any alteration or unexpected behavior in the program.
</div>

<div class="question">Q5. Can method overloading be determined at runtime?</div>
<div class="answer">
    No, method overloading cannot be determined at runtime; it is resolved at compile-time. Method overloading occurs when multiple methods have the same name but different parameters within the same class. The compiler determines which method to use based on the method signature (method name and parameter types) when the code is compiled. This is unlike method overriding, where the method to execute is determined at runtime based on the object’s actual class type.
</div>

<div class="question">Q6. How does Java resolve a call to an overloaded method?</div>
<div class="answer">
    Java resolves a call to an overloaded method at compile time by looking at the method signature, which includes the method name and the types and number of parameters. The compiler matches the arguments used in the method call to the parameters of the defined methods. It selects the most specific method that fits the arguments provided. If there's no exact match or it's ambiguous, the compiler will throw an error.
</div>

<div class="question">Q7. What is the diamond operator, and how does it work?</div>
<div class="answer">
    The diamond operator (<code>&lt;&gt;</code>) in Java, introduced in Java 7, simplifies the notation of generics by reducing the need to duplicate generic type parameters. For instance, instead of writing <code>List&lt;String&gt; list = new ArrayList&lt;String&gt;();</code>, you can use the diamond operator: <code>List&lt;String&gt; list = new ArrayList&lt;&gt;();</code>. The compiler infers the type parameter <code>String</code> for the <code>ArrayList</code> based on the variable's declared type, making the code cleaner and easier to read.
</div>

<div class="question">Q8. Explain inner classes in Java.</div>
<div class="answer">
    Inner classes in Java are classes defined within another class. They are useful for logically grouping classes that will only be used in one place, increasing encapsulation. Inner classes have access to the attributes and methods of the outer class, even if they are declared private. There are several types: non-static nested classes (inner classes), static nested classes, local classes (inside a method), and anonymous classes (without a class name). Each type serves different purposes based on the specific need for grouping and scope control.
</div>

<div class="question">Q9. Can inner classes have static declarations?</div>
<div class="answer">
    Inner classes in Java can have static declarations if they are themselves declared as <code>static</code>. These static nested classes can contain static methods, fields, or blocks. However, non-static inner classes, which are associated with an instance of the outer class, cannot contain any static members. The reason is that static members belong to the class rather than an instance, and non-static inner classes are intimately linked to the outer class's instance.
</div>

<div class="question">Q10. What is the significance of an anonymous inner class?</div>
<div class="answer">
    Anonymous inner classes in Java are useful when you need to implement an interface or extend a class without creating a separate named class. They are defined and instantiated all at once, typically at the point of use. This is particularly helpful for handling events or creating runnable objects in GUI applications with minimal code. By using anonymous inner classes, developers can make their code more concise and focused on specific tasks.
</div>

<div class="question">11) What do you think Java uses: pass by value or pass by reference?</div>
<div class="answer">Java uses pass by value. This means when you pass a variable to a method, Java copies the actual value of an argument into the formal parameter of the function. For primitive types, Java copies the actual values, while for objects, Java copies the value of the reference to the object. Therefore, changes made to the parameter inside the method do not affect the original value outside the method.</div>

<div class="question">12) What are the differences between implementing Runnable and extending Thread in Java?</div>
<div class="answer">In Java, implementing the Runnable interface and extending the Thread class are two ways to create a thread, but they serve different purposes. Implementing Runnable is generally preferred as it allows a class to extend another class while still being able to run in a thread, promoting better object-oriented design and flexibility. Extending Thread makes a class unable to extend any other class due to Java's single inheritance limitation, but it can be simpler for straightforward scenarios.</div>

<div class="question">13) What is a marker interface?</div>
<div class="answer">A marker interface in Java is an interface with no methods or fields. It serves to provide runtime information to objects about what they can do. Essentially, it "marks" a class with a certain property, allowing the program to use instanceof checks to trigger specific behavior based on the presence of the marker. Examples include Serializable and Cloneable, which indicate that a class is capable of serialization or cloning, respectively.</div>

<div class="question">14) Can you provide a scenario where creating a custom marker interface would be beneficial?</div>
<div class="answer">Creating a custom marker interface can be beneficial in scenarios where you want to enforce a special handling or policy for certain classes without adding any actual methods. For example, consider a security system where only certain data objects can be transmitted over a network. You could define a marker interface like Transmittable. By implementing this interface in certain classes, you can use instanceof to check and ensure that only objects of these classes are transmitted, enhancing security controls.</div>

<div class="question">15) How does Java determine which method to call in the case of method overloading?</div>
<div class="answer">In the case of method overloading, Java determines which method to call based on the method's signature. This includes the method name and the number and types of parameters. The compiler looks at the arguments passed during the method call and matches them to the method that has the corresponding parameter types. If it finds an exact match, it executes that method. If it doesn’t find a match or if the call is ambiguous, it results in a compile-time error.</div>

<div class="question">16) What happens if two packages have the same class name?</div>
<div class="answer">If two packages in Java contain a class with the same name, you can still use both classes in your program, but you must manage them carefully to avoid naming conflicts. To differentiate between the two, you should use the fully qualified name of the classes, which includes the package name followed by the class name, in your code. For example, package1.ClassName and package2.ClassName. This approach clarifies which class you intend to use from each package.</div>

<div class="question">17) How do you access a package-private class from another package?</div>
<div class="answer">In Java, a package-private class, which is declared without any access modifiers, is only accessible within the same package. To access such a class from another package, you cannot do so directly due to its limited visibility. The typical solution involves changing the access level of the class to public, making it accessible from other packages. Alternatively, you can add methods or classes within the same package that can access the package-private class and expose its functionality publicly or through interfaces.</div>

<div class="question">18) Can you modify a final object reference in Java?</div>
<div class="answer">In Java, when you declare an object reference as final, you cannot change the reference to point to a different object after it has been assigned. However, the object itself can still be modified if it is mutable. This means that while you can't reassign the final reference to a new object, you can change the object's properties or state. For instance, you can add items to a final list but cannot reassign it to another list.</div>

<div class="question">19) What is the default access modifier if none is specified?</div>
<div class="answer">In Java, if no access modifier is specified for a class member (like fields or methods), it defaults to package-private. This means that the member is accessible only within classes that are in the same package. This default access level provides a moderate level of protection within the package and is less restrictive than private, but more restrictive than protected or public, preventing access from outside the package.</div>

<div class="question">20) What are the potential issues with using mutable objects as keys in a HashMap?</div>
<div class="answer">Using mutable objects as keys in a HashMap can lead to significant issues. If the object’s state changes after it’s been used as a key, its hashcode can change, making it impossible to locate in the map even though it's still there. This results in a loss of access to that entry, effectively causing data loss and potential memory leaks. Therefore, it's best to use immutable objects as keys to maintain consistent behavior and reliable access.</div>

<div class="question">21) What would happen if you override only the equals() method and not hashCode() in a custom key class used in HashMap?</div>
<div class="answer">If you override only the equals() method without overriding hashCode() in a custom key class used in a HashMap, you'll run into problems. Java requires that equal objects must have the same hash code. If they don’t, the HashMap might not find the object even though it's there. This inconsistency can lead to duplicate keys and unpredictable behavior, as the HashMap uses the hash code to locate keys. Always override both methods to ensure correct behavior.</div>

<div class="question">22) What is the difference between HashMap and IdentityHashMap in terms of how they handle keys?</div>
<div class="answer">The main difference between HashMap and IdentityHashMap is how they handle key comparison. HashMap uses the equals() method and hashCode() to determine if two keys are the same, which checks for logical equality. In contrast, IdentityHashMap uses == for key comparison, which checks for reference equality. This means IdentityHashMap considers two keys equal only if they are exactly the same object, not merely equal objects. This makes IdentityHashMap suitable for identity-based key operations.</div>

<div class="question">23) How does Collections.sort() work internally?</div>
<div class="answer">Internally, Collections.sort() in Java uses a modified version of the MergeSort algorithm known as TimSort. This algorithm is efficient and stable, meaning it preserves the order of equal elements. It breaks the list into smaller parts, sorts each part, and then merges them back together in sorted order, ensuring that the overall list is ordered. This method is optimized for performance and reliability, making it suitable for sorting both primitive types and objects based on natural ordering or a specified comparator.</div>

<div class="question">24) What would happen if you try to sort a list containing null elements using Collections.sort()?</div>
<div class="answer">If you try to sort a list containing null elements using Collections.sort(), it will throw a NullPointerException. This method requires all elements in the list to be non-null and comparable. Null elements lack a comparison order, which prevents Collections.sort() from determining their position relative to other elements. To sort such lists, you must either remove null elements or use a custom comparator that explicitly handles nulls.</div>

<div class="question">25) Can you sort a list of custom objects using Collections.sort() without providing a Comparator?</div>
<div class="answer">Yes, you can sort a list of custom objects using Collections.sort() without providing a Comparator, but only if the custom objects implement the Comparable interface. This interface requires defining a compareTo method, which specifies the natural ordering of the objects. If the objects do not implement Comparable, or if the compareTo method is not implemented, attempting to sort without a Comparator will result in a ClassCastException.</div>

<div class="question">26) What is the difference between using Collections.sort() and Stream.sorted() in Java 8+?</div>
<div class="answer">The difference between Collections.sort() and Stream.sorted() in Java 8+ lies in how they handle data and output. Collections.sort() modifies the list it sorts directly, changing the original data structure. On the other hand, Stream.sorted() operates on a stream of data and returns a new sorted stream without altering the original source. This makes Stream.sorted() more flexible and suitable for functional programming styles, as it supports chain operations and doesn't affect the original data.</div>

<div class="question">27) Can an enum extend another class in Java?</div>
<div class="answer">No, an enum in Java cannot extend another class. In Java, all enums implicitly extend the java.lang.Enum class, and since Java does not support multiple inheritance for classes, an enum cannot extend any other class. However, enums can implement interfaces, allowing them to include additional functionality beyond the basic enum capabilities. This provides a way to enhance the functionality of enums without the need for class inheritance.</div>

<div class="question">28) How do you iterate over all values of an enum?</div>
<div class="answer">To iterate over all values of an enum in Java, you can use the values() method, which returns an array of all enum constants in the order they're declared. You can then loop through this array using a for-each loop. Here’s how it works: for each constant in the enum, you perform the desired operation. This method is straightforward and efficient for accessing and manipulating each constant in an enum type.</div>

<div class="question">29) Can you serialize static fields in Java?</div>
<div class="answer">No, you cannot serialize static fields in Java. Serialization in Java is designed to capture the state of an object, and static fields are not part of any individual object's state. Instead, static fields belong to the class itself, shared among all instances. When an object is serialized, only the object's instance variables are saved, while static fields are ignored. This ensures that the class's shared state remains consistent and is not duplicated with each object's serialization.</div>

<div class="question">30) What happens if an exception is thrown during the serialization process?</div>
<div class="answer">If an exception is thrown during the serialization process in Java, the serialization fails, and the state of the object being serialized is not saved. Typically, a NotSerializableException is thrown if an object does not support serialization (i.e., it does not implement the Serializable interface). Other exceptions can include IOException for input/output issues. These exceptions prevent the object from being properly converted into a byte stream, disrupting the storage or transmission of its state.</div>

<div class="question">31) What happens if your Serializable class contains a member which is not serializable? How do you fix it?</div>
<div class="answer">If your Serializable class contains a member that is not serializable, you'll encounter a NotSerializableException when you try to serialize the class. To fix this, you can either make the non-serializable member transient, which means it won't be included in the serialization process, or ensure that the member class also implements the Serializable interface. Alternatively, you can customize the serialization process by providing your own writeObject and readObject methods that handle the non-serializable member appropriately.</div>

<div class="question">32) What is Type Erasure?</div>
<div class="answer">Type Erasure in Java refers to the process by which the Java compiler removes generic type information from your code after it compiles it, enforcing generic constraints only at compile time and not at runtime. This means that generic type information is not available during the execution of the program. For example, a List<Integer> and a List<String> are just treated as List. This approach helps maintain backward compatibility with older Java versions that do not support generics.</div>

<div class="question">33) What is a generic type inference?</div>
<div class="answer">Generic type inference in Java is a feature that allows the Java compiler to automatically determine, or infer, the types of generic arguments that are necessary for method calls and expressions. This means you don't always have to explicitly specify the generic types when you're coding, which simplifies your code. For example, when you use the diamond operator (<>) with collections, the compiler can infer the type of the elements in the collection from the context.</div>

<div class="question">34) Why can’t we create an array of generic types in Java?</div>
<div class="answer">In Java, you cannot create an array of generic types because generics do not maintain their type information at runtime due to type erasure. This means that the Java compiler removes all information related to type parameters and type arguments within a generic at runtime. Arrays, however, need concrete type information at runtime to ensure type safety, which isn't possible with erased generic types. This mismatch prevents the creation of generic arrays to avoid runtime type errors.</div>

<div class="question">35) How Are Strings Represented in Memory?</div>
<div class="answer">In Java, strings are represented in memory as objects of the String class, which internally uses a character array to store the string data. Each String object is immutable, meaning once it is created, it cannot be changed. To optimize memory usage, Java maintains a special area called the "String Pool" where literals are stored. If you create a string that already exists in the pool, Java reuses the existing string instead of creating a new one, reducing memory overhead.</div>

<div class="question">36) What is the difference between Lambda vs. Anonymous Classes?</div>
<div class="answer">Lambda expressions and anonymous classes in Java both provide ways to implement methods from a functional interface, but they do so differently. Lambdas are more concise and focused on passing behavior or functionality, often written in a single line of code without a name. Anonymous classes, on the other hand, are more verbose, require a class declaration, and can be used to create instances of interfaces or abstract classes with methods. Lambdas generally lead to clearer, more readable code compared to anonymous classes.</div>

<div class="question">37) Explain the difference between Stream API map and flatMap?</div>
<div class="answer">In Java's Stream API, map and flatMap are functions used for transforming streams. map applies a function to each element of a stream and collects the results in a new stream. For example, converting each string in a stream to its upper case. On the other hand, flatMap is used when each element of the stream is a stream itself, or can be converted into a stream. It "flattens" all these streams into a single stream. For instance, converting a stream of lists into a stream of elements.</div>

<div class="question">38) Explain the difference between peek() and map(). In what scenarios should peek() be used with caution?</div>
<div class="answer">In Java's Stream API, peek() and map() both operate on elements of a stream, but they serve different purposes. map() transforms each element and returns a new stream containing the transformed elements. peek(), on the other hand, is mainly for debugging and allows you to perform operations on each element without altering them, returning the same stream. Caution is advised with peek() because its side effects can be unpredictable if used for purposes other than debugging, such as altering the state of objects, which can lead to inconsistent results in the stream's pipeline execution.</div>

<div class="question">39) How do imports affect compilation and class loading?</div>
<div class="answer">Imports in Java simplify code by allowing you to refer to classes from other packages without using their fully qualified names. During compilation, the import statements help the compiler locate and recognize these classes, but they don't affect performance or class loading. Class loading occurs at runtime when a class is first used, regardless of whether it's imported. Imports don't increase memory usage or slow down the program—they simply make the code more readable and organized.</div>

<div class="question">40) What is the difference between Import and Static Imports?</div>
<div class="answer">The difference between import and static import in Java lies in what they bring into scope. Regular import is used to access classes from other packages without using their fully qualified names, making code cleaner. Static imports, introduced in Java 5, allow direct access to static members (fields and methods) of a class without qualifying them with the class name. This is useful when you need frequent access to static methods, like Math.sqrt() or constants like PI, simplifying the code.</div>


<div class="question">41) What is the impact of static imports on code readability and maintainability?</div>
<div class="answer">Static imports can improve code readability by reducing repetitive class references, making the code more concise. For example, instead of writing Math.PI, you can just use PI. However, overusing static imports can harm maintainability, as it becomes harder to know where methods or constants are coming from, especially in larger projects. The lack of clarity can confuse developers unfamiliar with the code, so static imports should be used sparingly and wisely.</div>

<div class="question">42) How to choose initial capacity in an ArrayList constructor in a scenario where the list is repeatedly cleared and reused?</div>
<div class="answer">When choosing the initial capacity of an ArrayList in a scenario where the list is repeatedly cleared and reused, it's best to base it on the expected maximum size of the list during its heaviest use. This avoids frequent resizing and reallocations, which are costly. Setting the capacity slightly higher than the typical maximum size ensures that the list has enough space without frequent expansions, leading to better performance and memory management.</div>

<div class="question">43) Can you tell me an example of how objects and classes interact in a real-world application?</div>
<div class="answer">In a real-world banking application, a Customer class defines attributes like name and account number. When a user opens an account, an object of the Customer class is created with specific values. These objects interact with methods like deposit, withdraw, and check balance, encapsulating the behavior and data of the customer.</div>

<div class="question">44) Scenario-Based: How would you handle a situation where you need to compare the content equality of two custom object instances?</div>
<div class="answer">To compare the content equality of two custom object instances, override the equals() method in the class. Inside the method, compare the object's fields (like ID, name, or other properties). This ensures that two objects with identical values are considered equal, even if their references differ.</div>

<div class="question">45) Scenario-Based: Suppose you're storing user session data in a HashMap. How would you ensure thread safety?</div>
<div class="answer">To ensure thread safety when storing user session data in a HashMap, you can use Collections.synchronizedMap() to wrap the HashMap, making it thread-safe by synchronizing access to it. Alternatively, for better performance in highly concurrent environments, you can use ConcurrentHashMap, which provides thread safety with less locking overhead by allowing concurrent reads and controlled updates. This ensures that multiple threads can safely access and modify the session data.<br>
Example:<br>
Map&lt;String, SessionData&gt; sessionMap = new ConcurrentHashMap&lt;&gt;();</div>

<div class="question">46) Can an interface with multiple default methods still be a functional interface?</div>
<div class="answer">No, an interface with multiple default methods cannot be a functional interface. A functional interface is defined as an interface with only one abstract method, which allows it to be used with lambda expressions. Default methods are concrete (non-abstract), so having multiple default methods is fine, but as long as there's only one abstract method, the interface can still be functional. Multiple abstract methods would disqualify it as a functional interface.</div>

<div class="question">47) How does TreeSet sort elements when it stores objects and not wrapper classes?</div>
<div class="answer">When a TreeSet stores objects that are not wrapper classes, it uses natural ordering provided by the object's Comparable implementation, if the class implements the Comparable interface. The compareTo() method in the object defines how to sort the elements. Alternatively, if the objects don't implement Comparable, you can provide a custom Comparator when creating the TreeSet, which specifies how the elements should be ordered. Without this, trying to store unsorted objects would result in a runtime error.</div>

<div class="question">48) Can an enum extend another class in Java?</div>
<div class="answer">No, an enum in Java cannot extend another class. All enums implicitly extend java.lang.Enum, and since Java doesn't allow multiple inheritance for classes, an enum cannot extend any other class. However, an enum can implement interfaces to gain additional functionality. This limitation ensures that enums remain simple, specialized types that represent fixed sets of constants, while still allowing some flexibility through interfaces.</div>

<div class="question">49) How do you iterate over all values of an enum?</div>
<div class="answer">In Java, you can easily iterate over all the values of an enum using a for-each loop. First, use the values() method provided by the enum. This method returns an array containing all the values of the enum in the order they're declared. Then, use a for-each loop to go through each element in this array. Here, you treat each enum value as an element of the array and perform any operations inside the loop.</div>

<div class="question">50) How does TreeSet sort elements when it stores objects and not wrapper classes?</div>
<div class="answer">In Java, a TreeSet sorts objects based on natural ordering or a custom comparator. For natural ordering, the class of the objects stored in the TreeSet must implement the Comparable interface. This interface requires a method called compareTo that defines the order. If the objects don't have natural ordering, you can provide a Comparator when creating the TreeSet, specifying how to compare and sort the objects.</div>

<div class="question">51) Suppose you have multiple interfaces with default methods that a class implements. How would you resolve method conflicts?</div>
<div class="answer">When a class implements multiple interfaces that have default methods with the same signature, you must resolve the conflict by overriding the method in your class. In the overridden method, you can explicitly choose which interface's default method to use by using the syntax InterfaceName.super.methodName(). This tells your class exactly which version of the conflicting method to execute, thus resolving the ambiguity.</div>

<div class="question">52) How do JVM optimizations affect the performance of Java applications?</div>
<div class="answer">JVM optimizations significantly enhance the performance of Java applications by improving execution efficiency. The JVM uses techniques like Just-In-Time (JIT) compilation, which converts Java bytecode into native machine code that runs faster on the processor. It also employs methods like garbage collection optimization and inlining functions to reduce memory usage and execution time. These optimizations help Java programs run faster and more smoothly, making efficient use of system resources.</div>

<div class="question">53) Can ‘this’ be used in a static method or block?</div>
<div class="answer">No, the keyword this cannot be used in a static method or block in Java. The reason is that this refers to the current instance of a class, and static methods or blocks do not belong to any instance but to the class itself. Since static methods can be called without creating an instance of the class, there's no this context available in static contexts.</div>

<div class="question">54) Explain Java Class Loader.</div>
<div class="answer">The Java Class Loader is a part of the Java Runtime Environment that dynamically loads Java classes into the Java Virtual Machine. It does this when the class is needed for the first time, not at program start, enhancing efficiency. Java uses multiple class loaders in a hierarchy: Bootstrap, Extension, and System/Application. This mechanism helps in separating the namespace of the classes loaded by different class loaders, preventing conflicts.</div>

<div class="question">55) Is it possible to unload a class in Java?</div>
<div class="answer">In Java, directly unloading a class is not possible as Java does not provide explicit control over the unloading of classes. However, a class can be unloaded when its class loader is garbage collected. This happens if there are no active references to the class and its class loader from any part of the program. Essentially, for a class to be eligible for unloading, all instances of the class and the class loader itself must no longer be in use.</div>

<div class="question">56) How does class loading affect memory usage?</div>
<div class="answer">Class loading in Java affects memory usage by increasing it each time a class is loaded into the JVM. Each class needs memory for its metadata, methods, and associated objects. This loading is necessary for the JVM to use the class, but if many classes are loaded, or large libraries are in use, memory consumption can increase significantly. Proper management of class loaders can help in optimizing memory usage, especially in large applications.</div>

<div class="question">57) Can you serialize static fields in Java?</div>
<div class="answer">In Java, static fields are not serialized. Serialization in Java is focused on saving the state of an object, and static fields are part of the class state, not individual object state. Therefore, static fields are common to all instances of the class and remain unchanged based on individual object serialization. When you deserialize an object, the static fields will have the values set by the current running program or their initial values as defined in the class.</div>

<div class="question">58) What is the role of ExecutorService in the Executor Framework? What methods does it provide?</div>
<div class="answer">The ExecutorService in the Java Executor Framework plays a crucial role in managing and controlling thread execution. It provides a higher-level replacement for working directly with threads, offering methods to manage lifecycle operations like starting, running, and stopping threads efficiently. Some key methods it provides include submit() for executing callable tasks that return a result, execute() for running runnable tasks, and shutdown() to stop the executor service gracefully once tasks are completed.</div>

<h1 style="background-color: blue;">Springboot-1</h1>  

 <h1>Spring Boot Annotations</h1>
    <div class="question">Q1) What is @SpringBootApplication?</div>
    <div class="answer">It combines @Configuration, @EnableAutoConfiguration, and @ComponentScan annotations.</div>
    
    <div class="question">Q2) What is @EnableAutoConfiguration?</div>
    <div class="answer">It configures the application automatically based on included libraries.</div>
    
    <div class="question">Q3) What is @Configuration?</div>
    <div class="answer">It marks a class as a source of bean definitions.</div>
    
    <div class="question">Q4) What is @ComponentScan?</div>
    <div class="answer">It specifies where to look for components, services, and configurations.</div>
    
    <div class="question">Q5) What is @Bean?</div>
    <div class="answer">It defines a bean explicitly within a configuration class.</div>
    
    <div class="question">Q6) What is @Component?</div>
    <div class="answer">It marks a class as a Spring-managed component.</div>
    
    <div class="question">Q7) What is @Repository?</div>
    <div class="answer">It designates a class as a data access component.</div>
    
    <div class="question">Q8) What is @Service?</div>
    <div class="answer">It marks a class as a service layer component.</div>
    
    <div class="question">Q9) What is @Controller?</div>
    <div class="answer">It defines a class as a web controller handling HTTP requests.</div>
    
    <div class="question">Q10) What is @RestController?</div>
    <div class="answer">It combines @Controller and @ResponseBody to create RESTful services.</div>
    
    <div class="question">Q11) What is @RequestMapping?</div>
    <div class="answer">It maps HTTP requests to handler methods.</div>
    
    <div class="question">Q12) What is @Autowired?</div>
    <div class="answer">It enables automatic dependency injection.</div>
    
    <div class="question">Q13) What is @PathVariable?</div>
    <div class="answer">It extracts values from URI templates.</div>
    
    <div class="question">Q14) What is @RequestParam?</div>
    <div class="answer">It binds a method parameter to a request parameter.</div>
    
    <div class="question">Q15) What is @ResponseBody?</div>
    <div class="answer">It returns a method's result as the HTTP response body.</div>
    
    <div class="question">Q16) What is @RequestBody?</div>
    <div class="answer">It binds the request body to a method parameter.</div>
    
    <div class="question">Q17) What is @EnableWebMvc?</div>
    <div class="answer">It activates default configuration for Spring MVC.</div>
    
    <div class="question">Q18) What is @EnableAsync?</div>
    <div class="answer">It enables asynchronous method execution.</div>
    
    <div class="question">Q19) What is @Scheduled?</div>
    <div class="answer">It triggers methods to run at scheduled intervals.</div>
    
    <div class="question">Q20) What is @EnableScheduling?</div>
    <div class="answer">It enables scheduling capabilities.</div>
    
    <div class="question">Cross-Question: Can we use @Component instead of @Repository and @Service?</div>
    <div class="answer">Yes, since all three create Spring beans. However, @Repository and @Service improve code clarity and functionality, with @Repository enhancing database error management.</div>
	
<h1>Basic Spring Boot Interview Questions and Answers</h1>
    
    <div class="question">Q1) What is Spring Boot?</div>
    <div class="answer">Spring Boot is a powerful framework that streamlines the development, testing, and deployment of Spring applications. It eliminates boilerplate code and offers automatic configuration features to ease the setup and integration of various development tools.</div>
    
    <div class="question">Q2) What are the Features of Spring Boot?</div>
    <div class="answer">Key features include auto-configuration, embedded servers (like Tomcat and Jetty), starter kits, Spring Boot Actuator for monitoring, and cloud support.</div>
    
    <div class="question">Q3) What are the advantages of using Spring Boot?</div>
    <div class="answer">Spring Boot reduces setup time, requires less code, supports microservices, and includes built-in monitoring and security features.</div>
    
    <div class="question">Q4) Define the Key Components of Spring Boot.</div>
    <div class="answer">Key components include Starter Kits, AutoConfiguration, CLI, and Actuator.</div>
    
    <div class="question">Q5) Why do we prefer Spring Boot over Spring?</div>
    <div class="answer">Spring Boot offers automatic configuration, embedded servers, and reduced dependency management, making development faster and easier.</div>
    
    <div class="question">Q6) Explain the internal working of Spring Boot.</div>
    <div class="answer">Spring Boot auto-configures applications based on dependencies, uses embedded servers, and simplifies configuration through properties and annotations.</div>
    
    <div class="question">Q7) What are the Spring Boot Starter Dependencies?</div>
    <div class="answer">Starter dependencies bundle required libraries for features like web apps, data access, and security.</div>
    
    <div class="question">Q8) How does a Spring application get started?</div>
    <div class="answer">Spring Boot applications start with SpringApplication.run(), initializing the application context and embedded server.</div>
    
    <div class="question">Q9) What does the @SpringBootApplication annotation do internally?</div>
    <div class="answer">It combines @Configuration, @EnableAutoConfiguration, and @ComponentScan for auto-configuration and component scanning.</div>
    
    <div class="question">Q10) What is Spring Initializr?</div>
    <div class="answer">Spring Initializr is a web tool for generating Spring Boot projects with predefined settings and dependencies.</div>
	 <div class="question">Q11) What is a Spring Bean?</div>
    <div class="answer">A Spring Bean is an object managed by the Spring framework. The framework creates, configures, and connects these beans for us, making it easier to manage dependencies and the lifecycle of objects.</div>
    
    <div class="question">Q12) What is Auto-wiring?</div>
    <div class="answer">Auto-wiring in Spring automatically connects beans to their needed dependencies without manual setup. It uses annotations or XML to find and link beans based on their type or name.</div>
    
    <div class="question">Q13) What is ApplicationRunner in Spring Boot?</div>
    <div class="answer">ApplicationRunner in Spring Boot lets us run code right after the application starts. It is useful for tasks like setting up data or resources.</div>
    
    <div class="question">Q14) What is CommandLineRunner in Spring Boot?</div>
    <div class="answer">CommandLineRunner and ApplicationRunner both let us run code after the application starts. CommandLineRunner uses a String array for arguments, while ApplicationRunner uses an ApplicationArguments object.</div>
    
    <div class="question">Q15) What is Spring Boot CLI and the most used CLI commands?</div>
    <div class="answer">Spring Boot CLI helps quickly create and run Spring applications using simple scripts. Common commands include ‘spring init’ to start a project and ‘spring run’ to execute scripts.</div>
    
    <div class="question">Q16) What is Spring Boot dependency management?</div>
    <div class="answer">Spring Boot dependency management simplifies handling project dependencies using tools like Maven or Gradle.</div>
    
    <div class="question">Q17) Is it possible to change the port of the embedded Tomcat server in Spring Boot?</div>
    <div class="answer">Yes, we can change the port by setting the server.port property in the application.properties file.</div>
    
    <div class="question">Q18) What happens if a starter dependency includes conflicting versions of libraries?</div>
    <div class="answer">Spring Boot resolves conflicts using dependency resolution, ensuring only one compatible version is included.</div>
    
    <div class="question">Q19) What is the default port of Tomcat in Spring Boot?</div>
    <div class="answer">The default port for Tomcat in Spring Boot is 8080.</div>
    
    <div class="question">Q20) Can we disable the default web server in a Spring Boot application?</div>
    <div class="answer">Yes, by setting the spring.main.web-application-type property to none in the application.properties file.</div>
    
    <div class="question">Q21) How to disable a specific auto-configuration class?</div>
    <div class="answer">We can disable specific auto-configuration classes using the exclude attribute of the @EnableAutoConfiguration annotation.</div>
    
    <div class="question">Q22) Can we create a non-web application in Spring Boot?</div>
    <div class="answer">Yes, by setting the application type to 'none', which disables web-specific contexts.</div>
    
    <div class="question">Q23) Describe the flow of HTTPS requests through a Spring Boot application.</div>
    <div class="answer">HTTPS requests pass through the security layer, are routed to controllers, processed, and then returned as encrypted responses.</div>
    
    <div class="question">Q24) Explain @RestController annotation in Spring Boot.</div>
    <div class="answer">@RestController is used to create RESTful web controllers, combining @Controller and @ResponseBody to return JSON/XML responses directly.</div>
	 <div class="question">25) Difference between @Controller and @RestController</div>
    <div class="answer">The key difference is that @Controller is used to mark classes as Spring MVC Controller and typically return a view. @RestController combines @Controller and @ResponseBody, indicating that all methods assume @ResponseBody by default, returning data instead of a view.</div>

    <div class="question">26) What is the difference between RequestMapping and GetMapping?</div>
    <div class="answer">@RequestMapping is a general annotation that can be used for routing any HTTP method requests (like GET, POST, etc.), requiring explicit specification of the method. @GetMapping is a specialized version of @RequestMapping that is designed specifically for HTTP GET requests, making the code more readable and concise.</div>

    <div class="question">27) What are the differences between @SpringBootApplication and @EnableAutoConfiguration annotation?</div>
    <div class="answer">The @SpringBootApplication annotation is a convenience annotation that combines @Configuration, @EnableAutoConfiguration, and @ComponentScan annotations. It is used to mark the main class of a Spring Boot application and trigger auto-configuration and component scanning. On the other hand, @EnableAutoConfiguration specifically enables Spring Boot's auto-configuration mechanism, which attempts to automatically configure our application based on the jar dependencies we have added. It is included within @SpringBootApplication.</div>

    <div class="question">28) How can you programmatically determine which profiles are currently active in a Spring Boot application?</div>
    <div class="answer">In a Spring Boot application, we can find out which profiles are active by using a tool called Environment. First, we include Environment in our code using @Autowired, which automatically fills it with the right information. Then, we use the getActiveProfiles() method of Environment to get a list of all the active profiles. This method gives us the names of these profiles as a simple array of strings.</div>

    <div class="question">29) Mention the differences between WAR and embedded containers.</div>
    <div class="answer">Traditional WAR deployment requires a standalone servlet container like Tomcat, Jetty, or WildFly. In contrast, Spring Boot with an embedded container allows us to package the application and the container as a single executable JAR file, simplifying deployment and ensuring that the environment configurations remain consistent.</div>

    <div class="question">30) What is Spring Boot Actuator?</div>
    <div class="answer">Spring Boot Actuator provides production-ready features to help monitor and manage our application. It includes a number of built-in endpoints that provide vital operational information about the application (like health, metrics, info, dump, env, etc.) which can be exposed via HTTP or JMX.</div>

    <div class="question">31) How to enable Actuator in Spring Boot?</div>
    <div class="answer">To enable Spring Boot Actuator, we simply add the spring-boot-starter-actuator dependency to our project’s build file. Once added, we can configure its endpoints and their visibility properties through the application properties or YAML configuration file.</div>

    <div class="question">32) How to get the list of all the beans in our Spring Boot application?</div>
    <div class="answer">To list all the beans loaded by the Spring ApplicationContext, we can inject the ApplicationContext into any Spring-managed bean and call the getBeanDefinitionNames() method. This will return a String array containing the names of all beans managed by the context.</div>

    <div class="question">33) Can we check the environment properties in our Spring Boot application? Explain how.</div>
    <div class="answer">Yes, we can access environment properties in Spring Boot via the Environment interface. Inject the Environment into a bean using the @Autowired annotation and use the getProperty() method to retrieve properties.</div>

    <div class="question">34) How to enable debugging log in the Spring Boot application?</div>
    <div class="answer">To enable debugging logs in Spring Boot, we can set the logging level to DEBUG in the application.properties or application.yml file by adding a line such as logging.level.root=DEBUG. This will provide detailed logging output, useful for debugging purposes.</div>

    <div class="question">35) Explain the need of dev-tools dependency.</div>
    <div class="answer">The dev-tools dependency in Spring Boot provides features that enhance the development experience. It enables automatic restarts of our application when code changes are detected, which is faster than restarting manually. It also offers additional development-time checks to help us catch common mistakes early.</div>

    <div class="question">36) How do you test a Spring Boot application?</div>
    <div class="answer">To test a Spring Boot application, we use different tools and annotations. For testing the whole application together, we use @SpringBootTest. When we want to test just a part of our application, like the web layer, we use @WebMvcTest. If we are testing how our application interacts with the database, we use @DataJpaTest. Tools like JUnit help us check if things are working as expected, and Mockito lets us replace some parts with dummy versions to focus on what we are testing.</div>

    <div class="question">37) What is the purpose of unit testing in software development?</div>
    <div class="answer">Unit testing is a way to check if small parts of a program work as they should. It helps find mistakes early, making it easier to fix them and keep the program running smoothly. This makes the software more reliable and easier to update later.</div>

    <div class="question">38) How do JUnit and Mockito facilitate unit testing in Java projects?</div>
    <div class="answer">JUnit and Mockito are tools that help test small parts of Java programs. JUnit lets us check if each part works right, while Mockito lets us create fake versions of parts we are not testing. This way, we can focus on testing one thing at a time.</div>

    <div class="question">39) Explain the difference between @Mock and @InjectMocks in Mockito.</div>
    <div class="answer">In Mockito, @Mock is used to create a fake version of an object to test it without using the real one. @InjectMocks is used to put these fake objects into the class we are testing. This helps us see how our class works with the fakes, making sure everything fits together correctly.</div>
	 <div class="question">40) What is the role of @SpringBootTest annotation?</div>
    <div class="answer">The @SpringBootTest annotation in Spring Boot is used for integration testing. It loads the entire application context to ensure that all the components of the application work together as expected.</div>
    
    <div class="question">41) How do you handle exceptions in Spring Boot applications?</div>
    <div class="answer">In Spring Boot, exceptions are handled using @ControllerAdvice or @RestControllerAdvice with methods annotated with @ExceptionHandler.</div>
    
    <div class="question">42) Explain the purpose of the pom.xml file in a Maven project.</div>
    <div class="answer">The pom.xml file in a Maven project is a configuration file that defines project dependencies, build plugins, and other settings for Maven-based builds.</div>
    
    <div class="question">43) How does auto-configuration play an important role in a Spring Boot application?</div>
    <div class="answer">Auto-configuration simplifies setup by automatically configuring components based on classpath dependencies.</div>
    
    <div class="question">44) Can we customize a specific auto-configuration in Spring Boot?</div>
    <div class="answer">Yes, we can override auto-configuration using application properties, YAML files, or custom configuration beans.</div>
    
    <div class="question">45) How can you disable specific auto-configuration classes in Spring Boot?</div>
    <div class="answer">Using @SpringBootApplication(exclude = {ClassName.class}) or the spring.autoconfigure.exclude property in application.properties.</div>
    
    <div class="question">46) What is the purpose of having a spring-boot-starter-parent?</div>
    <div class="answer">It simplifies dependency management and enforces consistent versions across Spring Boot projects.</div>
    
    <div class="question">47) How do starters simplify the Maven or Gradle configuration?</div>
    <div class="answer">Starters bundle commonly used dependencies, reducing manual dependency management.</div>
    
    <div class="question">48) How do you create REST APIs?</div>
    <div class="answer">Using @RestController with request mappings like @GetMapping, @PostMapping, @PutMapping, and @DeleteMapping.</div>
    
    <div class="question">49) What is versioning in REST? What are the ways to implement versioning?</div>
    <div class="answer">Versioning allows APIs to evolve without breaking clients, using URL versioning, query parameters, headers, or media types.</div>
    
    <div class="question">50) What are the REST API Best practices?</div>
    <div class="answer">Follow standard HTTP methods, use clear resource names, implement proper error handling, and secure APIs.</div>
    
    <div class="question">51) What are the uses of ResponseEntity?</div>
    <div class="answer">ResponseEntity allows setting HTTP status codes, headers, and response bodies in a flexible manner.</div>
    
    <div class="question">52) What should the DELETE API method status code be?</div>
    <div class="answer">It should return 200 OK (if a response body is present), 204 No Content (if no response body), or 404 Not Found (if the resource doesn't exist).</div>
    
    <div class="question">53) What is Swagger?</div>
    <div class="answer">Swagger is an open-source tool for designing, documenting, and testing REST APIs.</div>
    
    <div class="question">54) How does Swagger help in documenting APIs?</div>
    <div class="answer">Swagger generates interactive API documentation and provides a user-friendly interface for testing endpoints.</div>
    
    <div class="question">55) What servers does Spring Boot provide, and which one is the default?</div>
    <div class="answer">Spring Boot provides Tomcat, Jetty, and Undertow, with Tomcat being the default embedded server.</div>
    
    <div class="question">56) How does Spring Boot decide which embedded server to use if multiple options are available?</div>
    <div class="answer">Spring Boot selects the first embedded server found in the classpath dependencies.</div>
    
    <div class="question">57) How can we disable the default server and enable a different one?</div>
    <div class="answer">Exclude the default server dependency and add the preferred server dependency in pom.xml or build.gradle.</div>
 
<h1 style="background-color: blue;">Springboot-2</h1> 

 <div class="question">1. How would you handle inter-service communication in a microservices architecture using Spring Boot?</div>
    <div class="answer">For simple, direct communication, I would use RestTemplate. For more complex interactions, Feign Client is preferred. For asynchronous communication, message brokers like RabbitMQ or Kafka ensure a robust system.</div>
    
    <div class="question">2. Can you explain the caching mechanisms available in Spring Boot?</div>
    <div class="answer">Spring Cache Abstraction allows storing frequently used data to enhance performance. It helps avoid redundant operations and speeds up response times.</div>
    
    <div class="question">3. How would you implement caching in a Spring Boot application?</div>
    <div class="answer">Add a caching dependency, enable caching using @EnableCaching, use @Cacheable for caching methods, and select a cache provider like EhCache or Hazelcast.</div>
    
    <div class="question">4. Your Spring Boot application is experiencing performance issues under high load. What steps would you take?</div>
    <div class="answer">Monitor with Spring Boot Actuator, analyze logs, optimize database queries, implement caching, use async methods, and scale the application as needed.</div>
    
    <div class="question">5. What are the best practices for versioning REST APIs in a Spring Boot application?</div>
    <div class="answer">Best practices include URL versioning, header versioning, media type versioning, and parameter versioning.</div>
    
    <div class="question">6. How does Spring Boot simplify the data access layer implementation?</div>
    <div class="answer">Spring Boot auto-configures data sources, provides repository support, initializes schemas, integrates with ORM tools, and simplifies error handling.</div>
    
    <div class="question">7. What are conditional annotations in Spring Boot?</div>
    <div class="answer">Conditional annotations control bean creation based on conditions like class presence. Example: @ConditionalOnClass ensures a bean is created only if a specific class exists.</div>
    
    <div class="question">8. Explain the role of @EnableAutoConfiguration in Spring Boot.</div>
    <div class="answer">It allows automatic configuration based on dependencies and conditions using @Conditional annotations.</div>
    
    <div class="question">9. What are Spring Boot Actuator endpoints?</div>
    <div class="answer">Actuator provides monitoring and management endpoints to check health, metrics, and configurations.</div>
    
    <div class="question">10. How can we secure the actuator endpoints?</div>
    <div class="answer">Limit exposure, use Spring Security for authentication, enable HTTPS, and restrict access via roles.</div>
    
    <div class="question">11. What strategies optimize Spring Boot performance?</div>
    <div class="answer">Implement caching, optimize database queries, use async methods, load balancing, improve time complexity, and utilize WebFlux.</div>
    
    <div class="question">12. How can we handle multiple beans of the same type?</div>
    <div class="answer">Use @Qualifier to specify the bean or mark one as @Primary.</div>
    
    <div class="question">13. Best practices for managing transactions in Spring Boot?</div>
    <div class="answer">Use @Transactional, manage transactions in the service layer, and ensure proper rollback on failures.</div>
    
    <div class="question">14. How do you approach testing in Spring Boot?</div>
    <div class="answer">Use unit testing for isolated components and integration testing for combined functionality.</div>
    
    <div class="question">15. Discuss @SpringBootTest and @MockBean.</div>
    <div class="answer">@SpringBootTest loads the full context for integration tests, while @MockBean replaces a bean with a mock to isolate dependencies.</div>

	<div class="question">16. What advantages does YAML offer over properties files in Spring Boot? Are there limitations when using YAML for configuration?</div>
    <div class="answer">YAML offers several advantages over properties files in Spring Boot. It supports hierarchical configurations, which are more readable and easier to manage, especially for complex structures. YAML also allows comments, aiding documentation. However, YAML has limitations too. It's more error-prone due to its sensitivity to spaces and indentation. Additionally, YAML is less familiar to some developers compared to the straightforward key-value format of properties files.</div>
    
    <div class="question">17. Explain how Spring Boot profiles work.</div>
    <div class="answer">Spring Boot profiles allow us to separate parts of our application configuration and make it available only in certain environments. For example, we might have one set of settings for development, another for testing, and yet another for production. Using profiles helps keep our application flexible and maintainable.</div>
    
    <div class="question">18. Why Use Profiles?</div>
    <div class="answer">Using profiles helps switch environments without changing code. It ensures that our app always behaves appropriately for its current environment.</div>
    
    <div class="question">19. What is aspect-oriented programming in the Spring framework?</div>
    <div class="answer">Aspect-Oriented Programming (AOP) is a programming approach that helps in separating concerns in your program, especially those that cut across multiple parts of an application. It allows keeping the main program code focused on core functionality while handling common concerns like logging, security checks, and transaction management separately.</div>
    
    <div class="question">20. What is Spring Cloud and how is it useful for building microservices?</div>
    <div class="answer">Spring Cloud is a part of the Spring framework that helps manage microservices. It provides tools for service discovery, load balancing, security, and configuration management, simplifying the complexities of developing distributed applications.</div>
    
    <div class="question">21. How does Spring Boot make the decision on which server to use?</div>
    <div class="answer">Spring Boot decides which server to use based on the classpath dependencies. If a specific server dependency, like Tomcat, Jetty, or Undertow, is present, Spring Boot auto-configures it as the default server.</div>
    
    <div class="question">22. How to get the list of all the beans in your Spring Boot application?</div>
    <div class="answer">To list all beans in a Spring Boot application, we can autowire the ApplicationContext and use the getBeanDefinitionNames() method.</div>
    
    <div class="question">23. Describe a Spring Boot project where you significantly improved performance. What techniques did you use?</div>
    <div class="answer">I optimized database interactions with connection pooling and caching, enabled HTTP response compression, and configured stateless sessions in Spring Security. Additionally, I used asynchronous processing to improve concurrency and reduce response times.</div>
    
    <div class="question">24. Explain the concept of Spring Boot's embedded servlet containers.</div>
    <div class="answer">Spring Boot has an embedded servlet container feature, which means it includes a web server like Tomcat, Jetty, or Undertow within the application. This eliminates the need for external server configuration and simplifies deployment.</div>
    
    <div class="question">25. How does Spring Boot make DI easier compared to traditional Spring?</div>
    <div class="answer">Spring Boot simplifies Dependency Injection (DI) by using auto-configuration and component scanning to register beans automatically. Unlike traditional Spring, where beans were manually defined in XML files or annotated explicitly, Spring Boot reduces boilerplate configuration and makes DI more convenient.</div>
	
	<div class="question">26. How does Spring Boot simplify the management of application secrets and sensitive configurations?</div>
    <div class="answer">Spring Boot allows externalized configuration via properties files, environment variables, and secure vaults like Spring Cloud Config and HashiCorp Vault.</div>
    
    <div class="question">27. Explain Spring Boot's approach to handling asynchronous operations.</div>
    <div class="answer">Spring Boot uses the @Async annotation to execute tasks in the background using separate threads, preventing blocking operations.</div>
    
    <div class="question">28. How can you enable and use asynchronous methods in a Spring Boot application?</div>
    <div class="answer">Enable async processing by adding @EnableAsync in a configuration class and annotate asynchronous methods with @Async.</div>
    
    <div class="question">29. How would you secure sensitive data in a Spring Boot application accessed by multiple users with different roles?</div>
    <div class="answer">Implement authentication, role-based access control, encryption, secure storage of credentials, and audit logs.</div>
    
    <div class="question">30. How would you handle file uploads in a Spring Boot application?</div>
    <div class="answer">Use @PostMapping to create an endpoint that accepts MultipartFile and store files in a directory or a cloud storage service.</div>
    
    <div class="question">31. What is the difference between authentication and authorization in Spring Security?</div>
    <div class="answer">Authentication verifies user identity, while authorization determines access permissions.</div>
    
    <div class="question">32. How would you send a welcome email after user registration in Spring Boot?</div>
    <div class="answer">Use JavaMailSender with Spring Boot Starter Mail, configure SMTP settings, and send emails upon successful registration.</div>
    
    <div class="question">33. What is Spring Boot CLI and how to execute a Spring Boot project using it?</div>
    <div class="answer">Spring Boot CLI enables running Spring Boot applications with minimal configuration using Groovy scripts via the command spring run myApp.groovy.</div>
    
    <div class="question">34. How is Spring Security implemented in a Spring Boot application?</div>
    <div class="answer">Include Spring Security dependency, configure authentication and authorization, and use BCryptPasswordEncoder for password hashing.</div>
    
    <div class="question">35. How to disable a specific auto-configuration?</div>
    <div class="answer">Use the exclude attribute in @SpringBootApplication to disable a particular auto-configuration class.</div>
    
    <div class="question">36. What is the difference between cache eviction and cache expiration?</div>
    <div class="answer">Cache eviction removes data to free space, while cache expiration removes outdated data based on a time policy.</div>
    
    <div class="question">37. How would you scale a Spring Boot application for high traffic?</div>
    <div class="answer">Use horizontal scaling, caching, API gateways, and microservices architecture.</div>
    
    <div class="question">38. How do you implement security in a microservices architecture using Spring Boot?</div>
    <div class="answer">Use Spring Security, OAuth2, JWT authentication, and API gateways for centralized access control.</div>
    
    <div class="question">39. How is session management handled in distributed Spring Boot applications?</div>
    <div class="answer">Use Spring Session to store session data in a shared database or cache.</div>
    
    <div class="question">40. How do you handle API rate limits and failures in a Spring Boot application?</div>
    <div class="answer">Implement circuit breakers, retry mechanisms, rate limiting, and caching strategies.</div>
	
	<div class="question">41. How would you manage externalized configuration and secure sensitive configuration properties in a microservices architecture?</div>
    <div class="answer">To handle these settings across microservices in a big project, I would use Spring Cloud Config. It acts as a central repository for configuration settings. The Config Server distributes settings to microservices when requested. Sensitive information is encrypted to ensure security.</div>

    <div class="question">42. Can we create a non-web application in Spring Boot?</div>
    <div class="answer">Yes, we can create non-web applications using Spring Boot. By excluding web dependencies, Spring Boot can be used for batch processing, CLI applications, or background jobs.</div>

    <div class="question">43. What does the @SpringBootApplication annotation do internally?</div>
    <div class="answer">@SpringBootApplication combines @Configuration, @EnableAutoConfiguration, and @ComponentScan to simplify configuration and component scanning in a Spring Boot application.</div>

    <div class="question">44. How does Spring Boot support internationalization (i18n)?</div>
    <div class="answer">Spring Boot supports i18n using resource bundles (messages_xx.properties). LocaleResolver determines the appropriate language based on user preferences.</div>

    <div class="question">45. What Is Spring Boot DevTools Used For?</div>
    <div class="answer">Spring Boot DevTools improves development productivity by enabling automatic application restarts and live reloads.</div>

    <div class="question">46. How can you mock external services in a Spring Boot test?</div>
    <div class="answer">Using @MockBean and Mockito, we can create mock implementations of external services, ensuring faster and reliable unit testing.</div>

    <div class="question">47. How do you mock microservices during testing?</div>
    <div class="answer">Tools like WireMock or Mockito can be used to simulate API responses for microservices, improving test reliability.</div>

    <div class="question">48. Explain the process of creating a Docker image for a Spring Boot application.</div>
    <div class="answer">Write a Dockerfile specifying the Java version, add the app's JAR file, and use docker build to create an image.</div>

    <div class="question">49. Discuss the configuration of Spring Security to address common security concerns.</div>
    <div class="answer">Spring Security is configured for authentication, authorization, HTTPS, CSRF protection, and session management.</div>

    <div class="question">50. Discuss how would you secure a Spring Boot application using JSON Web Token (JWT).</div>
    <div class="answer">JWT tokens authenticate users, reducing database lookups and ensuring stateless security.</div>

    <div class="question">51. How can Spring Boot applications be made more resilient to failures, especially in microservices architectures?</div>
    <div class="answer">Using Resilience4j, circuit breakers, retries, timeouts, and monitoring tools improves fault tolerance.</div>

    <div class="question">52. Explain the conversion of business logic into serverless functions with Spring Cloud Function.</div>
    <div class="answer">Spring Cloud Function allows business logic to run as serverless functions, improving scalability and cost efficiency.</div>

    <div class="question">53. How can Spring Cloud Gateway be configured for routing, security, and monitoring?</div>
    <div class="answer">Routes are defined in properties, security is managed via Spring Security, and monitoring is done using Spring Actuator.</div>

    <div class="question">54. How would you manage and monitor asynchronous tasks in a Spring Boot application?</div>
    <div class="answer">Using @Async, CompletableFuture, and a ThreadPoolTaskExecutor helps manage and monitor background tasks efficiently.</div>

    <div class="question">55. Your application needs to process notifications asynchronously using a message queue. Explain how you would set up the integration and send messages from your Spring Boot application.</div>
    <div class="answer">Using RabbitMQ or Kafka, messages can be queued, ensuring reliable asynchronous communication.</div>

    <div class="question">56. You need to secure a Spring Boot application to ensure that only authenticated users can access certain endpoints. Describe how you would configure Spring Security to set up a basic form-based authentication.</div>
    <div class="answer">Using Spring Security’s WebSecurityConfigurerAdapter, form-based authentication is configured with user roles.</div>

    <div class="question">57. How to Tell an Auto-Configuration to Back Away When a Bean Exists?</div>
    <div class="answer">Using @ConditionalOnMissingBean ensures that auto-configuration does not override existing beans.</div>
	
	 <div class="question">58. How to Deploy Spring Boot Web Applications as Jar and War Files?</div>
    <div class="answer">To deploy Spring Boot web applications, we can package them as either JAR or WAR files. For a JAR, we use Spring Boot's embedded server, like Tomcat, by running the command <code>mvn package</code> and then <code>java -jar target/myapplication.jar</code>. If we need a WAR file for deployment on an external server, we change the packaging in the <code>pom.xml</code> to <code>&lt;packaging&gt;war&lt;/packaging&gt;</code>, ensure the application extends <code>SpringBootServletInitializer</code>, and then build with <code>mvn package</code>. The WAR file can then be deployed to any Java servlet container, like Tomcat or Jetty.</div>
    
    <div class="question">59. What Does It Mean That Spring Boot Supports Relaxed Binding?</div>
    <div class="answer">Spring Boot's relaxed binding means it's flexible in how properties are defined in configuration files. This flexibility allows us to use various formats for property names. For example, if we have a property named <code>server.port</code>, we can write it in different ways like <code>server.port</code>, <code>server-port</code>, or <code>SERVER_PORT</code>. Spring Boot understands these as the same property. This feature makes configuration easier across different environments.</div>
    
    <div class="question">60. Discuss the integration of Spring Boot applications with CI/CD pipelines.</div>
    <div class="answer">Integrating Spring Boot apps with CI/CD pipelines automates building, testing, and deploying. When we push changes, the pipeline builds the app, runs tests, and deploys it if everything passes. Tools like Jenkins or GitHub Actions automate compiling and testing. If tests pass, the app is deployed to a test environment or directly to users, ensuring faster, reliable updates.</div>
    
    <div class="question">61. Can we override or replace the Embedded Tomcat server in Spring Boot?</div>
    <div class="answer">Yes, we can override or replace the embedded Tomcat server in Spring Boot. To use a different server like Jetty or Undertow, we exclude Tomcat as a dependency and include the desired server in <code>pom.xml</code> or <code>build.gradle</code>. Spring Boot automatically configures the new server.</div>
    
    <div class="question">62. How to resolve Whitelabel error page in a Spring Boot application?</div>
    <div class="answer">The Whitelabel Error Page appears when no matching controller exists for a URL. To fix it, ensure correct URL mappings in controllers. Additionally, create custom error pages or use <code>@ControllerAdvice</code> to handle errors globally, providing users with a more meaningful error message.</div>
    
    <div class="question">63. How can you implement pagination in a Spring Boot application?</div>
    <div class="answer">Pagination in Spring Boot can be implemented using Spring Data JPA's <code>Pageable</code> interface. Modify repository query methods to accept a <code>Pageable</code> parameter, then pass a <code>PageRequest</code> specifying page number and size from the service layer. Spring Data JPA returns a <code>Page</code> object containing the requested data along with total pages and elements.</div>
    
    <div class="question">64. How to handle a 404 error in Spring Boot?</div>
    <div class="answer">To handle 404 errors, create a custom error controller by implementing <code>ErrorController</code>. Mark it with <code>@Controller</code>, then define a method mapped to <code>/error</code> to return a custom message or page when a requested URL does not exist.</div>
    
    <div class="question">65. How can Spring Boot be used to implement event-driven architectures?</div>
    <div class="answer">Spring Boot supports event-driven architectures using events and listeners. Define custom events by extending <code>ApplicationEvent</code> and publish them using <code>ApplicationEventPublisher</code>. Use <code>@EventListener</code> to listen for and handle events asynchronously, making the application more modular.</div>
    
    <div class="question">66. What are the basic annotations that Spring Boot offers?</div>
    <div class="answer">Spring Boot provides key annotations such as <code>@SpringBootApplication</code> (combining <code>@Configuration</code>, <code>@EnableAutoConfiguration</code>, and <code>@ComponentScan</code>), <code>@RestController</code> for RESTful APIs, <code>@RequestMapping</code> for URL mappings, <code>@Service</code> and <code>@Repository</code> for service and repository layers, and <code>@Autowired</code> for dependency injection.</div>
    
    <div class="question">67. Discuss the integration and use of distributed tracing in Spring Boot applications for monitoring and troubleshooting.</div>
    <div class="answer">Distributed tracing in Spring Boot, using tools like Spring Cloud Sleuth and Zipkin, assigns unique trace IDs to requests across microservices. This helps visualize request flows, identify performance bottlenecks, and troubleshoot issues efficiently.</div>
    
    <div class="question">68. How would you integrate cloud storage in a Spring Boot application?</div>
    <div class="answer">To integrate cloud storage, use cloud SDKs like AWS SDK for S3 or Google Cloud Storage libraries. Add the SDK as a dependency, configure credentials in <code>application.properties</code>, and create a service class for file upload, download, and deletion.</div>
    
    <div class="question">69. How to implement rate limiting in a Spring Boot API?</div>
    <div class="answer">Rate limiting can be implemented using libraries like Bucket4j or Spring Cloud Gateway. Define rate-limiting policies in application properties or use annotations to control API request rates, preventing abuse and ensuring fair usage.</div>
    
    <div class="question">70. How to implement a soft delete feature in a Spring Boot application?</div>
    <div class="answer">Use a <code>deleted</code> boolean or <code>deleteTimestamp</code> column in database entities. Instead of deleting records, update this column and filter out "deleted" records in queries, preserving data for audits.</div>
    
    <div class="question">71. How would you build a non-blocking, reactive REST API using Spring WebFlux?</div>
    <div class="answer">Add <code>spring-boot-starter-webflux</code> dependency, use <code>@RestController</code>, and return <code>Mono</code> or <code>Flux</code> for asynchronous processing. Use <code>ReactiveCrudRepository</code> for non-blocking database operations, optimizing API performance.</div>
	
	<h1 style="background-color: blue;">Springboot-3</h1> 
	
	 <div class="question">1) If you had to scale a Spring Boot application to handle high traffic, what strategies would you use?</div>
    <div class="answer">
        To scale a Spring Boot application for high traffic, we can:
        <ul>
            <li>Add more app instances (horizontal scaling) and use a load balancer to spread out the traffic.</li>
            <li>Break our app into microservices so each part can be scaled independently.</li>
            <li>Use cloud services that can automatically adjust resources based on our app's needs.</li>
            <li>Use caching to store frequently accessed data, reducing the need to fetch it from the database every time.</li>
            <li>Implement an API Gateway to handle requests and take care of things like authentication.</li>
        </ul>
    </div>

    <div class="question">2) Imagine your application requires data from an external REST API to function. Describe how you would use RestTemplate or WebClient to consume the REST API in your Spring Boot application.</div>
    <div class="answer">
        <strong>Using RestTemplate:</strong>
        <ul>
            <li>Define a RestTemplate bean in a configuration class using <code>@Bean</code> so it can be auto-injected.</li>
            <li>Use RestTemplate to make HTTP calls with methods like <code>getForObject()</code> for a GET request, providing the API URL and response type.</li>
        </ul>
        <strong>Using WebClient:</strong>
        <ul>
            <li>Define a WebClient bean using <code>@Bean</code>.</li>
            <li>Make asynchronous requests using methods like <code>get()</code>, <code>retrieve()</code>, and handle responses using <code>bodyToMono()</code> or <code>bodyToFlux()</code> depending on expected data type.</li>
        </ul>
    </div>

    <div class="question">3) Your Spring Boot backend needs to accept cross-origin requests from a specific frontend domain. Explain how you would configure CORS policies in your application.</div>
    <div class="answer">
        To enable cross-origin requests from a specific domain:
        <ul>
            <li>Use <code>@CrossOrigin(origins = "http://example.com")</code> annotation on the controller or method.</li>
            <li>For a global approach, configure a <code>WebMvcConfigurer</code> bean and override <code>addCorsMappings</code> to allow requests from a specified domain.</li>
        </ul>
    </div>

    <div class="question">4) Your Spring Boot application is experiencing performance issues under high load. What are the steps you would take to identify and address the performance?</div>
    <div class="answer">
        Steps to identify and fix performance issues:
        <ul>
            <li>Use monitoring tools like Spring Boot Actuator or Splunk.</li>
            <li>Analyze logs and metrics to spot patterns or errors under high load.</li>
            <li>Run performance tests and use a profiler to analyze code execution.</li>
            <li>Optimize database queries, implement caching, and consider scaling options.</li>
            <li>Continuously monitor the application to prevent future issues.</li>
        </ul>
    </div>

    <div class="question">5) Imagine you need to make a simple web application with Spring Boot that serves a static homepage and a dynamic page displaying current server time. Discuss the project structure you would use.</div>
    <div class="answer">
        I would place the main application and a web controller in the <code>src/main/java</code> directory. The controller would have mappings for the homepage (<code>@GetMapping("/")</code>) and the server time page (<code>@GetMapping("/time")</code>). Static content, like <code>index.html</code>, would go in <code>src/main/resources/static</code>, while dynamic content would use Thymeleaf templates in <code>src/main/resources/templates</code>. Configuration settings would be stored in <code>src/main/resources/application.properties</code>. This setup ensures clear separation and easy management of web content.
    </div>

    <div class="question">6) Your application behaves differently in development and production environments. How would you use Spring profiles to manage these differences?</div>
    <div class="answer">
        To handle differences between development and production environments, I would use Spring profiles.
        <ul>
            <li>Define environment-specific configurations in <code>application-dev.properties</code> for development and <code>application-prod.properties</code> for production.</li>
            <li>Activate profiles using the <code>spring.profiles.active</code> property, command-line arguments, or environment variables.</li>
            <li>Use the <code>@Profile</code> annotation to selectively load beans or configurations based on the current environment.</li>
        </ul>
    </div>

    <div class="question">7) What strategies would you use to optimize the performance of a Spring Boot application?</div>
    <div class="answer">
        Some optimization strategies include:
        <ul>
            <li>Implement caching for frequently accessed data.</li>
            <li>Optimize database queries to reduce the load on the database.</li>
            <li>Use asynchronous methods for operations like sending emails.</li>
            <li>Use a load balancer if traffic is high.</li>
            <li>Optimize the time complexity of the code.</li>
            <li>Use WebFlux to handle a large number of concurrent connections.</li>
        </ul>
    </div>
	
	<div class="question">8) Describe a scenario where a Spring Boot application needs to dynamically switch between multiple data sources at runtime based on the request context.</div>
    <div class="answer">Imagine a Spring Boot application that serves users from different places, like Europe or Asia. We switch between databases based on where the user is from. If someone from Europe visits the app, they get data from the European database, making the content more relevant to them. We set this up by having a special part in the app that knows which database to use when it sees where the request is coming from. This way, users see information and offers that make sense for their region.</div>

    <div class="question">9) Discuss how you would add a GraphQL API to an existing Spring Boot RESTful service.</div>
    <div class="answer">First, I'd add GraphQL Java and GraphQL Spring Boot starter dependencies to my pom.xml or build.gradle file. Secondly, I'd create a GraphQL schema file (schema.graphqls) in the src/main/resources folder. Then, I'd implement data fetchers to retrieve data from the existing services or directly from the database. Moving ahead, I'd configure a GraphQL service using the schema and data fetchers. Then, I would expose the GraphQL endpoint and make sure it is correctly configured. Finally, I'd test the GraphQL API using tools like GraphiQL or Postman to ensure it's working as expected.</div>

    <div class="question">10) Describe how you would secure sensitive data in a Spring Boot application that is accessed by multiple users with different roles.</div>
    <div class="answer">To keep sensitive information safe in a Spring Boot app used by many people with different roles, I would do a few things. First, I would make sure everyone who uses the app proves who they are through a login system. Then, I'd use special settings to control what each person can see or do in the app based on their role. Some users can see more sensitive data while others can’t. I'd also encrypt any secret information stored in the app or sent over the internet so that only the right people can understand it. Plus, I'd keep passwords and other secret keys out of the code and in a safe place, making them easy to change if needed. Lastly, I'd keep track of who accesses or changes sensitive information to enhance security.</div>

    <div class="question">11) In an IoT application scenario, explain how a Spring Boot backend could be designed to efficiently process and analyze real-time data streams from thousands of IoT devices.</div>
    <div class="answer">In an IoT setup, a Spring Boot backend can manage data from lots of devices by using Apache Kafka, a tool that helps collect all the data. It then processes this data in real-time, figuring out what's important and what's not. After sorting the data, it stores it in a database designed for quick access and analysis. This way, the system can handle tons of information coming in all at once, ensuring everything runs smoothly and quickly.</div>

    <div class="question">12) Discuss the specific security challenges associated with using WebSockets in a Spring Boot application.</div>
    <div class="answer">WebSockets in Spring Boot apps face security issues because they keep a constant connection open between the user and the server, unlike regular web pages. This can lead to risks like attackers hijacking these connections to intercept or send fake messages. Also, without the usual security checks we have for web pages, it's trickier to stop unauthorized access. To keep things safe, it's important to make sure only the right people can connect and to encrypt the data being sent back and forth.</div>

    <div class="question">13) How would you implement efficient handling of large file uploads in a Spring Boot REST API, ensuring that the system remains responsive and scalable?</div>
    <div class="answer">To handle big file uploads in a Spring Boot REST API without slowing down the system, I'd use a method that processes files in the background and streams them directly where they need to go, like a hard drive or the cloud. This way, the main part of the app stays fast and can handle more users or tasks at the same time. Also, by saving files outside the main server, like on Amazon S3, it helps the app run smoothly even as it grows or when lots of users are uploading files.</div>

    <div class="question">14) How would you use Spring WebFlux to consume data from an external service in a non-blocking manner and process this data reactively within your Spring Boot application?</div>
    <div class="answer">In a Spring Boot app using Spring WebFlux, I'd use WebClient to fetch data from an external service without slowing things down. WebClient makes it easy to get data in a way that doesn't stop other parts of the app from working. When the data comes in, it's handled reactively, meaning I can work with it on the go, like filtering or changing it without waiting for everything to finish loading. This keeps the app fast and responsive, even when dealing with a lot of data or making many requests.</div>

    <div class="question">15) Imagine you need to develop a REST API in a Spring Boot application that allows clients to manage user data. Explain how you would structure your application.</div>
    <div class="answer">To build a REST API in Spring Boot for managing user data, I'd organize the app into three main parts: Controllers, Services, and Repositories. Controllers would deal with web requests, using endpoints like /users to handle different actions—getting, adding, updating, and deleting user info. Services would focus on the app's logic, like checking if a user's data meets certain criteria before saving it. Repositories would connect to the database to actually save, update, or fetch user data. This setup keeps everything neat and makes it easier to update parts of the app without affecting others.</div>
	
	 <div class="question">16) Imagine you are designing a Spring Boot application that interfaces with multiple external APIs. How would you handle API rate limits and failures?</div>
    <div class="answer">
        To handle API rate limits and failures in a Spring Boot application, I would:
        <ul>
            <li>Use a circuit breaker to manage failures</li>
            <li>Implement rate limiting to avoid exceeding API limits</li>
            <li>Add a retry mechanism with exponential backoff for temporary issues</li>
            <li>Use caching to reduce the number of requests</li>
        </ul>
        This approach helps keep the application reliable and efficient.
    </div>

    <div class="question">17) You need to deploy a Spring Boot application to a cloud platform (e.g., AWS, Azure). What steps would you take, and how would you configure the application properties for different environments?</div>
    <div class="answer">
        To deploy a Spring Boot app to the cloud, like AWS or Azure, first, I'd package it using Maven or Gradle. Next, I'd pick a cloud service that makes deployment easy, such as AWS Elastic Beanstalk or Azure App Service. For different settings in development, staging, and production, I'd use Spring profiles.
        <br><br>
        I'd make separate property files for each environment, like <code>application-dev.properties</code> for development. When deploying, I'd choose the right profile for that environment, making sure the app uses the correct settings. This way, the app runs smoothly in any environment with the right configurations.
    </div>

    <div class="question">18) Explain how you would use application events in Spring Boot to notify different parts of your application about significant activities.</div>
    <div class="answer">
        In Spring Boot, to let different parts of the app know about important activities, I'd use application events. First, I'd create special event classes for different types of activities, like when a new user signs up. Then, I'd write listeners for these events, which are just pieces of code that wait for a specific event to happen and then do something in response.
        <br><br>
        To tell the app when something important happens, I'd publish these events from anywhere in the app. This way, parts of the app can communicate and react to events without being directly connected, keeping the code clean and organized.
    </div>

<h1 style="background-color: blue;">Microservices</h1>
<div class="question">Q1) What are microservices?</div>
<div class="answer">Microservices are a way of designing software as a collection of small, independent services that work together. Each service is responsible for a specific function and can be developed, deployed, and scaled independently. This approach enhances flexibility, simplifies maintenance, and allows teams to use different technologies best suited for each service.</div>

<div class="question">Q2) How do microservices differ from monolithic architectures?</div>
<div class="answer">Microservices break an application into smaller, self-contained units that operate independently, making updates and scaling more efficient. In contrast, a monolithic architecture combines all components into a single application, making modifications and scaling more complex since any change can impact the entire system.</div>

<div class="question">Q3) What are some benefits of using microservices?</div>
<div class="answer">Microservices offer multiple benefits, such as independent scalability of services, flexibility in using different programming languages, faster deployment cycles, and better fault isolation. They also enhance team productivity by enabling smaller, focused teams to work on different services without affecting the entire application.</div>

<div class="question">Q4) Can you mention any challenges you might face while working with microservices?</div>
<div class="answer">Working with microservices introduces challenges like managing inter-service communication, handling network latency, ensuring data consistency, and maintaining security across multiple services. Additionally, debugging and monitoring become more complex due to distributed system architecture, requiring specialized tools and logging mechanisms.</div>

<div class="question">Q5) What is the role of an API Gateway in microservices?</div>
<div class="answer">An API Gateway acts as a single entry point for client requests in a microservices architecture. It handles request routing, authentication, rate limiting, load balancing, and response aggregation. This simplifies client interactions, improves security, and enhances performance by reducing direct service-to-service communication overhead.</div>

<div class="question">Q6) How does an API Gateway manage traffic?</div>
<div class="answer">An API Gateway helps manage traffic by directing requests to the right part of the application and spreading the workload evenly to avoid overloading any single service. It can limit the number of requests to maintain smooth operation and prevent crashes during busy times. The API Gateway can also remember common responses, reducing the need to ask the backend services repeatedly, which speeds up the process and reduces the load on the system.</div>

<div class="question">Q7) What are some security measures that can be implemented at the API Gateway?</div>
<div class="answer">At the API Gateway, we can boost security by adding several protections. This includes checking user identities (authentication), ensuring they have the right permissions (authorization), and encrypting data sent over the internet (SSL/TLS encryption). The gateway can also limit how many requests a user can make to prevent overload and attacks (rate limiting). Plus, it checks and cleans up the data coming in to stop harmful actions like SQL injection or XSS attacks. These steps help keep the application safe from attacks.</div>

<div class="question">Q8) Can you explain how an API Gateway can handle load balancing?</div>
<div class="answer">An API Gateway manages load balancing by spreading out incoming traffic evenly across multiple services or servers. This prevents any one part of the application from getting too many requests and possibly slowing down or crashing. The gateway decides where to send each request based on how busy servers are, how they are performing, and where the user is located. This way, the application runs more smoothly and responds faster to users.</div>

<div class="question">Q9) How do microservices communicate with each other?</div>
<div class="answer">Microservices communicate with each other using simple methods like HTTP (the same technology that powers the web) or through messaging systems that send and receive information. They use specific interfaces called APIs, which let them exchange data and requests without needing to know how other services are built. This setup allows them to work together as parts of a single application, each handling its tasks and talking to others as needed.</div>

<div class="question">Q10) What is synchronous vs. asynchronous communication?</div>
<div class="answer">Synchronous communication is like having a conversation on the phone—we talk, then the other person immediately responds while both of us are connected. Asynchronous communication is like sending an email—we send a message, and the other person can reply whenever they have time, without both needing to be present at the same moment. In software, synchronous means waiting for a task to finish before starting another, while asynchronous allows tasks to run in the background, letting us do multiple things at once.</div>

<div class="question">Q11) Can you explain the role of message brokers in microservices?</div>
<div class="answer">In microservices, message brokers help different parts of an application talk to each other without being directly connected. They act like mail carriers, picking up messages from one service and delivering them to another. This helps keep the services independent and improves the system’s ability to handle more users or tasks smoothly. Message brokers manage the queuing, routing, and safe delivery of messages, making communication more reliable and efficient.</div>

<div class="question">Q12) What are some of the risks involved with inter-service communication?</div>
<div class="answer">When different services in a microservices architecture talk to each other, there are a few risks. Network problems can slow down communication or cause messages to get lost, which can mess up how the application works. Managing many services talking to each other can also lead to mistakes or inconsistent data if they're not perfectly synchronized. Each service is also a potential weak spot for security—if one service has a security issue, it could affect the whole system. Lastly, relying heavily on network communication can make it tough to find and fix problems when they happen.</div>

<div class="question">Q13) What is a Service Registry?</div>
<div class="answer">A Service Registry in microservices is like a phonebook for services. It lists all the services in the system, where they are, and whether they are available to use. When a service starts, it adds itself to this list. Other services check this list to find and connect with the services they need. This setup helps manage traffic effectively, balance the workload, and adjust to changes, such as when services are added or removed.</div>

<div class="question">Q14) How does service discovery work in microservices?</div>
<div class="answer">Service discovery in microservices helps services find and talk to each other. When a service starts up, it tells a central Service Registry where it is and how to connect to it. When one service needs to communicate with another, it checks this registry to find the most current information on where and how to connect to the other service. This system makes sure that services can always find each other, even as they change or move around within the network.</div>

<div class="question">Q15) What would happen if a service registry fails?</div>
<div class="answer">If a service registry fails, it can cause big problems in a microservices system because services use the registry to find and connect with each other. Without the registry, services might not be able to locate the ones they need, leading to failures in processing requests. This could make parts of the application stop working. To prevent such issues, systems often have backup registries and setups that ensure the registry is always available, even if one part fails.</div>

<div class="question">Q16) How do microservices update their registration and discovery information?</div>
<div class="answer">In microservices, services keep their registration and discovery information up-to-date by regularly checking in with the Service Registry. When a service starts or changes (like moving to a new address), it updates its details in the registry. It also sends frequent "heartbeat" signals to show it's still running. If the registry stops getting these signals, it thinks the service has stopped working and removes it from the list, so other services don't try to connect to something that isn't there. This keeps the system's information accurate and reliable.</div>

<div class="question">Q17) How do you handle data consistency in microservices?</div>
<div class="answer">In microservices, keeping data consistent involves a few strategies. One common approach is using events to update data across services slowly but reliably—this is called eventual consistency. Another method is the saga pattern, where a series of steps or transactions are performed across different services to complete a larger process. These methods help ensure that even though services are separate, the data across them remains accurate and consistent.</div>

<div class="question">Q18) What is eventual consistency?</div>
<div class="answer">Eventual consistency is a concept used when managing data across different locations in a network. It means that when data is updated in one place, it might take some time before all parts of the system see the change. This approach allows the system to run faster and handle more users or actions at once, even though the data might not be exactly the same everywhere right away. Eventually, all parts of the system will have the updated data.</div>

<div class="question">Q19) What are some security measures that can be implemented at the API Gateway?</div>
<div class="answer">At the API Gateway, we can boost security by adding several protections. This includes checking user identities (authentication), ensuring they have the right permissions (authorization), and encrypting data sent over the internet (SSL/TLS encryption). The gateway can also limit how many requests a user can make to prevent overload and attacks (rate limiting). Plus, it checks and cleans up the data coming in to stop harmful actions like SQL injection or XSS attacks. These steps help keep the application safe from attacks.</div>

<div class="question">Q20) Can you explain how an API Gateway can handle load balancing?</div>
<div class="answer">An API Gateway manages load balancing by spreading out incoming traffic evenly across multiple services or servers. This prevents any one part of the application from getting too many requests and possibly slowing down or crashing. The gateway decides where to send each request based on how busy servers are, how they are performing, and where the user is located. This way, the application runs more smoothly and responds faster to users.</div>

<div class="question">Q21) How do microservices communicate with each other?</div>
<div class="answer">Microservices communicate with each other using simple methods like HTTP (the same technology that powers the web) or through messaging systems that send and receive information. They use specific interfaces called APIs, which let them exchange data and requests without needing to know how other services are built. This setup allows them to work together as parts of a single application, each handling its tasks and talking to others as needed.</div>

<div class="question">Q22) What is synchronous vs. asynchronous communication?</div>
<div class="answer">Synchronous communication is like having a conversation on the phone—we talk, then the other person immediately responds while both of us are connected. Asynchronous communication is like sending an email—we send a message and the other person can reply whenever they have time, without both needing to be present at the same moment. In software, synchronous means waiting for a task to finish before starting another, while asynchronous allows tasks to run in the background, letting us do multiple things at once.</div>

<div class="question">Q23) Can you explain the role of message brokers in microservices?</div>
<div class="answer">In microservices, message brokers help different parts of an application talk to each other without being directly connected. They act like mail carriers, picking up messages from one service and delivering them to another. This helps keep the services independent and improves the system’s ability to handle more users or tasks smoothly. Message brokers manage the queuing, routing, and safe delivery of messages, making communication more reliable and efficient.</div>

<div class="question">Q24) What are some of the risks involved with inter-service communication?</div>
<div class="answer">When different services in a microservices architecture talk to each other, there are a few risks. Network problems can slow down communication or cause messages to get lost, which can mess up how the application works. Managing many services talking to each other can also lead to mistakes or inconsistent data if they're not perfectly synchronized. Each service is also a potential weak spot for security—if one service has a security issue, it could affect the whole system. Lastly, relying heavily on network communication can make it tough to find and fix problems when they happen.</div>

<div class="question">Q25) What metrics are important to monitor in a microservices architecture?</div>
<div class="answer">In a microservices architecture, it's important to keep an eye on how fast services respond, how often errors occur, and how much CPU, memory, and storage they use. We should also watch the traffic between services, how they connect with each other, and how quickly data moves across the network. Monitoring how many requests each service handles helps in managing workloads and spotting any unusual increases in activity.</div>

<div class="question">Q26) How can distributed tracing help in monitoring microservices?</div>
<div class="answer">Distributed tracing helps monitor microservices by tracking how requests move through different services. It shows where delays happen, which service might be causing problems, and how changes in one service affect others. This makes it easier to find and fix issues, improving how the whole system works.</div>

<div class="question">Q27) What tools can be used for logging and monitoring in a microservices environment?</div>
<div class="answer">In a microservices environment, we can use tools like Prometheus for tracking metrics, Grafana for making charts and graphs, and the ELK Stack (Elasticsearch, Logstash, Kibana) for managing logs and creating visuals. Jaeger and Zipkin are good for tracing how requests travel through our services. These tools help us understand how our services are performing and quickly find and fix any issues.</div>

<div class="question">Q28) How do you ensure security in microservices?</div>
<div class="answer">To ensure security in microservices, we should use strong authentication and authorization to control who can access services, encrypt data being sent and stored, and communicate securely using HTTPS. Keep services updated to protect against vulnerabilities, restrict access rights to the minimum needed, and continuously scan for security weaknesses. Logging what happens within the services also helps quickly spot and address any security issues.</div>

<div class="question">Q29) What are the common security patterns applicable in microservices?</div>
<div class="answer">In microservices, common security patterns include using an API Gateway to handle and check incoming requests, setting up service-to-service authentication with tokens or certificates, and gradually securing old systems with the Strangler pattern. It's also important to encrypt data being sent and stored, regularly check for security weaknesses, and use the Sidecar pattern to add security features to services without changing their main code. These methods help keep the system safe.</div>

<div class="question">Q30) How can services securely communicate with each other?</div>
<div class="answer">To make sure services in a microservices system talk to each other securely, they should use HTTPS, which encrypts the data sent between them. Mutual TLS (mTLS) is another good method, providing both encryption and authentication to make sure only allowed services can connect. Also, using an API Gateway helps manage and secure communications, and using access tokens or API keys confirms the identity of services before they can communicate with each other.</div>
<div class="question">Q31) What are the implications of service-specific databases on security?</div>
<div class="answer">Using service-specific databases in a microservices setup can make the system more secure because if one service gets compromised, the breach affects only that service's data. Each database can have security settings that fit its own needs, which helps in protecting sensitive information better. This setup also allows for easier management of who can access what data. However, it requires careful management to ensure all databases meet the security standards and prevent unauthorized access.</div>

<div class="question">Q32) Discuss the patterns used to handle failures in microservices.</div>
<div class="answer">In microservices, to manage failures, several patterns are used. The Circuit Breaker pattern stops repeated attempts to a service that's failing, which helps avoid further errors. Fallback methods give an alternative plan when a service fails. The Retry pattern tries the request again, using delays to reduce pressure on the system. Bulkhead and Timeout patterns keep failures in one service from affecting others and prevent long waits for responses.</div>

<div class="question">Q33) What is the Circuit Breaker pattern?</div>
<div class="answer">The Circuit Breaker pattern is like a safety switch for microservices. If a service starts to fail often, this pattern stops more requests from going to that failing service. This prevents further problems and gives the service time to fix itself. After a set time, it checks if the service is working well again before allowing requests to go through, helping to keep the system stable.</div>

<div class="question">Q34) How does the Bulkhead pattern help in improving system resilience?</div>
<div class="answer">The Bulkhead pattern makes a system more reliable by dividing it into separate sections, similar to compartments in a ship. If one section has a problem, it doesn't affect the others. This separation helps ensure that if one part of the system fails or gets too busy, it won't drag down the entire system. Each section has its own resources, so they don't overwhelm each other, keeping the system stable.</div>

<div class="question">Q35) Can you explain the Retry and Backoff patterns?</div>
<div class="answer">The Retry pattern means trying a failed operation again, which can help solve temporary problems like a network glitch. The Backoff pattern adds waiting times between these retries, increasing the wait after each attempt. This helps avoid overloading the system while it's still recovering. Using these patterns together helps the system handle failures smoothly by not rushing to retry, giving everything a better chance to get back to normal.</div>

<h1 style="background-color: blue;">Common-Step-Java-Coding</h1>

 <h3>Q1: Write a Java Program to reverse a string without using String inbuilt function.</h3>
    <p><strong>Explanation:</strong> This solution manually swaps the characters of the string from the start and end, moving towards the center, effectively reversing the string without using any built-in functions.</p>
    <pre><code>
public String reverseString(String input) {
    char[] chars = input.toCharArray();
    int left = 0, right = chars.length - 1;
    while (left < right) {
        char temp = chars[left];
        chars[left] = chars[right];
        chars[right] = temp;
        left++;
        right--;
    }
    return new String(chars);
}
    </code></pre>
    
    <h3>Q2: Write a Java Program to swap two numbers without using the third variable.</h3>
    <p><strong>Explanation:</strong> This method uses arithmetic operations to swap two numbers without a temporary variable. It first adds the two numbers and stores the result in <code>a</code>, then subtracts <code>b</code> from the new <code>a</code> to recover the original <code>a</code> and assigns it to <code>b</code>, and finally subtracts the new <code>b</code> from the new <code>a</code> to recover the original <code>b</code>.</p>
    <pre><code>
public void swapNumbers(int a, int b) {
    a = a + b;
    b = a - b;
    a = a - b;
    System.out.println("After swap: a = " + a + ", b = " + b);
}
    </code></pre>
    
    <h3>Q3: Write a Java Program to count the number of words in a string using HashMap.</h3>
    <p><strong>Explanation:</strong> This solution splits the input string into words using a space delimiter, then uses a HashMap to count the occurrences of each word. The <code>getOrDefault</code> method is used to simplify the counting logic.</p>
    <pre><code>
public Map<String, Integer> countWords(String input) {
    Map<String, Integer> wordCount = new HashMap<>();
    String[] words = input.split("\\s+");
    for (String word : words) {
        wordCount.put(word, wordCount.getOrDefault(word, 0) + 1);
    }
    return wordCount;
}
    </code></pre>
    
    <h3>Q4: Write a Java Program to iterate HashMap using While and Advanced for Loop.</h3>
    <p><strong>Explanation:</strong> This method shows two ways to iterate over a HashMap: using an enhanced for loop to traverse the entry set, and using an iterator in a while-loop to perform the same task.</p>
    <pre><code>
public void iterateHashMap(Map<String, String> map) {
    // Using advanced for-loop
    for (Map.Entry<String, String> entry : map.entrySet()) {
        System.out.println(entry.getKey() + " -> " + entry.getValue());
    }
    
    // Using while-loop with iterator
    Iterator<Map.Entry<String, String>> iterator = map.entrySet().iterator();
    while (iterator.hasNext()) {
        Map.Entry<String, String> entry = iterator.next();
        System.out.println(entry.getKey() + " -> " + entry.getValue());
    }
}

  <h3>Q5: Write a Java Program to find whether a number is prime or not in the most efficient way.</h3>
    <p><strong>Explanation:</strong> This function checks for divisibility using small primes and iterates through potential factors up to the square root of the number.</p>
    <pre><code>
public boolean isPrime(int num) {
    if (num <= 1) return false;
    if (num <= 3) return true;
    if (num % 2 == 0 || num % 3 == 0) return false;
    for (int i = 5; i * i <= num; i += 6) {
        if (num % i == 0 || num % (i + 2) == 0) return false;
    }
    return true;
}
    </code></pre>
    
    <h3>Q6: Write a Java Program to find whether a string or number is palindrome or not.</h3>
    <p><strong>Explanation:</strong> This method checks if a string is a palindrome by comparing characters from both ends moving toward the center.</p>
    <pre><code>
public boolean isPalindrome(String input) {
    int left = 0, right = input.length() - 1;
    while (left < right) {
        if (input.charAt(left) != input.charAt(right)) {
            return false;
        }
        left++;
        right--;
    }
    return true;
}
    </code></pre>
    
    <h3>Q7: Write a Java Program for the Fibonacci series using recursion.</h3>
    <p><strong>Explanation:</strong> This recursive function computes Fibonacci numbers.</p>
    <pre><code>
public int fibonacci(int n) {
    if (n <= 1) return n;
    return fibonacci(n - 1) + fibonacci(n - 2);
}
    </code></pre>
    
    <h3>Q8: Write a Java Program to iterate ArrayList using for-loop, while-loop, and advanced for-loop.</h3>
    <p><strong>Explanation:</strong> This method demonstrates three different ways to iterate through an ArrayList.</p>
    <pre><code>
public void iterateList(List<Integer> list) {
    for (int i = 0; i < list.size(); i++) {
        System.out.println(list.get(i));
    }
    int j = 0;
    while (j < list.size()) {
        System.out.println(list.get(j));
        j++;
    }
    for (int item : list) {
        System.out.println(item);
    }
}
    </code></pre>
	
	  <h3>Q9: Write a Java Program to find the duplicate characters in a string.</h3>
    <p><strong>Explanation:</strong> This solution uses a HashMap to count the occurrences of each character in the string. It then checks which characters have a count greater than one to identify duplicates.</p>
    <pre><code>
public void findDuplicates(String input) {
    HashMap<Character, Integer> charCount = new HashMap<>();
    for (char c : input.toCharArray()) {
        charCount.put(c, charCount.getOrDefault(c, 0) + 1);
    }
    for (Map.Entry<Character, Integer> entry : charCount.entrySet()) {
        if (entry.getValue() > 1) {
            System.out.println(entry.getKey() + " appears " + entry.getValue() + " times");
        }
    }
}
    </code></pre>

    <h3>Q10: Write a Java Program to find the second-highest number in an array.</h3>
    <p><strong>Explanation:</strong> This method maintains two variables to track the highest and second-highest numbers. It iterates through the array once, updating these values appropriately to find the second-highest number.</p>
    <pre><code>
public int secondHighest(int[] nums) {
    int highest = Integer.MIN_VALUE, secondHighest = Integer.MIN_VALUE;
    for (int num : nums) {
        if (num > highest) {
            secondHighest = highest;
            highest = num;
        } else if (num > secondHighest && num != highest) {
            secondHighest = num;
        }
    }
    return secondHighest;
}
    </code></pre>

    <h3>Q11: Write a Java Program to check Armstrong number.</h3>
    <p><strong>Explanation:</strong> An Armstrong number is a number that is equal to the sum of its own digits each raised to the power of the number of digits. This function checks if the given number is an Armstrong number.</p>
    <pre><code>
public boolean isArmstrong(int number) {
    int original = number, sum = 0;
    int digits = String.valueOf(number).length();
    while (number > 0) {
        int digit = number % 10;
        sum += Math.pow(digit, digits);
        number /= 10;
    }
    return sum == original;
}
    </code></pre>

    <h3>Q12: Write a Java Program to remove all white spaces from a string without using replace().</h3>
    <p><strong>Explanation:</strong> This method iterates through the string, appending only non-space characters to a StringBuilder to create the final string without spaces.</p>
    <pre><code>
public String removeWhitespaces(String input) {
    StringBuilder result = new StringBuilder();
    for (int i = 0; i < input.length(); i++) {
        if (input.charAt(i) != ' ') {
            result.append(input.charAt(i));
        }
    }
    return result.toString();
}
    </code></pre>

    <h3>Q13: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.</h3>
    <p><strong>Explanation:</strong> This solution uses a hash map to track each element's complement (i.e., target - nums[i]). If a complement is found in the map, the indices of the current element and its complement are returned.</p>
    <pre><code>
public int[] twoSum(int[] nums, int target) {
    Map<Integer, Integer> numMap = new HashMap<>();
    for (int i = 0; i < nums.length; i++) {
        int complement = target - nums[i];
        if (numMap.containsKey(complement)) {
            return new int[] { numMap.get(complement), i };
        }
        numMap.put(nums[i], i);
    }
    throw new IllegalArgumentException("No two sum solution");
}
    </code></pre>

    <h3>Q14: Write a program that accepts comma-separated strings, sorts the strings in ascending order, and outputs the concatenated string of sorted strings.</h3>
    <p><strong>Explanation:</strong> This method splits the input string into an array using commas as delimiters, sorts the array, and then concatenates the sorted strings into a single string.</p>
    <pre><code>
public String sortAndConcatenate(String input) {
    String[] parts = input.split(",");
    Arrays.sort(parts);
    return String.join("", parts);
}
    </code></pre>
	
	 <h3>Q15: Write a Java Program to check if all characters in a string appear the same number of times.</h3>
    <p><strong>Explanation:</strong> This solution creates an array to count occurrences of each letter in the string. It then checks if all non-zero counts are the same.</p>
    <pre><code>
public boolean areOccurrencesEqual(String s) {
    int[] count = new int[26];
    for (char c : s.toCharArray()) {
        count[c - 'a']++;
    }
    int frequency = 0;
    for (int i = 0; i < 26; i++) {
        if (count[i] != 0) {
            if (frequency == 0) {
                frequency = count[i];
            } else if (frequency != count[i]) {
                return false;
            }
        }
    }
    return true;
}
    </code></pre>

    <h3>Q16: Write a Java Program to remove all instances of a given value from an array in-place.</h3>
    <p><strong>Explanation:</strong> This solution uses two pointers to modify the array in-place, ensuring an O(1) space complexity.</p>
    <pre><code>
public int removeElement(int[] nums, int val) {
    int i = 0;
    for (int j = 0; j < nums.length; j++) {
        if (nums[j] != val) {
            nums[i] = nums[j];
            i++;
        }
    }
    return i;
}
    </code></pre>

    <h3>Q17: Given an array and queries, update the array and return the sum of even numbers.</h3>
    <p><strong>Explanation:</strong> This solution keeps track of even numbers' sum and efficiently updates it as per queries.</p>
    <pre><code>
public int[] sumEvenAfterQueries(int[] nums, int[][] queries) {
    int sumEven = 0;
    for (int num : nums) {
        if (num % 2 == 0) sumEven += num;
    }
    int[] result = new int[queries.length];
    for (int i = 0; i < queries.length; i++) {
        int val = queries[i][0], index = queries[i][1];
        if (nums[index] % 2 == 0) sumEven -= nums[index];
        nums[index] += val;
        if (nums[index] % 2 == 0) sumEven += nums[index];
        result[i] = sumEven;
    }
    return result;
}
    </code></pre>

    <h3>Q18: Find all start indices of anagrams of a given string in another string.</h3>
    <p><strong>Explanation:</strong> Uses a sliding window approach to efficiently detect anagrams.</p>
    <pre><code>
public List<Integer> findAnagrams(String s, String p) {
    List<Integer> result = new ArrayList<>();
    if (s.length() == 0 || p.length() > s.length()) return result;
    int[] charCount = new int[26];
    for (char c : p.toCharArray()) {
        charCount[c - 'a']++;
    }
    int start = 0, end = 0, count = p.length();
    while (end < s.length()) {
        if (charCount[s.charAt(end++) - 'a']-- >= 1) count--;
        if (count == 0) result.add(start);
        if (end - start == p.length() && charCount[s.charAt(start++) - 'a']++ >= 0) count++;
    }
    return result;
}
    </code></pre>

    <h3>Q19: Find the length of the longest substring without repeating characters.</h3>
    <p><strong>Explanation:</strong> Uses a sliding window to efficiently track non-repeating characters.</p>
    <pre><code>
public int lengthOfLongestSubstring(String s) {
    int[] chars = new int[128];
    int left = 0, right = 0, res = 0;
    while (right < s.length()) {
        char r = s.charAt(right);
        chars[r]++;
        while (chars[r] > 1) {
            char l = s.charAt(left);
            chars[l]--;
            left++;
        }
        res = Math.max(res, right - left + 1);
        right++;
    }
    return res;
}
    </code></pre>

    <h3>Q20: Merge two sorted linked lists and return it as a new sorted list.</h3>
    <p><strong>Explanation:</strong> Iterates through both lists, merging them into a new linked list.</p>
    <pre><code>
public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
    ListNode dummy = new ListNode(0);
    ListNode current = dummy;
    while (l1 != null && l2 != null) {
        if (l1.val < l2.val) {
            current.next = l1;
            l1 = l1.next;
        } else {
            current.next = l2;
            l2 = l2.next;
        }
        current = current.next;
    }
    current.next = (l1 != null) ? l1 : l2;
    return dummy.next;
}
    </code></pre>
	
	    <h3>Q21: Rotate an n x n 2D matrix by 90 degrees clockwise.</h3>
    <pre><code>
public void rotate(int[][] matrix) {
    int n = matrix.length;
    // Transpose the matrix
    for (int i = 0; i < n; i++) {
        for (int j = i; j < n; j++) {
            int temp = matrix[j][i];
            matrix[j][i] = matrix[i][j];
            matrix[i][j] = temp;
        }
    }
    // Reverse each row
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n / 2; j++) {
            int temp = matrix[i][j];
            matrix[i][j] = matrix[i][n - 1 - j];
            matrix[i][n - 1 - j] = temp;
        }
    }
}
    </code></pre>

    <h3>Q22: Given a non-negative integer num, repeatedly add all its digits until the result has only one digit.</h3>
    <pre><code>
public int addDigits(int num) {
    while (num >= 10) {
        int sum = 0;
        while (num > 0) {
            sum += num % 10;
            num /= 10;
        }
        num = sum;
    }
    return num;
}
    </code></pre>

    <h3>Q23: Given an integer, write a function to determine if it is a power of two.</h3>
    <pre><code>
public boolean isPowerOfTwo(int n) {
    return (n > 0) && ((n & (n - 1)) == 0);
}
    </code></pre>

    <h3>Q24: Move all zeroes in an array to the end while maintaining the order of non-zero elements.</h3>
    <pre><code>
public void moveZeroes(int[] nums) {
    int insertPos = 0;
    for (int num : nums) {
        if (num != 0) nums[insertPos++] = num;
    }
    while (insertPos < nums.length) {
        nums[insertPos++] = 0;
    }
}
    </code></pre>

    <h3>Q25: Find all the missing numbers in an array where elements range from 1 to n.</h3>
    <pre><code>
public List<Integer> findDisappearedNumbers(int[] nums) {
    List<Integer> result = new ArrayList<>();
    for (int i = 0; i < nums.length; i++) {
        int val = Math.abs(nums[i]) - 1;
        if (nums[val] > 0) {
            nums[val] = -nums[val];
        }
    }
    for (int i = 0; i < nums.length; i++) {
        if (nums[i] > 0) {
            result.add(i + 1);
        }
    }
    return result;
}
    </code></pre>
	
<h1 style="background-color: blue;">Common-Step-Stream-API-Coding-Level-I</h1>

<h3>Q1: Filter Even Numbers</h3>
    <p><strong>Problem:</strong> Given a list of integers, return a list containing only even numbers.</p>
    <pre><code>
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6);
List<Integer> evenNumbers = numbers.stream()
    .filter(n -> n % 2 == 0)
    .collect(Collectors.toList());
    </code></pre>
    <p><strong>Explanation:</strong> The filter method is used to apply a condition that keeps only even numbers. The collect method gathers the results into a new list.</p>

    <h3>Q2: Find Maximum</h3>
    <p><strong>Problem:</strong> Find the maximum value in a list of integers.</p>
    <pre><code>
Optional<Integer> max = numbers.stream()
    .max(Integer::compare);
    </code></pre>
    <p><strong>Explanation:</strong> The max method takes a comparator and returns the maximum element wrapped in an Optional.</p>

    <h3>Q3: Sum of Elements</h3>
    <p><strong>Problem:</strong> Calculate the sum of elements in a list of integers.</p>
    <pre><code>
int sum = numbers.stream()
    .mapToInt(Integer::intValue)
    .sum();
    </code></pre>
    <p><strong>Explanation:</strong> mapToInt converts the stream to an IntStream, which provides the sum method to get the total.</p>

    <h3>Q4: List of Names to Uppercase</h3>
    <p><strong>Problem:</strong> Convert all strings in a list to uppercase.</p>
    <pre><code>
List<String> names = Arrays.asList("Alice", "Bob", "Charlie");
List<String> upperNames = names.stream()
    .map(String::toUpperCase)
    .collect(Collectors.toList());
    </code></pre>
    <p><strong>Explanation:</strong> The map function applies String::toUpperCase to each element, transforming them to uppercase.</p>

    <h3>Q5: Sort List</h3>
    <p><strong>Problem:</strong> Sort a list of integers in ascending order.</p>
    <pre><code>
List<Integer> sortedNumbers = numbers.stream()
    .sorted()
    .collect(Collectors.toList());
    </code></pre>
    <p><strong>Explanation:</strong> The sorted method sorts the elements of the stream in natural order.</p>

    <h3>Q6: Count Elements</h3>
    <p><strong>Problem:</strong> Count the number of elements in a list that are greater than 5.</p>
    <pre><code>
long count = numbers.stream()
    .filter(n -> n > 5)
    .count();
    </code></pre>
    <p><strong>Explanation:</strong> The filter method removes elements that don't satisfy the condition, and count returns the number of elements remaining.</p>

    <h3>Q7: Get Distinct Elements</h3>
    <p><strong>Problem:</strong> Get a list of distinct elements from a list of integers.</p>
    <pre><code>
List<Integer> distinctNumbers = numbers.stream()
    .distinct()
    .collect(Collectors.toList());
    </code></pre>
    <p><strong>Explanation:</strong> The distinct method filters the stream to include only unique elements.</p>

<h3>Q8: Reduce to Sum</h3>
    <pre><code>
int total = numbers.stream()
    .reduce(0, Integer::sum);
    </code></pre>
    <p><strong>Explanation:</strong> The reduce method takes an identity (0 in this case) and an accumulator function (Integer::sum) to calculate the total.</p>

    <h3>Q9: Find Any</h3>
    <pre><code>
Optional<Integer> anyElement = numbers.stream()
    .findAny();
    </code></pre>
    <p><strong>Explanation:</strong> findAny potentially returns any element from the stream, wrapped in an Optional.</p>

    <h3>Q10: List First Names</h3>
    <pre><code>
List<String> fullNames = Arrays.asList("Alice Johnson", "Bob Harris", "Charlie Lou");
List<String> firstNames = fullNames.stream()
    .map(name -> name.split(" ")[0])
    .collect(Collectors.toList());
    </code></pre>
    <p><strong>Explanation:</strong> The map function splits each name string and selects the first part.</p>

    <h3>Q11: All Match</h3>
    <pre><code>
boolean allPositive = numbers.stream()
    .allMatch(n -> n > 0);
    </code></pre>
    <p><strong>Explanation:</strong> allMatch returns true if every element in the stream matches the given predicate.</p>

    <h3>Q12: None Match</h3>
    <pre><code>
boolean noneNegative = numbers.stream()
    .noneMatch(n -> n < 0);
    </code></pre>
    <p><strong>Explanation:</strong> noneMatch checks that no elements match the negative condition.</p>

    <h3>Q13: Find First</h3>
    <pre><code>
Optional<Integer> first = numbers.stream()
    .findFirst();
    </code></pre>
    <p><strong>Explanation:</strong> findFirst returns the first element of the stream, wrapped in an Optional.</p>

    <h3>Q14: FlatMap for Nested Lists</h3>
    <pre><code>
List<List<Integer>> nestedNumbers = Arrays.asList(Arrays.asList(1, 2), Arrays.asList(3, 4, 5));
List<Integer> flatList = nestedNumbers.stream()
    .flatMap(List::stream)
    .collect(Collectors.toList());
    </code></pre>
    <p><strong>Explanation:</strong> flatMap converts each element into its own stream and then merges them into a single stream.</p>

    <h3>Q15: Grouping Elements</h3>
    <pre><code>
Map<Integer, List<User>> usersByAge = users.stream()
    .collect(Collectors.groupingBy(User::getAge));
    </code></pre>
    <p><strong>Explanation:</strong> The groupingBy collector groups elements based on the age property, creating a map where each key is an age and each value is a list of users with that age.</p>

    <h3>Q16: Peek Elements</h3>
    <pre><code>
List<Integer> peekedAtNumbers = numbers.stream()
    .peek(System.out::println)
    .collect(Collectors.toList());
    </code></pre>
    <p><strong>Explanation:</strong> peek is used for debugging or performing actions without changing the stream. It prints each element before passing it along the stream.</p>

    <h3>Q17: Limit Stream</h3>
    <pre><code>
List<Integer> limited = numbers.stream()
    .limit(3)
    .collect(Collectors.toList());
    </code></pre>
    <p><strong>Explanation:</strong> limit truncates the stream to be no longer than the specified size.</p>
 <h3>Q18: Skip Elements</h3>
    <p><strong>Problem:</strong> Skip the first 2 elements of a list and return the rest.</p>
    <pre><code>
List<Integer> skipped = numbers.stream()
    .skip(2)
    .collect(Collectors.toList());
    </code></pre>
    <p><strong>Explanation:</strong> The skip method discards the first n elements of the stream.</p>

    <h3>Q19: Convert to Set</h3>
    <p><strong>Problem:</strong> Convert a list of integers to a set to remove duplicates.</p>
    <pre><code>
Set<Integer> uniqueNumbers = numbers.stream()
    .collect(Collectors.toSet());
    </code></pre>
    <p><strong>Explanation:</strong> Collecting the stream into a Set automatically removes duplicates.</p>

    <h3>Q20: Summarizing Statistics</h3>
    <p><strong>Problem:</strong> Get summary statistics for a list of integers.</p>
    <pre><code>
IntSummaryStatistics stats = numbers.stream()
    .mapToInt(Integer::intValue)
    .summaryStatistics();
    </code></pre>
    <p><strong>Explanation:</strong> summaryStatistics provides a summary (max, min, average, sum, count) for a stream of integers.</p>


<h1 style="background-color: blue;">Common-Step-Stream-API-Coding-Level-II</h1>

    <h3>Q1: Given a list of integers, find out all the even numbers that exist in the list using Stream functions.</h3>
    <p><strong>Explanation:</strong> This method filters the input list to include only even numbers and prints them.</p>
    <pre><code>
import java.util.*;
import java.util.stream.*;

public class EvenNumber {
    public static void main(String args[]) {
        List<Integer> list = Arrays.asList(10, 15, 8, 49, 25, 98, 32);
        list.stream()
            .filter(n -> n % 2 == 0)
            .forEach(System.out::println);
    }
}
    </code></pre>

    <h3>Q2: Given a list of integers, find out all the numbers starting with 1 using Stream functions.</h3>
    <p><strong>Explanation:</strong> This method converts numbers to strings, filters those starting with '1', and prints them.</p>
    <pre><code>
import java.util.*;
import java.util.stream.*;

public class NumberStartingWithOne {
    public static void main(String args[]) {
        List<Integer> myList = Arrays.asList(10, 15, 8, 49, 25, 98, 32);
        myList.stream()
              .map(s -> s + "")
              .filter(s -> s.startsWith("1"))
              .forEach(System.out::println);
    }
}
    </code></pre>

    <h3>Q3: How to find duplicate elements in a given integer list in Java using Stream functions?</h3>
    <p><strong>Explanation:</strong> This method filters elements that appear more than once and prints them.</p>
    <pre><code>
import java.util.*;
import java.util.stream.*;

public class DuplicateElements {
    public static void main(String args[]) {
        List<Integer> myList = Arrays.asList(10, 15, 8, 49, 25, 98, 98, 32, 15);
        Set<Integer> set = new HashSet<>();
        myList.stream()
              .filter(n -> !set.add(n))
              .forEach(System.out::println);
    }
}
    </code></pre>

    <h3>Q4: Given the list of integers, find the first element of the list using Stream functions.</h3>
    <p><strong>Explanation:</strong> This method retrieves the first element in the list using findFirst().</p>
    <pre><code>
import java.util.*;
import java.util.stream.*;

public class FindFirstElement {
    public static void main(String args[]) {
        List<Integer> myList = Arrays.asList(10, 15, 8, 49, 25, 98, 98, 32, 15);
        myList.stream()
              .findFirst()
              .ifPresent(System.out::println);
    }
}
    </code></pre>

    <h3>Q5: Given a list of integers, find the total number of elements present in the list using Stream functions.</h3>
    <p><strong>Explanation:</strong> This method counts the elements in the list.</p>
    <pre><code>
import java.util.*;
import java.util.stream.*;

public class CountElements {
    public static void main(String args[]) {
        List<Integer> myList = Arrays.asList(10, 15, 8, 49, 25, 98, 98, 32, 15);
        long count = myList.stream().count();
        System.out.println(count);
    }
}
    </code></pre>
	
	 <h3>Q6: Given a list of integers, find the maximum value element present in it using Stream functions.</h3>
    <p><strong>Explanation:</strong> The max function finds the highest value in the stream using Integer::compare. The result is obtained using get().</p>
    <pre><code>
import java.util.*;
import java.util.stream.*;

public class FindMaxElement {
    public static void main(String args[]) {
        List<Integer> myList = Arrays.asList(10, 15, 8, 49, 25, 98, 98, 32, 15);
        int max = myList.stream()
                        .max(Integer::compare)
                        .get();
        System.out.println(max);
    }
}
    </code></pre>

    <h3>Q7: Given a String, find the first non-repeated character in it using Stream functions.</h3>
    <p><strong>Explanation:</strong> The input string is converted into a character stream, mapped to lowercase, grouped by frequency, and then the first character with a count of 1 is returned.</p>
    <pre><code>
import java.util.*;
import java.util.stream.*;
import java.util.function.Function;

public class FirstNonRepeated {
    public static void main(String args[]) {
        String input = "Java articles are Awesome";
        Character result = input.chars()
                .mapToObj(s -> Character.toLowerCase((char) s))
                .collect(Collectors.groupingBy(Function.identity(), LinkedHashMap::new, Collectors.counting()))
                .entrySet()
                .stream()
                .filter(entry -> entry.getValue() == 1L)
                .map(Map.Entry::getKey)
                .findFirst()
                .orElse(null);
        System.out.println(result);
    }
}
    </code></pre>

    <h3>Q8: Given a String, find the first repeated character in it using Stream functions.</h3>
    <p><strong>Explanation:</strong> The input string is converted into a character stream, mapped to lowercase, grouped by frequency, and then the first character with a count greater than 1 is returned.</p>
    <pre><code>
import java.util.*;
import java.util.stream.*;
import java.util.function.Function;

public class FirstRepeated {
    public static void main(String args[]) {
        String input = "Java Articles are Awesome";
        Character result = input.chars()
                .mapToObj(s -> Character.toLowerCase((char) s))
                .collect(Collectors.groupingBy(Function.identity(), LinkedHashMap::new, Collectors.counting()))
                .entrySet()
                .stream()
                .filter(entry -> entry.getValue() > 1L)
                .map(Map.Entry::getKey)
                .findFirst()
                .orElse(null);
        System.out.println(result);
    }
}
    </code></pre>

    <h3>Q9: Given a list of integers, sort all the values present in it using Stream functions.</h3>
    <p><strong>Explanation:</strong> The sorted function sorts the stream in ascending order and prints the sorted values.</p>
    <pre><code>
import java.util.*;
import java.util.stream.*;

public class SortValues {
    public static void main(String args[]) {
        List<Integer> myList = Arrays.asList(10, 15, 8, 49, 25, 98, 98, 32, 15);
        myList.stream()
              .sorted()
              .forEach(System.out::println);
    }
}
    </code></pre>

    <h3>Q10: Given a list of integers, sort all the values present in it in descending order using Stream functions.</h3>
    <p><strong>Explanation:</strong> The sorted function with Collections.reverseOrder() sorts the stream in descending order and prints the sorted values.</p>
    <pre><code>
import java.util.*;
import java.util.stream.*;

public class SortDescending {
    public static void main(String args[]) {
        List<Integer> myList = Arrays.asList(10, 15, 8, 49, 25, 98, 98, 32, 15);
        myList.stream()
              .sorted(Collections.reverseOrder())
              .forEach(System.out::println);
    }
}
    </code></pre>
	
	  <h3>Q11: Given an integer array nums, return true if any value appears at least twice in the array, and return false if every element is distinct.</h3>
    <p><strong>Explanation:</strong> This method converts the array to a list and then a set. If the set size is smaller than the list, duplicates exist.</p>
    <pre><code>
public boolean containsDuplicate(int[] nums) {
    Set<Integer> set = new HashSet<>();
    return Arrays.stream(nums).anyMatch(num -> !set.add(num));
}
    </code></pre>

    <h3>Q12: How will you get the current date and time using Java 8 Date and Time API?</h3>
    <p><strong>Explanation:</strong> Uses Java 8 LocalDate, LocalTime, and LocalDateTime APIs to fetch and print the current date, time, and both.</p>
    <pre><code>
public class Java8 {
    public static void main(String[] args) {
        System.out.println("Current Local Date: " + java.time.LocalDate.now());
        System.out.println("Current Local Time: " + java.time.LocalTime.now());
        System.out.println("Current Local Date and Time: " + java.time.LocalDateTime.now());
    }
}
    </code></pre>

    <h3>Q13: Write a Java 8 program to concatenate two Streams.</h3>
    <p><strong>Explanation:</strong> Converts two lists into streams and then concatenates them using Stream.concat().</p>
    <pre><code>
public class Java8 {
    public static void main(String[] args) {
        List<String> list1 = Arrays.asList("Java", "8");
        List<String> list2 = Arrays.asList("explained", "through", "programs");
        Stream<String> concatStream = Stream.concat(list1.stream(), list2.stream());
        concatStream.forEach(str -> System.out.print(str + " "));
    }
}
    </code></pre>

    <h3>Q14: Java 8 program to perform cube on list elements and filter numbers greater than 50.</h3>
    <p><strong>Explanation:</strong> Maps each number to its cube and filters values greater than 50.</p>
    <pre><code>
public class Main {
    public static void main(String[] args) {
       List<Integer> integerList = Arrays.asList(4,5,6,7,1,2,3);
       integerList.stream()
                  .map(i -> i*i*i)
                  .filter(i -> i>50)
                  .forEach(System.out::println);
    }
}
    </code></pre>

    <h3>Q15: Write a Java 8 program to sort an array and then convert the sorted array into Stream.</h3>
    <p><strong>Explanation:</strong> Uses Arrays.parallelSort() for sorting and then converts the array into a Stream.</p>
    <pre><code>
public class Java8 {
    public static void main(String[] args) {
        int arr[] = { 99, 55, 203, 99, 4, 91 };
        Arrays.parallelSort(arr);
        Arrays.stream(arr).forEach(n -> System.out.print(n + " "));
    }
}
    </code></pre>

    <h3>Q16: How to use map to convert object into Uppercase in Java 8?</h3>
    <p><strong>Explanation:</strong> Uses the map function to convert all strings in a list to uppercase.</p>
    <pre><code>
public class Java8 {
    public static void main(String[] args) {
        List<String> names = Arrays.asList("aa", "bb", "cc", "dd");
        List<String> nameLst = names.stream()
                                    .map(String::toUpperCase)
                                    .collect(Collectors.toList());
        System.out.println(nameLst);
    }
}
    </code></pre>

    <h3>Q17: How to convert a List of objects into a Map by considering duplicated keys and store them in sorted order?</h3>
    <p><strong>Explanation:</strong> Converts a list of objects into a sorted map using Collectors.toMap().</p>
    <pre><code>
public class TestNotes {
    public static void main(String[] args) {
        List<Notes> noteLst = Arrays.asList(
            new Notes(1, "note1", 11),
            new Notes(2, "note2", 22),
            new Notes(3, "note3", 33),
            new Notes(4, "note4", 44),
            new Notes(5, "note5", 55),
            new Notes(6, "note4", 66)
        );
        Map<String, Long> notesRecords = noteLst.stream()
            .sorted(Comparator.comparingLong(Notes::getTagId).reversed())
            .collect(Collectors.toMap(
                Notes::getTagName, Notes::getTagId,
                (oldValue, newValue) -> oldValue,
                LinkedHashMap::new
            ));
        System.out.println("Notes : " + notesRecords);
    }
}
    </code></pre>

 <h3>Q18: How to count each element/word from the String ArrayList in Java 8?</h3>
    <pre><code>
public class TestNotes {
    public static void main(String[] args) {
        List<String> names = Arrays.asList("AA", "BB", "AA", "CC");
        Map<String, Long> namesCount = names.stream()
                .collect(Collectors.groupingBy(Function.identity(), Collectors.counting()));
        System.out.println(namesCount);
    }
}
    </code></pre>
    <p><strong>Output:</strong> {CC=1, BB=1, AA=2}</p>

    <h3>Q19: How to find only duplicate elements with their count from the String ArrayList in Java 8?</h3>
    <pre><code>
public class TestNotes {
    public static void main(String[] args) {
        List<String> names = Arrays.asList("AA", "BB", "AA", "CC");
        Map<String, Long> namesCount = names.stream()
                .collect(Collectors.groupingBy(Function.identity(), Collectors.counting()))
                .entrySet().stream()
                .filter(entry -> entry.getValue() > 1)
                .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));
        System.out.println(namesCount);
    }
}
    </code></pre>
    <p><strong>Output:</strong> {AA=2}</p>

    <h3>Q20: How to check if a list is empty in Java 8 using Optional?</h3>
    <pre><code>
Optional.ofNullable(noteLst)
        .orElseGet(Collections::emptyList)
        .stream()
        .filter(Objects::nonNull)
        .map(Notes::getTagName)
        .forEach(System.out::println);
    </code></pre>

    <h3>Q21: Write a Program to find the Maximum element in an array.</h3>
    <pre><code>
public static int findMaxElement(int[] arr) {
    return Arrays.stream(arr).max().getAsInt();
}
    </code></pre>
    <p><strong>Input:</strong> 12, 19, 20, 88, 00, 9</p>
    <p><strong>Output:</strong> 88</p>

    <h3>Q22: Write a program to print the count of each character in a String.</h3>
    <pre><code>
public static void findCountOfChars(String s) {
    Map<String, Long> map = Arrays.stream(s.split(""))
            .map(String::toLowerCase)
            .collect(Collectors.groupingBy(Function.identity(), Collectors.counting()));
    System.out.println(map);
}
    </code></pre>
    <p><strong>Input:</strong> "string data to count each character"</p>
    <p><strong>Output:</strong> {s=1, t=5, r=3, i=1, n=2, g=1,  =5, d=1, a=5, o=2, c=4, u=1, e=2, h=2}</p>


</body>
</html>
