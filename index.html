<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Java</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; line-height: 1.6; background-color: #f4f4f4; }
        h1 { color: #fff; text-align: center; background-color: #3498db; padding: 15px; border-radius: 8px; }
        .question { font-weight: bold; margin-top: 20px; color: #000; background-color: yellow; padding: 10px; border-radius: 5px; }
        p { background: white; padding: 10px; border-radius: 5px; color: green; font-weight: bold; }
    </style>
</head>
<body>

    <div class="tab-buttons">
        <button onclick="showTab('java1')">Java 1</button>
        <button onclick="showTab('java2')">Java 2</button>
        <button onclick="showTab('java3')">Java 3</button>
    </div>
 <div class="qa-container">
        <h1 style="background-color: blue;">Paper 1</h1>
        
		<div id="java1" class="tab active">
        <div class="question">Q1. What is Java?</div>
        <div class="answer">Java is a high-level, class-based, object-oriented programming language that is designed to have as few implementation dependencies as possible. It is a widely used language for developing applications for web, mobile, and desktop platforms.</div>
        <div id="java1" class="tab active">
        <div class="question">Q2. What are the features of Java?</div>
        <div class="answer">Key features of Java include platform independence, object-orientation, security, robustness, simplicity, multithreading support, and garbage collection.</div>
        
        <div class="question">Q3. What is JVM and why is it important?</div>
        <div class="answer">JVM stands for Java Virtual Machine, which is the part of the Java Runtime Environment that executes Java byte code. It is important because it provides a platform-independent way of executing Java code.</div>
        
        <div class="question">Q4. What is the difference between JDK, JRE, and JVM?</div>
        <div class="answer">JDK (Java Development Kit) is the full software development kit required to develop Java applications, JRE (Java Runtime Environment) is a subset of JDK that is required to run Java applications, and JVM (Java Virtual Machine) is the component of JRE that executes Java bytecode.</div>
        
        <div class="question">Q5. What is the use of the public static void main(String[] args) method?</div>
        <div class="answer">This method is the entry point for any Java application. It is the method called by the JVM to run the program.</div>
        
        <div class="question">Q6. Explain the concept of Object-Oriented Programming in Java.</div>
        <div class="answer">Object-Oriented Programming (OOP) in Java is a programming paradigm based on the concept of "objects", which can contain data in the form of fields (attributes) and code in the form of procedures (methods). Java uses OOP principles including inheritance, encapsulation, polymorphism, and abstraction.</div>
        
        <div class="question">Q7. What is inheritance in Java?</div>
        <div class="answer">Inheritance is a fundamental OOP concept where one class can inherit fields and methods from another class. In Java, inheritance is achieved using the extends keyword.</div>
        
        <div class="question">Q8. What is polymorphism in Java?</div>
        <div class="answer">Polymorphism in Java is the ability of an object to take on many forms. It is typically achieved through method overriding and method overloading.</div>
        
        <div class="question">Q9. Explain encapsulation with an example in Java.</div>
        <div class="answer">Encapsulation in Java is the bundling of data (variables) and methods that operate on the data into a single unit, or class, and restricting access to some of the object's components. This is usually done by making fields private and providing public getter and setter methods.</div>
        
        <div class="question">Q10. What is an interface in Java?</div>
        <div class="answer">An interface in Java is a reference type, similar to a class, that can contain only constants, method signatures, default methods, static methods, and nested types. Interfaces cannot contain instance fields. The methods in interfaces are abstract by default.</div>
        
        <div class="question">Q11. Explain the concept of an abstract class.</div>
        <div class="answer">An abstract class in Java is a class that cannot be instantiated and may contain abstract methods, which do not have an implementation and must be implemented in subclasses.</div>
        
        <div class="question">Q12. What are constructors in Java?</div>
        <div class="answer">Constructors in Java are special methods used to initialize objects. The constructor is called when an object of a class is created and has the same name as the class.</div>
        
        <div class="question">Q13. What is method overloading?</div>
        <div class="answer">Method overloading is a feature in Java that allows a class to have more than one method having the same name, if their parameter lists are different. It is a way of implementing compile-time polymorphism.</div>
        
        <div class="question">Q14. What is method overriding?</div>
        <div class="answer">Method overriding, in Java, is a feature that allows a subclass to provide a specific implementation of a method that is already provided by one of its super-classes or parent classes.</div>
        
        <div class="question">Q15. What is a package in Java?</div>
        <div class="answer">In Java, a package is a namespace that organizes a set of related classes and interfaces. Conceptually, packages are similar to different folders on your computer.</div>
        
        <div class="question">Q16. Explain the final keyword in Java.</div>
        <div class="answer">The final keyword in Java can be used to mark a variable as constant (not changeable), a method as not overrideable, or a class as not inheritable.</div>
        
        <div class="question">Q17. What are Java Exceptions?</div>
        <div class="answer">Exceptions in Java are events that disrupt the normal flow of the program. They are objects that wrap an error event that occurred within a method and are either caught or propagated further up the calling chain.</div>
        
        <div class="question">Q18. What is the difference between checked and unchecked exceptions?</div>
        <div class="answer">Checked exceptions are exceptions that are checked at compile-time, meaning that the code must handle or declare them. Unchecked exceptions are checked at runtime, meaning they can be thrown without being caught or declared.</div>
        
        <div class="question">Q19. What is the static keyword used for in Java?</div>
        <div class="answer">The static keyword in Java is used to indicate that a particular field, method, or block of code belongs to the class, rather than instances of the class. Static members are shared among all instances of a class.</div>
        
        <div class="question">Q20. What is a thread in Java?</div>
        <div class="answer">A thread in Java is a lightweight process that allows concurrent execution of code. Java provides built-in support for multithreading using the Thread class and Runnable interface.</div>
        
    
    <div class="question">Q21. What is the difference between == and .equals()?</div>
        <div class="answer">The == operator compares memory addresses, while the .equals() method checks for value equality in objects.</div>
        
        <div class="question">Q22. What is garbage collection in Java?</div>
        <div class="answer">Garbage collection in Java is an automatic memory management process that removes unused objects to free up memory. The JVM performs garbage collection to avoid memory leaks.</div>
        
        <div class="question">Q23. What is the Collections Framework?</div>
        <div class="answer">The Collections Framework in Java is a set of classes and interfaces that provide data structures like Lists, Sets, and Maps for handling collections of objects.</div>
        
        <div class="question">Q24. Explain the synchronized keyword.</div>
        <div class="answer">The synchronized keyword in Java is used to control access to critical sections of code by multiple threads, preventing race conditions.</div>
        
        <div class="question">Q25. What are generics in Java?</div>
        <div class="answer">Generics allow the creation of classes, interfaces, and methods with type parameters to provide type safety and code reusability.</div>
        
        <div class="question">Q26. What is the this keyword in Java?</div>
        <div class="answer">The this keyword in Java refers to the current instance of a class and is used to access instance variables and methods.</div>
        
        <div class="question">Q27. What is an Enum in Java?</div>
        <div class="answer">An Enum in Java is a special data type that defines a fixed set of constants.</div>
        
        <div class="question">Q28. What is multithreading in Java?</div>
        <div class="answer">Multithreading in Java allows multiple threads to run simultaneously, improving efficiency and performance.</div>
        
        <div class="question">Q29. Explain the volatile keyword in Java.</div>
        <div class="answer">The volatile keyword ensures that a variable is read directly from memory rather than from a thread's local cache, ensuring visibility across multiple threads.</div>
        
        <div class="question">Q30. Explain volatile keyword in Java.</div>
        <div class="answer">The volatile keyword in Java is used to indicate that a variable's value will be modified by different threads. Declaring a variable volatile ensures that its value is read from the main memory and not from the thread's cache memory.</div>
        


    <h1 style="background-color: blue;">Paper 2</h1>


        <h2>Java Architecture and Memory Management</h2>
        
      <div class="question">Q1. Is Java 100% object-oriented programming language?</div>
        <div class="answer">No, Java is not considered 100% object-oriented because it uses primitive types (like int, char, etc.) that are not objects.</div>
        
        <div class="question">Q2. What are the advantages of Java being partially object-oriented?</div>
        <div class="answer">
            <ul>
                <li>Using simple, non-object types like integers and booleans helps Java run faster and use less memory.</li>
                <li>The mix of features allows Java to work well with other technologies and systems, which might not be fully object-oriented.</li>
            </ul>
        </div>
        
        <div class="question">Q3. What is the use of object-oriented programming languages in enterprise projects?</div>
        <div class="answer">Object-oriented programming (OOP) is used in big projects to make coding easier to handle. It helps organize code better, makes it easier to update and scale, and lets programmers reuse code, saving time and effort.</div>
        
        <div class="question">Q4. Explain public static void main(String args[])?</div>
        <div class="answer">In Java, public static void main(String[] args) is the entry point of any standalone Java application.</div>
        
        <div class="question">Q5. What will happen if we don’t declare the main method as static?</div>
        <div class="answer">If the main method is not declared as static, the JVM will not be able to launch the application.</div>
        
        <div class="question">Q6. Can we override the main method?</div>
        <div class="answer">No, the main method cannot be overridden because it is a static method.</div>
        
        <div class="question">Q7. Can JVM execute our overloaded main method?</div>
        <div class="answer">No, JVM only calls the original main method and does not execute overloaded versions.</div>
        
        <div class="question">Q8. What’s the difference between primitive and non-primitive data types?</div>
        <div class="answer">Primitive data types are predefined and not objects, while non-primitive data types are objects and can call methods.</div>
        
        <div class="question">Q9. Can primitive data types be NULL?</div>
        <div class="answer">No, primitive data types cannot be null. They have default values.</div>
        
        <div class="question">Q10. Can we declare pointers in Java?</div>
        <div class="answer">No, Java does not support pointers for security reasons.</div>
        
        <div class="question">Q11. What are wrapper classes?</div>
        <div class="answer">Wrapper classes allow primitive data types to be treated as objects. Examples include Integer, Double, etc.</div>
        
        <div class="question">Q12. Why do we need wrapper classes?</div>
        <div class="answer">
            <ul>
                <li>They provide methods like valueOf() and parseInt().</li>
                <li>They enable autoboxing and unboxing.</li>
            </ul>
        </div>
        
        <div class="question">Q13. Why do we use wrapper classes in collections?</div>
        <div class="answer">Java collections can only store objects, so wrapper classes allow primitives to be stored in collections.</div>
        
        <div class="question">Q14. What is the difference between unboxing and autoboxing?</div>
        <div class="answer">Autoboxing converts a primitive to a wrapper object, while unboxing converts a wrapper object back to a primitive.</div>
        
        <div class="question">Q15. Can autoboxing cause unexpected behavior?</div>
        <div class="answer">Yes, comparing two Integer objects using == might give unexpected results for values outside the range of -128 to 127.</div>
        
        <div class="question">Q16. Can autoboxing and unboxing cause a NullPointerException?</div>
        <div class="answer">Yes, if a null object is unboxed, a NullPointerException will occur.</div>
        
        <div class="question">Q17. What is the role of try, catch, and finally in exception handling?</div>
        <div class="answer">The try block contains risky code, catch handles exceptions, and finally executes cleanup code.</div>
        
        <div class="question">Q18. What happens if return is used inside try or catch?</div>
        <div class="answer">The finally block still executes before returning the value.</div>
        
        <div class="question">Q19. Can we use try with finally without a catch block?</div>
        <div class="answer">Yes, a try block can be used with finally without a catch block to ensure cleanup occurs.</div>
		 <div class="question">Q20. How does exception handling with try-catch-finally affect the performance of a Java application?</div>
        <div class="answer">Using try-catch-finally can affect performance slightly due to the overhead of managing exceptions but is generally minimal unless exceptions are thrown frequently.</div>

        <div class="question">Q21. Can you tell me a condition where the finally block will not be executed?</div>
        <div class="answer">The finally block will not execute if the JVM exits via System.exit() during try or catch execution.</div>

        <div class="question">Q22. Can we write multiple finally blocks in Java?</div>
        <div class="answer">No, each try can only have one finally block. Multiple finally blocks are not allowed within a single try-catch-finally structure.</div>

        <div class="question">Q23. What is an exception and the differences between checked and unchecked exceptions?</div>
        <div class="answer">An exception is an unwanted event that occurs during the execution of a program and disrupts the flow. Checked exceptions must be declared or handled (e.g., IOException), whereas unchecked exceptions do not need to be declared or caught (e.g., NullPointerException).</div>

        <div class="question">Q24. How would you handle multiple exceptions in a single catch block?</div>
        <div class="answer">Use a single catch block for multiple exceptions by separating them with a pipe (|), e.g., catch (IOException | SQLException e), to handle both exceptions with the same logic.</div>

        <div class="question">Q25. What is the difference between a Throwable and an Exception in Java?</div>
        <div class="answer">Throwable is the superclass for all errors and exceptions. Exception is a subclass of Throwable representing recoverable conditions, while Error (another subclass) represents serious issues the application should not attempt to recover from.</div>

        <div class="question">Q26. Discuss the difference between finalize() and finally. Under what circumstances might finalize() not get called in a Java application?</div>
        <div class="answer">finalize() is called by the garbage collector before an object is destroyed, while finally is used in a try-catch block to execute code regardless of exceptions. finalize() may not get called if the garbage collector doesn't run or the JVM shuts down.</div>

        <div class="question">Q27. What is the string pool?</div>
        <div class="answer">A Java String Pool is a place in heap memory where all the strings defined in the program are stored. Whenever a new string object is created, the JVM checks for its presence in the String pool. If the String is available in the pool, the same object reference is shared; otherwise, a new object is created.</div>

        <div class="question">Q28. Are there any scenarios where using the string pool might not be beneficial?</div>
        <div class="answer">It will not be beneficial when there are a lot of unique strings because it will be complex to check each string.</div>

        <div class="question">Q29. Can you please tell me about String and StringBuffer?</div>
        <div class="answer">String in Java is immutable, meaning once created, its value cannot be changed. StringBuffer is mutable, allowing for modification of its contents, and is thread-safe, making it suitable for use in multithreaded environments where strings need to be altered.</div>

        <div class="question">Q30. How does StringBuilder differ from StringBuffer, and when should each be used?</div>
        <div class="answer">StringBuilder is similar to StringBuffer but is not thread-safe, making it faster for single-threaded scenarios.</div>

        <div class="question">Q31. Give a scenario where StringBuffer is better than String.</div>
        <div class="answer">A scenario where StringBuffer is more appropriate than String is in a multi-threaded server application where multiple threads modify a shared string, such as constructing a complex log entry concurrently from different threads.</div>

        <div class="question">Q32. What is the difference between a String literal and a String object?</div>
        <div class="answer">A String literal is stored in the String pool for reusability. A String object, created using new String(), is stored in the heap, even if it has the same value as a literal.</div>

        <div class="question">Q33. Why is String immutable?</div>
        <div class="answer">String is immutable to improve security, caching, and performance by ensuring that its value cannot be changed once created.</div>

        <div class="question">Q34. What are the packages in Java?</div>
        <div class="answer">In Java, packages are namespaces that organize classes and interfaces into groups, preventing naming conflicts and managing access control. They provide a structured way to manage Java code, allowing related classes to be grouped together logically.</div>

        <div class="question">Q35. Why are packages used?</div>
        <div class="answer">
            1. They help in organizing code.<br>
            2. Packages prevent naming conflicts by providing a unique namespace.<br>
            3. Packages support modularity by allowing developers to separate the program.<br>
            4. Organizing classes into packages makes it easier to locate related classes.</div>


<h2>Object Oriented Programming Concepts</h2>
<div class="question">Q1. What are access modifiers in Java?</div>
        <div class="answer">Java uses public, protected, default (no modifier), and private to control access to classes, methods, and fields, ensuring appropriate visibility and encapsulation.</div>
        
        <div class="question">Q2. Can you provide examples of when to use each type of access modifier?</div>
        <div class="answer">
            1. <b>Public:</b> Used when members should be accessible from any other class.<br>
            2. <b>Protected:</b> Ideal for members that should be accessible to subclasses and classes within the same package.<br>
            3. <b>Default:</b> Use when members should be accessible only within the same package.<br>
            4. <b>Private:</b> Best for members intended only for use within their own class.
        </div>
        
        <div class="question">Q3. Why do we use getters and setters when we can make fields public and set/get directly?</div>
        <div class="answer">Using getters and setters instead of public variables allows us to control how values are set and accessed, add validation, and keep the ability to change how data is stored without affecting other parts of your program.</div>
        
        <div class="question">Q4. Can a top-level class be private or protected in Java?</div>
        <div class="answer">No, a top-level class cannot be private or protected because it restricts access, making it unusable from any other classes, contrary to the purpose of a top-level class.</div>
        
        <div class="question">Q5. Explain the concepts of classes and objects in Java.</div>
        <div class="answer">Classes are blueprints for objects in Java, defining the state and behavior that the objects of the class can have. Objects are instances of classes, representing entities with states and behaviors defined by their class.</div>
        
        <div class="question">Q6. What are the ways to create an object?</div>
        <div class="answer">
            1. Using the <b>new</b> Keyword, example: <code>MyClass object = new MyClass();</code><br>
            2. Using <b>Class Factory Methods</b>, example: <code>Calendar calendar = Calendar.getInstance();</code><br>
            3. Using the <b>clone()</b> method.
        </div>
        
        <div class="question">Q7. Can a class in Java be without any methods or fields?</div>
        <div class="answer">Yes, a class in Java can be declared without any methods or fields. Such a class can still be used to create objects, although these objects would have no specific behavior or state.</div>
        
        <div class="question">Q8. What are the methods available in the Object class, and how are they used?</div>
        <div class="answer">The key methods are <code>equals()</code>, <code>hashCode()</code>, <code>toString()</code>, <code>clone()</code>, <code>finalize()</code>, <code>wait()</code>, <code>notify()</code>, and <code>notifyAll()</code>. These provide basic operations like equality checks, memory management, and thread coordination.</div>
        
        <div class="question">Q9. What are anonymous classes and their advantages?</div>
        <div class="answer">Anonymous classes in Java are classes without a name, defined and instantiated in one place. They are useful when you need to create a subclass or implement an interface for a one-time use. The advantages include reduced boilerplate code, encapsulation of specific functionality, and the ability to override methods on the fly.</div>
        
        <div class="question">Q10. What is a Singleton Class?</div>
        <div class="answer">A singleton class in Java is a special class that can have only one instance (or object) at any time. It's useful when we want to make sure there's just one shared resource, like a configuration setting or a connection to a database.</div>
        
        <div class="question">Q11. How can we create a Singleton class?</div>
        <div class="answer">To create a singleton class, make the constructor private, create a private static instance of the class, and provide a static method to return the instance.</div>
        
        <div class="question">Q12. Are singleton classes thread-safe?</div>
        <div class="answer">Singleton classes are not thread-safe by default. If multiple threads try to create an instance at the same time, it could result in multiple instances. To prevent this, we can synchronize the method that creates the instance or use a static initializer.</div>
        
        <div class="question">Q13. What is a constructor in Java?</div>
        <div class="answer">A constructor in Java is a special method used to initialize new objects. It has the same name as the class and may take arguments to set initial values for the object's attributes.</div>
        
        <div class="question">Q14. Can we use a private constructor?</div>
        <div class="answer">Yes, we can use private constructors in Java. They are mostly used in classes that provide static methods or contain only static fields. A common use is in the Singleton design pattern.</div>
        
        <div class="question">Q15. Can a constructor be overloaded?</div>
        <div class="answer">Yes, you can have multiple constructors in a Java class, each with a different set of parameters. This lets you create objects in various ways depending on what information you have at the time.</div>
        
        <div class="question">Q16. What does immutability mean in Java?</div>
        <div class="answer">Immutability in Java means that once an object's state is created, it cannot be changed.</div>
        
        <div class="question">Q17. Why are immutable objects useful for concurrent programming?</div>
        <div class="answer">Immutable objects are useful in concurrent programming because they can be shared between threads without needing synchronization.</div>
        
        <div class="question">Q18. What are immutable classes?</div>
        <div class="answer">Immutable classes in Java are classes whose objects cannot be modified after they are created. This means all their fields are final and set only once, typically through the constructor.</div>
        
        <div class="question">Q19. How can we create an immutable class?</div>
        <div class="answer">
            1. Declare the class as <b>final</b> so it can't be extended.<br>
            2. Make all of the fields <b>final</b> and <b>private</b> so that direct access is not allowed.<br>
            3. Don’t provide setter methods for variables.<br>
            4. Initialize all fields using a constructor.
        </div>
        
        <div class="question">Q20. What does Java's inheritance mean?</div>
        <div class="answer">Inheritance in Java means a class can use the features of another class. This helps to reuse code and make things simpler.</div>
     <div class="question">Q21. Can a class extend on its own?</div>
        <div class="answer">No, a class in Java cannot extend itself. If it tries, it will cause an error.</div>

        <div class="question">Q22. Why multiple inheritance is not possible in Java?</div>
        <div class="answer">Java avoids using multiple inheritance because it can make things complicated, such as when two parent classes have methods that conflict.</div>

        <div class="question">Q23. What is the difference between inheritance and composition?</div>
        <div class="answer">Inheritance is when one class gets its features from another class. Composition is when a class is made using parts from other classes, which can be more flexible.</div>

        <div class="question">Q24. Discuss the principle of "composition over inheritance". Provide an example where this principle should be applied in Java application design.</div>
        <div class="answer">"Composition over inheritance" means using objects within other objects (composition) instead of inheriting from a parent class. It’s applied when classes have a "has-a" relationship. For example, a Car class can have an Engine class as a field rather than inheriting from an Engine.</div>

        <div class="question">Q25. What is the difference between association, aggregation, and composition in Java?</div>
        <div class="answer">Association is a general relationship between two classes. Aggregation is a weak association (has-a) where the child can exist independently of the parent. Composition is a strong association where the child cannot exist without the parent.</div>

        <div class="question">Q26. Explain the IS-A (inheritance) and Has-A (composition) relationships in Java.</div>
        <div class="answer">IS-A refers to inheritance, where a subclass is a type of the superclass. Has-A refers to composition, where a class contains references to other classes as fields.</div>

        <div class="question">Q27. What does polymorphism mean in Java?</div>
        <div class="answer">Polymorphism in Java means that the same piece of code can do different things depending on what kind of object it's dealing with. For example, if you have a method called "draw," it might make a circle for a Circle object and a square for a Square object.</div>

        <div class="question">Q28. How does method overloading relate to polymorphism?</div>
        <div class="answer">Method overloading is using the same method name with different inputs in the same class. It's a simple way to use polymorphism when you're writing your code.</div>

        <div class="question">Q29. What is dynamic method dispatch in Java?</div>
        <div class="answer">Dynamic method dispatch is a way Java decides which method to use at runtime when methods are overridden in subclasses. It ensures the correct method is used based on the type of object.</div>

        <div class="question">Q30. Can constructors be polymorphic?</div>
        <div class="answer">No, constructors cannot be polymorphic. We can have many constructors in a class with different inputs, but they don’t behave differently based on the object type like methods do.</div>
   <div class="question">Q31. What does abstraction mean in Java?</div>
        <div class="answer">Abstraction in Java means focusing on what needs to be done, not how to do it. You create a kind of blueprint that tells other parts of the program what actions they can perform without explaining the details.</div>
        
        <div class="question">Q32. Can you provide examples of where abstraction is effectively used in Java libraries?</div>
        <div class="answer">Java uses abstraction in its collection tools. For example, when you use a List, you don't need to know how it stores data, whether as an ArrayList or a LinkedList.</div>
        
        <div class="question">Q33. What happens if a class includes an abstract method?</div>
        <div class="answer">A class with an abstract method must itself be abstract. We can't create objects directly from an abstract class; it's meant to be a blueprint for other classes.</div>
        
        <div class="question">Q34. How does abstraction help in achieving loose coupling in software applications?</div>
        <div class="answer">Abstraction lets us hide complex details and only show what's necessary. This makes it easier to change parts of your program without affecting others, keeping different parts independent and easier to manage.</div>
        
        <div class="question">Q35. What is an interface in Java?</div>
        <div class="answer">An interface is like a blueprint for a class. It defines a set of methods that the class must implement, without specifying how these methods should work.</div>
        
        <div class="question">Q36. What is the difference between an interface and an abstract class in Java?</div>
        <div class="answer">An abstract class achieves partial abstraction (0 to 100%), whereas an interface achieves full abstraction. An abstract class can have abstract and non-abstract methods, whereas an interface can have only abstract methods. (Since Java 8, it can have default and static methods also.)</div>
        
        <div class="question">Q37. Can you provide examples of when to use an interface versus when to extend a class?</div>
        <div class="answer">Use an interface when we want to list the methods a class should have, without detailing how they work. Use class extension when we want a new class to inherit features and behaviors from an existing class and possibly modify them.</div>
        
        <div class="question">Q38. How do you use multiple inheritance in Java using interfaces?</div>
        <div class="answer">In Java, we can't inherit features from multiple classes directly, but we can use interfaces for a similar effect. A class can follow the guidelines of many interfaces at once, which lets it combine many sets of capabilities.</div>
        
        <div class="question">Q39. Can an interface in Java contain static methods, and if so, how can they be used?</div>
        <div class="answer">Yes, interfaces in Java can have static methods, which you can use without creating an instance of the class.</div>
        
        <div class="question">Q40. When would you use an interface, and when would you use an abstract class?</div>
        <div class="answer">Use an interface when you need multiple classes to share a contract without implementation. Use an abstract class when you need shared behavior (method implementations) along with method declarations.</div>
        
        <div class="question">Q41. Explain the difference between Comparable and Comparator interfaces. When would you use one over the other?</div>
        <div class="answer">Comparable is used for natural ordering and is implemented by the class itself, while Comparator is used for custom ordering and can be implemented externally. Use Comparable when objects have a single logical ordering; use Comparator when you need multiple ways to order objects.</div>
     <div class="question">Q41. What is a static method in an Interface, and how is it different from a default method in an interface?</div>
    <div class="answer">A static method in an interface belongs to the interface itself and cannot be overridden. A default method provides a default implementation for classes that implement the interface, and it can be overridden.</div>
    
    <div class="question">Q42. What is the diamond problem in Java and how does Java address it?</div>
    <div class="answer">The diamond problem occurs in multiple inheritance where a class inherits from two classes with a common ancestor. Java resolves this by not allowing multiple inheritance with classes, but interfaces can use default methods to avoid this issue.</div>
    
    <div class="question">Q43. How does the concept of default methods in interfaces help resolve the diamond problem?</div>
    <div class="answer">Default methods allow interfaces to provide method implementations, and in case of conflicts (multiple interfaces with the same default method), the implementing class must override the method, resolving ambiguity.</div>
    
    <div class="question">Q44. What does mean by encapsulation in java?</div>
    <div class="answer">Encapsulation in Java is like putting important information into a safe. We store data and the methods inside a class, and we control who can access or change the data by using specific methods.</div>
    
    <div class="question">Q45. How Encapsulation Enhances Software Security and Integrity:</div>
    <div class="answer">Encapsulation keeps important data hidden and safe. It only lets certain parts of our program use this data, which helps prevent mistakes and keeps the data secure from unwanted changes.</div>
    
    <div class="question">Q46. What is the concept of Serialization in Java?</div>
    <div class="answer">Serialization is the process of converting an object into a byte stream for storage or transmission. It allows objects to be saved and restored later or transferred over a network.</div>
    
    <div class="question">Q47. What is the purpose of the serialVersionUID in Java serialization?</div>
    <div class="answer">The serialVersionUID is a unique identifier for Serializable classes. It ensures that the serialized and deserialized objects are compatible by checking version consistency. If the serialVersionUID of the class doesn’t match during deserialization, an InvalidClassException is thrown, preventing incompatible class versions from being used.</div>
    
    <div class="question">Q48. What happens if the serialVersionUID of a class changes during deserialization?</div>
    <div class="answer">If the serialVersionUID changes between serialization and deserialization, the JVM considers the class as incompatible with the serialized object. This results in an InvalidClassException, as the runtime expects the version of the serialized class to match with the version defined in the deserialized class.</div>
    
    <div class="question">Q49. How can you prevent certain fields from being serialized in Java?</div>
    <div class="answer">You can prevent specific fields from being serialized by marking them with the transient keyword. When a field is declared as transient, it is excluded from the serialization process, meaning its value will not be saved when the object is serialized.</div>
    
    <div class="question">Q50. Can a class be serialized if one of its member fields is not serializable?</div>
    <div class="answer">A class can still be serialized even if one of its member fields is not serializable. However, you must mark the non-serializable field as transient. If the field is not transient and is not serializable, attempting to serialize the object will result in a NotSerializableException.</div>
    
    <div class="question">Q51. What is the difference between writeObject() and readObject() methods in Java serialization?</div>
    <div class="answer">The writeObject() and readObject() methods allow customization of the serialization and deserialization processes. writeObject() is used to customize how an object is serialized, while readObject() customizes how it is deserialized. These methods can be overridden to handle complex scenarios, such as serializing transient fields or managing class versioning.</div>
    
    <div class="question">Q52. Is it possible to serialize static fields in Java? Why or why not?</div>
    <div class="answer">No, static fields are not serialized in Java because they belong to the class, not to individual instances. Serialization is intended to capture the state of an object, and static fields are part of the class's state, not the object's state.</div>
    
    <div class="question">Q53. How do you serialize an object with circular references in Java?</div>
    <div class="answer">Java handles circular references during serialization by keeping track of references that have already been serialized. When the same object reference appears again, Java writes a reference to the already serialized object rather than serializing it again. This prevents infinite recursion and maintains the object graph structure.</div>
    
    <div class="question">Q54. What is method overloading in Java?</div>
    <div class="answer">Method overloading allows multiple methods in the same class to have the same name but different parameters. It provides flexibility by enabling multiple ways to call a method with different arguments.</div>
    
    <div class="question">Q55. How does the Java compiler determine which overloaded method to call?</div>
    <div class="answer">When we call an overloaded method, the Java compiler looks at the number and type of arguments provided and picks the method that matches these arguments best.</div>
    
    <div class="question">Q56. Is it possible to overload methods that differ only by their return type in Java?</div>
    <div class="answer">In Java, we cannot overload methods just by changing their return type. The methods must differ by their parameters for overloading to be valid.</div>
    
    <div class="question">Q57. What are the rules for method overloading in Java?</div>
    <div class="answer">The parameters must differ in how many there are, what type they are, or the order they are in.</div>
    
    <div class="question">Q58. What is method overriding in Java?</div>
    <div class="answer">To override a method, the new method in the subclass must have the same name, return type, and parameters as the method in the parent class. Also, the new method should not be less accessible than the original.</div>
<div class="question">Q58. What is method overriding in Java?</div>
    <div class="answer">To override a method, the new method in the subclass must have the same name, return type, and parameters as the method in the parent class. Also, the new method should not be less accessible than the original.</div>
   
   <div class="question">Q59. What are the rules and conditions for method overriding in Java?</div>
    <div class="answer">In Java, method overriding occurs when a subclass has a method with the same name, return type, and parameters as one in its parent class. The method in the subclass replaces the one in the parent class when called.</div>
   
   <div class="question">Q60. How does the @Override annotation influence method overriding?</div>
    <div class="answer">The @Override annotation tells the compiler that the method is supposed to replace one from its superclass. It's useful because it helps find mistakes if the method does not actually override an existing method from the parent class.</div>
   
   <div class="question">Q61. What happens if a superclass method is overridden by more than one subclass in Java?</div>
    <div class="answer">If different subclasses override the same method from a superclass, each subclass will have its own version of that method.</div>
   
   <div class="question">Q62. What is 'this' and 'super' keyword in Java?</div>
    <div class="answer">'this' is used to refer current class's instance as well as static members. 'super' keyword is used to access methods of the parent class.</div>
   
   <div class="question">Q63. Can 'this' keyword be assigned a new value in Java?</div>
    <div class="answer">No, this keyword cannot be assigned a new value in Java. It is a read-only reference that always points to the current object.</div>
   
   <div class="question">Q64. What happens if you attempt to use the "super" keyword in a class that doesn't have a superclass?</div>
    <div class="answer">If we attempt to use the "super" keyword in a class that doesn't have a superclass, a compilation error occurs. The "super" keyword is only applicable within subclasses to refer to members of the superclass.</div>
   
   <div class="question">Q65. Can the this or super keyword be used in a static method?</div>
    <div class="answer">No, the this and super keyword cannot be used in static methods. Static methods belong to the class, not instances, and super refers to the superclass's object context, which does not exist in a static context.</div>
   
   <div class="question">Q66. How does 'super' play a role in polymorphism?</div>
    <div class="answer">In Java, the super keyword lets a subclass use methods from its parent class, helping it behave in different ways and that is nothing but a polymorphic behavior.</div>
   
   <div class="question">Q67. What is the static keyword in Java?</div>
    <div class="answer">The static keyword in Java is used to indicate that a particular member (variable or method) belongs to the class, rather than any instance of the class. This means that the static member can be accessed without creating an instance of the class.</div>
   
   <div class="question">Q68. Can a static block throw an exception?</div>
    <div class="answer">Yes, a static block can throw an exception, but if it does, the exception must be handled within the block itself or declared using a throws clause in the class.</div>
   
   <div class="question">Q69. Can we override static methods in Java?</div>
    <div class="answer">No, static methods cannot be overridden in Java because method overriding is based on dynamic binding at runtime and static methods are bound at compile time.</div>
   
   <div class="question">Q70. Is it possible to access non-static members from within a static method?</div>
    <div class="answer">No, it's not possible to access non-static members (instance variables or methods) directly from within a static method. This is because static methods belong to the class itself, not to any specific instance. To access non-static members, you need to create an instance of the class and use that object to reference the non-static members.</div>
	<div class="question">Q71. What is static block?</div>
    <div class="answer">To initialize static variables, the statements inside static block are executed only once, when the class is loaded in the memory.</div>
    
    <div class="question">Q72. Can we print something on console without main method in Java?</div>
    <div class="answer">Prior to Java 8, yes, we can print something without main method but it's not possible from Java 8 onwards.</div>
    
    <div class="question">Q73. What is final keyword in Java?</div>
    <div class="answer">The 'final' keyword is used to declare constants, making variables unchangeable once assigned, or to prevent method overriding or class inheritance.</div>
    
    <div class="question">Q74. What are some common use cases for using final variables in Java programming?</div>
    <div class="answer">Common use cases for using final variables in Java programming include defining constants, parameters passed to methods, and local variables in lambdas or anonymous inner classes.</div>
    
    <div class="question">Q75. How does the "final" keyword contribute to immutability and thread safety in Java?</div>
    <div class="answer">The "final" keyword contributes to immutability and thread safety in Java by ensuring that the value of a variable cannot be changed once assigned, preventing unintended modifications and potential concurrency issues.</div>
    
    <div class="question">Q76. Can you describe any performance considerations related to using final?</div>
    <div class="answer">The final keyword improves the performance by reducing call overhead.</div>
    
    <div class="question">Q77. What is a functional interface?</div>
    <div class="answer">Functional interfaces in Java are interfaces with just one abstract method. They are used to create lambda expressions, and instances of these interfaces can be created with lambdas, method references, or constructor references.</div>
    
    <div class="question">Q78. Can a functional interface extend another interface?</div>
    <div class="answer">No, as a functional interface allows only a single abstract method. However, a functional interface can inherit another interface if it contains only static and default methods.</div>
    
    <div class="question">Q79. Advantages of using a functional interface.</div>
    <div class="answer">Functional interfaces, which contain only one abstract method, are key to enabling functional programming in Java. They offer concise and readable code through lambda expressions and method references, improving code simplicity. Functional interfaces allow easy parallel processing, better abstraction, and reusability, especially in scenarios like streams and event handling, promoting a cleaner and more expressive programming style.</div>


<h2>Java 8 basics</h2>

 <div class="question">Q1. Can you tell me some new features that were introduced in Java 8?</div>
    <div class="answer">Lambda Expressions, Stream API, Method References, Default Methods, Optional Class, New Date-Time API are the new features that were introduced in Java 8.</div>

    <div class="question">Q2. Why optional class, lambda expressions, and stream API were introduced in Java 8?</div>
    <div class="answer">Optional class was introduced in Java 8 as a way to address the problem of null references. Lambda expressions were introduced in Java 8 to make it easier to write code for interfaces that have only one method, using a simpler and more direct style. The Stream API was introduced in Java 8 to help developers process collections of data in a more straightforward and efficient way, especially for bulk operations like filtering or sorting.</div>

    <div class="question">Q3. Difference between filter and map function of Stream API?</div>
    <div class="answer">filter() eliminates elements of a collection where the condition is not satisfied, whereas map() is used to perform an operation on all elements; hence, it returns all elements of the collection.</div>

    <div class="question">Q4. Can you tell me some new features that were introduced in Java 11?</div>
    <div class="answer">HTTP Client, Epsilon Garbage Collector, Z Garbage Collector, Local-Variable Syntax for Lambda Parameters are some of the new features. Additionally, methods like isBlank(), strip(), stripLeading(), stripTrailing(), and repeat() were introduced for strings.</div>

    <div class="question">Q5. Can you tell me some new features that were introduced in Java 17?</div>
    <div class="answer">Sealed Classes, Pattern Matching for switch, and the Foreign Function and Memory API are some examples.</div>

    <div class="question">Q6. Can you tell me some new features that were introduced in Java 21?</div>
    <div class="answer">Virtual Threads, Structured Concurrency, Scoped Values, Sequenced Collections, and Record Pattern are some examples.</div>

    <div class="question">Q7. Which is faster, traditional for loop or Streams?</div>
    <div class="answer">Traditional for loops are generally faster due to less overhead, but Streams provide better readability and are optimized for parallel processing in large datasets.</div>

    <div class="question">Q8. In which scenarios would you prefer traditional for loops and streams?</div>
    <div class="answer">Use traditional loops for simple, small datasets requiring maximum performance. Use Streams for more complex data transformations or when working with large datasets where readability, maintainability, and potential parallelism are prioritized.</div>

    <div class="question">Q9. Explain intermediate and terminal operations in Streams.</div>
    <div class="answer">Intermediate operations (e.g., filter(), map()) return another stream and are lazy (executed only when a terminal operation is called). Terminal operations (e.g., forEach(), collect()) trigger the actual processing of the stream and produce a result or side effect.</div>

    <div class="question">Q10. Differences in Interface from Java 7 to Java 8.</div>
    <div class="answer">In Java 7, interfaces could only have abstract methods. Java 8 introduced default and static methods, allowing interfaces to have method implementations.</div>

    <div class="question">Q11. Use of String.join(….) in Java 8?</div>
    <div class="answer">String.join() concatenates a sequence of strings with a specified delimiter, simplifying string joining operations.</div>

<h2>Java 8 advance</h2>

 <div class="question">Q1. What are the new features introduced in Java 8?</div>
    <div class="answer">Java 8 introduced several significant features that enhanced the language's capabilities and performance. Key additions include Lambda Expressions for concise and functional-style programming, the Stream API for efficient data processing, and the new Date and Time API for improved date handling. Java 8 also introduced default and static methods in interfaces, allowing more complex interface designs, and the Optional class to better handle null values. These features collectively made Java more flexible and powerful, especially for handling collections and concurrency.</div>

    <div class="question">Q2. What is a lambda expression in Java 8, and what are its benefits?</div>
    <div class="answer">Lambda expressions in Java 8 are a way to implement methods from functional interfaces (interfaces with a single abstract method) in a clear and concise manner, using an arrow syntax. The benefits of lambda expressions include reducing the amount of boilerplate code, enhancing readability, and making it easier to use functional programming patterns. They are particularly useful for simplifying code when using collections and APIs that support concurrency, such as the Stream API.</div>

    <div class="question">Q3. What is the difference between a Lambda Expression and an Anonymous Inner Class?</div>
    <div class="answer">Lambda expressions and anonymous inner classes in Java both enable you to implement methods without declaring a formal class, but they differ significantly in simplicity and functionality. Lambda expressions are more concise and focus on passing a single piece of functionality, typically to a single method in a functional interface. In contrast, anonymous inner classes are more verbose and can implement multiple methods from an interface or subclass. Lambda expressions also do not have their own scope, unlike anonymous inner classes, which can shadow variables from the enclosing class.</div>

    <div class="question">Q4. What is a Functional Interface in Java 8?</div>
    <div class="answer">In Java 8, a Functional Interface is an interface that contains only one abstract method. These interfaces are intended for use with lambda expressions, which provide the implementation of the abstract method. Functional Interfaces can include other default or static methods without affecting their status. The @FunctionalInterface annotation, although not required, can be used to indicate that an interface is intended to be a Functional Interface, helping to avoid accidental addition of abstract methods in the future.</div>

    <div class="question">Q5. What are some of the predefined functional interfaces in Java 8?</div>
    <div class="answer">Java 8 introduced several predefined functional interfaces to facilitate lambda expressions and method references. Key examples include Consumer, which accepts a single input and returns no result; Supplier, which provides a result without accepting any input; Function, which takes one argument and returns a result; Predicate, which takes one argument and returns a boolean; and BiFunction, which takes two arguments and returns a result. These interfaces streamline the creation of lambda expressions for common functional programming patterns.</div>

    <div class="question">Q6. What is the Streams API in Java 8? How does it work?</div>
    <div class="answer">The Streams API in Java 8 is a powerful tool for processing sequences of elements in a declarative way. It works by providing a high-level abstraction for performing operations like filtering, mapping, sorting, and more, on collections of objects without modifying the underlying data source. Streams can be sequential or parallel, allowing for efficient data processing. The API emphasizes readability and simplicity, using functional-style operations that leverage lambda expressions for concise and expressive coding.</div>

    <div class="question">Q7. Explain the difference between map() and flatMap() in Streams.</div>
    <div class="answer">In Java Streams, map() and flatMap() are both transformation functions but serve different purposes. map() takes a function and applies it to each element in the stream, returning a stream of the results—essentially transforming each element into a new form. Conversely, flatMap() also applies a function to elements, but each function result is expected to be a stream itself; flatMap() then "flattens" these multiple streams into a single stream. This is particularly useful for handling nested collections or arrays.</div>

    <div class="question">Q8. How can you filter a collection using Streams in Java 8?</div>
    <div class="answer">In Java 8, you can filter a collection using the Streams API by converting the collection to a stream, applying a filter() method, and then specifying a condition within the filter method. The filter() method takes a predicate, which is a functional interface representing a condition that each element of the stream must meet. Elements that satisfy the predicate are retained in the stream, while others are discarded. You can then collect these filtered elements into a new collection if needed.</div>

<div class="question">Q9. What are Default Methods in Java 8, and why were they introduced?</div>
    <div class="answer">Default methods in Java 8 are methods added to interfaces that include an implementation. They were introduced to enable new functionality in interfaces without breaking existing implementations of these interfaces. This feature allows Java to add enhancements to the standard libraries (like the Collections API) while ensuring backward compatibility with older versions. Default methods help evolve interfaces over time without disrupting the classes that implement these interfaces.</div>

    <div class="question">Q10. How are Static Methods in interfaces different from Default Methods in Java 8?</div>
    <div class="answer">In Java 8, static methods in interfaces allow the interface to define methods that can be called on the interface itself, not on instances of classes that implement the interface. This is similar to static methods in classes. Conversely, default methods are methods within an interface that have an implementation. They can be called on instances of classes that implement the interface, providing default behavior without requiring the implementing class to override the method. Static methods help in utility or helper functionality, while default methods aid in enhancing interfaces without breaking existing implementations.</div>

    <div class="question">Q11. What is Optional in Java 8, and how is it used?</div>
    <div class="answer">Optional in Java 8 is a container object used to represent the presence or absence of a value, effectively reducing the problems caused by null references (often termed the billion-dollar mistake). It provides a way to express optional values without using null. This approach helps prevent NullPointerExceptions when accessing values that might not exist. Optional is commonly used in situations where a method might return a meaningful value or no value at all, allowing developers to handle the absence of a value gracefully using methods like isPresent(), ifPresent(), and orElse().</div>

    <div class="question">Q12. How do you handle null values in Java 8 using Optional?</div>
    <div class="answer">In Java 8, Optional is used to handle null values gracefully. You can create an Optional object that may or may not contain a non-null value by using methods like Optional.ofNullable(). This method returns an Optional object that is either empty (if the value is null) or contains the value. You can then use methods like orElse() to provide a default value if the Optional is empty, or ifPresent() to execute a block of code only if a value is present. This approach helps avoid NullPointerException and makes your code cleaner and safer.</div>

    <div class="question">Q13. What is the difference between findFirst() and findAny() in Streams?</div>
    <div class="answer">In Java Streams, findFirst() and findAny() are terminal operations that return an Optional describing an element of the stream. findFirst() returns the first element in the stream according to the encounter order, which is particularly useful in sequential streams. On the other hand, findAny() can return any element from the stream and is more performance-efficient in parallel streams, as it allows more flexibility in which element is returned, potentially reducing the time spent on synchronous operations.</div>

    <div class="question">Q14. Explain the purpose of the Collectors class in Java 8.</div>
    <div class="answer">The Collectors class in Java 8 serves as a utility to help with common mutable reductions and collection operations on streams, like grouping elements, summarizing elements, or converting them into collections like Lists, Sets, or Maps. It provides a set of pre-defined static methods that can be used with the collect() method of the Stream API. This makes it easy to perform complex tasks like joining strings, averaging numbers, or categorizing items in a streamlined and efficient manner.</div>
 <div class="question">Q15. What is the significance of the forEach() method in Java 8?</div>
    <div class="answer">The forEach() method in Java 8 is significant for its ability to simplify iterations over collections, including those that are part of the Java Collections Framework or arrays. Implemented as a default method in the Iterable interface and as a terminal operation in the Stream API, forEach() allows you to execute a specific action on each element of a collection or stream. This method enhances readability and reduces boilerplate code associated with traditional for-loops, making operations more concise and expressive, especially when combined with lambda expressions.</div>
    
    <div class="question">Q16. How does Java 8 handle parallel processing with the Streams API?</div>
    <div class="answer">Java 8 enhances parallel processing capabilities through the Streams API, which allows for easy parallelization of operations on collections. By invoking the parallelStream() method on a collection, you can create a parallel stream that divides the data into multiple parts, which are processed concurrently across different threads. This leverages multicore processors effectively to improve performance for large data sets. The framework handles the decomposition and merging of data, simplifying parallel execution without the need for explicit thread management.</div>
    
    <div class="question">Q17. What is the purpose of the Predicate functional interface in Java 8?</div>
    <div class="answer">The Predicate functional interface in Java 8 is designed to represent a boolean-valued function of one argument. Its primary purpose is to evaluate a given predicate (a condition that returns true or false) on objects of a specific type. Predicates are often used for filtering or matching objects. For example, in the Streams API, the filter() method uses a Predicate to determine which elements should be included in the resulting stream based on whether they satisfy the predicate. This functionality is crucial for conditional operations in collection processing.</div>
    
    <div class="question">Q18. How do you create an infinite stream in Java 8?</div>
    <div class="answer">In Java 8, you can create an infinite stream using the Stream.iterate or Stream.generate methods. Stream.iterate repeatedly applies a given function to a seed value to produce an infinite sequence, for example, generating an infinite stream of natural numbers by successively adding one. Stream.generate takes a Supplier to provide new values and produces an infinite stream of those values. Both methods yield infinite streams that require limiting actions to prevent endless processing.</div>
    
    <div class="question">Q19. What is the Function interface in Java 8, and how is it used?</div>
    <div class="answer">The Function interface in Java 8 is a functional interface that represents a function that accepts one argument and produces a result. It is commonly used for transforming objects of one type into another, such as converting strings to integers or applying mathematical operations to numbers. The interface is generic, allowing for flexibility in specifying the types of the input and output. In the Streams API, the Function interface is often passed to the map() method to transform stream elements.</div>
    
    <div class="question">Q20. What are method references in Java 8, and how do they relate to Lambda Expressions?</div>
    <div class="answer">Method references in Java 8 are a shorthand notation of lambda expressions that refer directly to methods by their names. They serve as a clean and concise way to express instances where lambda expressions simply call existing methods. For example, instead of using a lambda like (x) -> System.out.println(x), you can use the method reference System.out::println. This syntax directly points to the println method, improving code clarity and reducing verbosity when interfacing with functional interfaces.</div>
    
    <div class="question">Q21. How can you sort a collection using Streams in Java 8?</div>
    <div class="answer">In Java 8, you can sort a collection using the Streams API by converting the collection into a stream, applying the sorted() method, and then collecting the results back into a collection. The sorted() method can be used without arguments to sort in natural order, or with a comparator if a specific sorting order is needed. Finally, you use the collect(Collectors.toList()) (or another appropriate collector) to gather the sorted elements back into a collection like a list or set. This method provides a fluent, functional approach to sorting data.</div>
    
    <div class="question">Q22. What is the use of reduce() in Java 8 Streams?</div>
    <div class="answer">The reduce() method in Java 8 Streams is used to combine all elements of the stream into a single result. This method takes a binary operator as a parameter, which is used to accumulate the elements of the stream. Reduce() is useful for performing operations like summing all numbers in a list, finding the maximum or minimum value, or accumulating elements into a single result. This method essentially reduces a stream of elements to one summary result based on the provided operation.</div>
  <div class="question">Q23. How does the filter() method work in Java 8?</div>
    <div class="answer">The filter() method in Java 8's Streams API is used to evaluate each element in a stream against a given predicate, which is a functional interface that defines a condition returning a boolean value. Elements that pass this condition (i.e., for which the predicate returns true) are included in the resulting stream, while those that do not pass are discarded. This method is particularly useful for extracting subsets of data from collections based on specific criteria.</div>
    
    <div class="question">Q24. What is the significance of Collectors.toList() in Java 8 Streams?</div>
    <div class="answer">In Java 8, Collectors.toList() is a collector used in the Stream API to gather stream elements into a new list. This method is typically used with the collect() terminal operation to accumulate the elements of a stream into a list after performing operations like filtering, mapping, or sorting. It simplifies the process of converting a stream back into a collection, making it highly useful for collecting processed data conveniently and efficiently into a commonly used data structure.</div>
    
    <div class="question">Q25. Can you explain how Stream.of() works in Java 8?</div>
    <div class="answer">In Java 8, Stream.of() is a static method used to create a stream from a set of individual objects. You can pass one or more objects to this method, and it will return a stream containing the elements you provided. This is particularly useful for quickly turning a few elements into a stream without needing to create a collection first. It's a convenient way to work with a fixed number of elements for stream operations like filtering, mapping, or collecting.</div>
    
    <div class="question">Q26. How is Java 8 backward-compatible with earlier versions of Java?</div>
    <div class="answer">Java 8 maintains backward compatibility with earlier versions by ensuring that existing interfaces can be expanded with new features—like lambda expressions, method references, and stream APIs— without breaking the implementations that depend on older versions. For example, the introduction of default methods in interfaces allows new methods to be added without requiring changes in the implementing classes. This design approach ensures that older Java applications can still run without modification in the newer Java 8 environment.</div>
    
    <div class="question">Q27. What is the difference between limit() and skip() in Java 8 Streams?</div>
    <div class="answer">In Java 8 Streams, limit() and skip() are two intermediate operations that manage the size of the stream. limit(n) is used to truncate the stream so that it contains no more than n elements, effectively limiting the number of items processed downstream. On the other hand, skip(n) discards the first n elements of the stream, allowing the stream to start processing from the element that follows. Together, these methods help in controlling stream flow for specific processing needs.</div>
    
    <div class="question">Q28. Explain how to convert a list to a map using Streams in Java 8.</div>
    <div class="answer">In Java 8, you can convert a list to a map using the Streams API by utilizing the collect(Collectors.toMap()) method. First, convert the list into a stream. Then, use toMap() where you specify functions for determining the keys and values for the map. For example, if you have a list of objects, you might use an attribute of the objects as the key and the objects themselves as values. This method effectively organizes elements of a list into a map based on defined criteria.</div>
    
    <div class="question">Q29. What is the difference between Stream.iterate() and Stream.generate()?</div>
    <div class="answer">Stream.iterate() and Stream.generate() in Java 8 are both methods for creating infinite streams, but they do so in different ways. Stream.iterate() takes a seed (initial value) and a function, applying the function repeatedly to generate a sequence (e.g., creating a stream of powers of two). Stream.generate(), on the other hand, uses a supplier to provide new values, which doesn't depend on the previous element. This makes Stream.generate() suitable for generating streams where each element is independent of the others.</div>
    
    <div class="question">Q30. How can you apply a custom comparator in a stream pipeline in Java 8?</div>
    <div class="answer">In Java 8, you can apply a custom comparator in a stream pipeline using the sorted() method. First, define your comparator, which dictates how the elements should be compared based on your custom criteria. Then, pass this comparator to the sorted() method within your stream pipeline. For example, if you're streaming a list of objects, you can sort them by a specific attribute using a comparator that compares that attribute. This method integrates seamlessly into the stream, allowing for flexible sorting within the pipeline.</div>
<div class="question">Q31. Can you explain why Java 8 introduced the concept of Default Methods in interfaces, and what problem does it solve?</div>
    <div class="answer">Java 8 introduced default methods in interfaces to enable interfaces to evolve while maintaining backward compatibility with older versions. Previously, adding a new method to an interface required all implementing classes to define that method, potentially breaking existing applications. Default methods allow new functionalities to be added to interfaces without obligating implementing classes to change. This helps in enhancing interfaces with new methods while ensuring that existing implementations do not fail.</div>

    <div class="question">Q32. Is it possible to use this and super in a Lambda expression? Explain why or why not.</div>
    <div class="answer">In Java, within lambda expressions, this and super keywords do not refer to the lambda expression itself but rather to the enclosing instance where the lambda is defined. This means this refers to the instance of the class where the lambda is created, and super refers to the superclass of this instance. Therefore, while you can use this and super in lambda expressions, they do not behave as they might be expected to within traditional methods or anonymous inner classes, where they refer directly to the current or parent class object respectively.</div>

    <div class="question">Q33. How can a Lambda expression access variables outside its scope? What is the concept behind it?</div>
    <div class="answer">Lambda expressions in Java can access variables outside their scope, specifically final or effectively final variables from their enclosing scope. An effectively final variable is one that is not modified after initialization. This restriction ensures that the lambda expression is state-consistent and can be safely called multiple times without side effects that could arise from modifying external variables. This capability allows lambda expressions to capture and use local variables in a functional-style programming approach, enhancing their utility and flexibility.</div>

    <div class="question">Q34. Can a Lambda expression throw an exception? How can you handle exceptions in a Lambda?</div>
    <div class="answer">Yes, lambda expressions in Java can throw exceptions, just like regular methods. However, if the functional interface the lambda is implementing does not declare an exception, any checked exceptions thrown within the lambda must either be caught or converted to unchecked exceptions. To handle exceptions directly within a lambda, you can use a try-catch block surrounding the code that might throw the exception. This approach allows the lambda to manage exceptions internally without affecting the external execution flow.</div>

    <div class="question">Q35. What is the difference between Optional.of() and Optional.ofNullable()?</div>
    <div class="answer">In Java, Optional.of() and Optional.ofNullable() are methods used to create Optional objects, but they handle null values differently. Optional.of(value) requires a non-null value and throws a NullPointerException if passed a null. This is suitable when you are certain the value is not null. In contrast, Optional.ofNullable(value) is safe for use with values that might be null. It returns an empty Optional if the value is null, thus avoiding any exceptions.</div>

    <div class="question">Q36. How does the internal working of Stream.sorted() differ when using natural ordering versus custom comparator?</div>
    <div class="answer">The Stream.sorted() method in Java sorts the elements of a stream either using natural ordering or a custom comparator. When using natural ordering, it assumes that the stream elements implement the Comparable interface and sorts them according to their compareTo method. With a custom comparator, you provide a Comparator object that defines a different sorting logic. This allows for flexibility in sorting based on attributes or rules that do not adhere to the natural order of the elements. Both methods internally use efficient sorting algorithms optimized for performance and stability.</div>

    <div class="question">Q37. Can you use Optional as a method parameter? Why should or shouldn’t you do this?</div>
    <div class="answer">Using Optional as a method parameter in Java is technically possible but generally discouraged. The primary purpose of Optional is to provide a more expressive alternative to null references and to enhance readability and safety in APIs by clearly indicating that a method might not return a value. Using Optional as a parameter complicates method signatures and usage, potentially obscuring intent and leading to less clean code. Instead, it's better to use Optional for return types where it clarifies that a method might not produce a value.</div>
	
 <div class="question">Q38. What will happen if you try to modify a local variable inside a Lambda expression?</div>
    <div class="answer">In Java, if you try to modify a local variable inside a lambda expression, you'll encounter a compile-time error. Local variables accessed from within a lambda must be final or effectively final—meaning once they are initialized, they cannot be modified. This restriction ensures that the lambda does not introduce side effects by altering the local environment, preserving thread safety and functional programming principles where functions do not modify the state outside their scope.</div>

    <div class="question">Q39. Can you use the synchronized keyword inside a Lambda expression?</div>
    <div class="answer">No, you cannot directly use the synchronized keyword inside the body of a lambda expression in Java. Lambda expressions are meant to be short, stateless, and concise blocks of code. They do not have an intrinsic lock object to synchronize on, unlike methods in a class. If synchronization is necessary within a lambda, you must handle it externally, such as synchronizing on an external object or using higher-level concurrency utilities provided by Java.</div>

    <div class="question">Q40. What is the difference between count(), sum(), and reduce() in Java 8 Streams?</div>
    <div class="answer">In Java 8 Streams, count(), sum(), and reduce() serve different purposes: count() simply returns the number of elements in the stream, useful for tallying items. sum(), available in specialized stream types like IntStream, LongStream, and DoubleStream, calculates the total of the elements. reduce(), on the other hand, is a more general method that combines all elements in the stream using a provided binary operator to produce a single result, allowing for more complex accumulations beyond just summing.</div>
	
<h2>Concurrency and multi-threading</h2>

	 <div class="question">Q1. What is a thread in Java and how can we create it?</div>
    <div class="answer">A thread in Java is a pathway of execution within a program. You can create a thread by extending the Thread class or implementing the Runnable interface.</div>

    <div class="question">Q2. Can you explain the lifecycle of a Java thread?</div>
    <div class="answer">A Java thread lifecycle includes states: New, Runnable, Blocked, Waiting, Timed Waiting, and Terminated.</div>

    <div class="question">Q3. How would you handle a scenario where two threads need to update the same data structure?</div>
    <div class="answer">Use synchronized blocks or methods to ensure that only one thread can access the data structure at a time, preventing concurrent modification issues.</div>

    <div class="question">Q4. Can we start a thread twice?</div>
    <div class="answer">No, a thread in Java cannot be started more than once. Attempting to restart a thread that has already run will throw an IllegalThreadStateException.</div>

    <div class="question">Q5. What is the difference between Thread class and Runnable interface in Java?</div>
    <div class="answer">The Thread class defines a thread of execution, whereas the Runnable interface should be implemented by any class whose instances are intended to be executed by a thread.</div>

    <div class="question">Q6. How can you ensure a method is thread-safe in Java?</div>
    <div class="answer">To ensure thread safety, use synchronization mechanisms like synchronized blocks, volatile variables, or concurrent data structures.</div>

    <div class="question">Q7. What are volatile variables?</div>
    <div class="answer">Volatile variables in Java are used to indicate that a variable's value will be modified by different threads, ensuring that the value read is always the latest written.</div>

    <div class="question">Q8. What is thread synchronization and why is it important?</div>
    <div class="answer">Thread synchronization controls the access of multiple threads to shared resources to prevent data inconsistency and ensure thread safety.</div>

    <div class="question">Q9. Can you describe a scenario where you would use wait() and notify() methods in thread communication?</div>
    <div class="answer">Use wait() and notify() for inter-thread communication, like when one thread needs to wait for another to complete a task before proceeding.</div>

    <div class="question">Q10. What challenges might you face with multithreaded programs in Java?</div>
    <div class="answer">In Java, multithreaded programming can lead to issues like deadlocks, race conditions, and resource contention, which complicate debugging and affect performance. Managing thread safety and synchronization efficiently is also a significant challenge.</div>

    <div class="question">Q11. What is the Java Memory Model (JMM) and how is it linked to threads?</div>
    <div class="answer">The Java Memory Model (JMM) defines the rules by which Java programs achieve consistency when reading and writing variables across multiple threads, ensuring all threads have a consistent view of memory. It governs how changes to variables are propagated and how synchronization constructs like volatile and synchronized affect visibility and ordering of operations.</div>

<h2>Concurrency and Multithreading Advance</h2>

<div class="question">Q1. How would you ensure that a shared resource is accessed safely by multiple threads?</div>
    <div class="answer">To ensure safe access to a shared resource by multiple threads in Java, you can use synchronization. This involves using the synchronized keyword to lock an object or a method while a thread is using it. Only one thread can hold the lock at a time, preventing other threads from accessing the locked code until the lock is released. This mechanism helps avoid conflicts and data corruption by ensuring that only one thread can modify the shared resource at any given time.</div>

    <div class="question">Q2. Explain the synchronized keyword in Java. How does it work?</div>
    <div class="answer">The synchronized keyword in Java is used to control access to a critical section of code by locking an object or method so that only one thread can execute it at a time. When a thread enters a synchronized block or method, it obtains a lock on the specified object or class, preventing other threads from entering any synchronized blocks or methods that lock the same object or class until the lock is released. This ensures that the shared data is accessed in a thread-safe manner.</div>

    <div class="question">Q3. What are the differences between using synchronized on a method versus on a block of code?</div>
    <div class="answer">Using synchronized on a method locks the entire method, so when a thread enters this method, no other thread can enter any synchronized method of that object until the lock is released. However, using synchronized on a block of code only locks that specific block. This allows finer control over which parts of the code need synchronization, potentially improving performance by reducing the scope of locking to just critical sections of the code.</div>

    <div class="question">Q4. What is the significance of the volatile keyword in Java concurrency?</div>
    <div class="answer">The volatile keyword in Java concurrency is crucial for ensuring visibility and preventing caching of variables across threads. When a variable is declared as volatile, it tells the JVM that every read or write to that variable should go directly to main memory, bypassing any intermediate caches. This ensures that changes made to a volatile variable by one thread are immediately visible to other threads, maintaining data consistency across threads without using synchronized blocks.</div>

    <div class="question">Q5. How does the introduction of Lambda expressions change the way Java handles concurrency?</div>
    <div class="answer">Lambda expressions in Java simplify the way concurrency is handled primarily by reducing the verbosity and complexity of anonymous classes, making code more readable and concise. They facilitate the use of functional programming techniques within Java, particularly in dealing with concurrency frameworks like Streams and CompletableFuture, which rely heavily on passing behaviors (functions) as arguments. Lambdas enable cleaner and more maintainable concurrent processing by allowing developers to focus on the logic rather than boilerplate code.</div>

    <div class="question">Q6. Explain the Java concurrency model.</div>
    <div class="answer">The Java concurrency model is built around threads, which are units of execution within a process. Java provides a rich set of tools and APIs, like Thread class, Runnable interface, and concurrency utilities in the java.util.concurrent package, to manage and synchronize these threads. This model allows multiple threads to run in parallel, enhancing performance especially in multi-core processors. Synchronization and coordination between threads are achieved through mechanisms like locks, synchronized blocks/methods, and concurrent data structures, ensuring safe communication between threads.</div>

    <div class="question">Q7. What are the challenges associated with Java’s thread management?</div>
    <div class="answer">Java's thread management presents several challenges, including the complexity of ensuring thread safety, which requires careful synchronization to avoid issues like data corruption and deadlocks. Managing thread life cycles and resource allocation efficiently can also be difficult, as threads consume system resources. Overuse of threading can lead to high CPU usage and slower application performance. Additionally, debugging multithreaded applications is often more complex due to the unpredictable nature of thread execution.</div>

    <div class="question">Q8. Can volatile variables be used as a replacement for synchronization?</div>
    <div class="answer">Volatile variables cannot fully replace synchronization in Java. While they ensure that the value of a variable is consistently updated across all threads (ensuring visibility), they do not provide the mutual exclusion necessary for complex synchronization. For operations that go beyond the simple reading and writing of a single variable, such as incrementing a counter or checking and modifying multiple variables, synchronized blocks or locks are necessary to prevent race conditions and ensure data integrity.</div>
	<div class="question">Q9. Can a deadlock occur with a single thread?</div>
    <div class="answer">A deadlock typically involves two or more threads, where each thread is waiting for another to release a resource they need. However, a single thread can experience a similar issue called a self-deadlock or resource starvation if it recursively acquires a non-reentrant lock it already holds without releasing it first.</div>
    
    <div class="question">Q10. What is a synchronized collection, and how does it differ from a concurrent collection?</div>
    <div class="answer">A synchronized collection in Java is a standard collection that has been wrapped with synchronization to make it thread-safe. A concurrent collection, like those in java.util.concurrent, is designed for simultaneous access with better performance using finer-grained locking or lock-free mechanisms.</div>
    
    <div class="question">Q11. How does Java handle multi-threading?</div>
    <div class="answer">Java handles multi-threading by allowing multiple threads to run concurrently within a single application using the Thread class and Runnable interface. Java provides built-in support for thread lifecycle management, synchronization, and inter-thread communication.</div>
    
    <div class="question">Q12. What are the differences between Runnable and Callable in Java concurrency?</div>
    <div class="answer">Runnable has a run() method that does not return a result, while Callable includes a call() method that returns a result and can throw checked exceptions, making it more suitable for tasks requiring outcomes.</div>
    
    <div class="question">Q13. How do you handle thread interruption in Java?</div>
    <div class="answer">Thread interruption in Java is handled by checking the interrupted status using Thread.interrupted() or isInterrupted(). A thread should properly clean up resources before stopping execution upon detecting an interruption.</div>
    
    <div class="question">Q14. How do you check if a Thread holds a lock or not?</div>
    <div class="answer">You can check if a thread holds a lock using Thread.holdsLock(Object obj), which returns true if the current thread holds the monitor lock on the specified object.</div>
    
    <div class="question">Q15. What are use cases of ThreadLocal variables in Java?</div>
    <div class="answer">ThreadLocal variables provide thread-specific data storage without synchronization. They are useful for maintaining per-thread user sessions, transaction IDs, or temporary credentials.</div>
    
    <div class="question">Q16. What is the role of ExecutorService in the Executor Framework? What methods does it provide?</div>
    <div class="answer">ExecutorService manages and controls thread execution efficiently. It provides methods such as submit() for executing callable tasks, execute() for running runnable tasks, and shutdown() to stop the executor service gracefully.</div>
	 <div class="question">Q17. What is the difference between submit() and execute() methods in the Executor Framework?</div>
    <div class="answer">In the Java Executor Framework, the submit() and execute() methods both schedule tasks for execution, but they differ in key aspects. The execute() method is used to run Runnable tasks and does not return any result. Conversely, the submit() method can accept both Runnable and Callable tasks, returning a Future object that can be used to retrieve the Callable task’s result or check the status of the Runnable. This makes submit() more flexible and useful for handling tasks that produce results.</div>

    <div class="question">Q18. What is the RejectedExecutionHandler in ThreadPoolExecutor? How can you customize it?</div>
    <div class="answer">The RejectedExecutionHandler in a ThreadPoolExecutor in Java is an interface that handles tasks that cannot be executed by the thread pool, typically when the pool is fully utilized and the task queue is full. You can customize it by implementing this interface and defining your own rejectedExecution method. This method decides what to do with the rejected tasks, such as logging them, running them on a different executor, or implementing a backoff and retry mechanism. This customization allows for more robust handling of task overflows in applications.</div>

    <div class="question">Q19. How does ConcurrentHashMap work internally?</div>
    <div class="answer">The ConcurrentHashMap in Java is designed for concurrent access without the extensive use of synchronization. Internally, it divides the data into segments, effectively a hashtable-like structure. Each segment manages its own lock, reducing contention by allowing multiple threads to concurrently access different segments of the map. This means that read operations can generally be performed without locking, and writes require minimal locking, significantly increasing performance over a Hashtable or synchronized Map under concurrent access scenarios.</div>

    <div class="question">Q20. Difference Between synchronized and ReentrantLock?</div>
    <div class="answer">The synchronized keyword and ReentrantLock both provide locking mechanisms in Java, but they differ in functionality and flexibility. synchronized is easier to use and automatically handles locking and unlocking, but offers less control. In contrast, ReentrantLock provides more advanced features, such as the ability to try to acquire a lock without waiting forever, lock interruptibility, and support for fairness policies. Additionally, ReentrantLock allows multiple condition variables per lock, facilitating more complex synchronization scenarios.</div>

    <div class="question">Q21. What happens when an exception occurs inside a synchronized block?</div>
    <div class="answer">When an exception occurs inside a synchronized block in Java, the lock that was acquired when entering the synchronized block is automatically released. This allows other threads to enter the synchronized block or method once the current thread has exited due to the exception. Essentially, the synchronized mechanism ensures that locks are managed cleanly, even in the event of an exception, preventing deadlocks and allowing program execution to continue in other threads.</div>

    <div class="question">Q22. How do you get a thread dump in Java?</div>
    <div class="answer">To obtain a thread dump in Java, you can use several methods depending on the environment. One common way is to send a SIGQUIT signal by pressing Ctrl+\ in Unix/Linux or Ctrl+Break in Windows on the command line where the Java application is running. Alternatively, you can use tools like jstack with the process ID to generate a thread dump. This tool is part of the JDK and provides detailed information about the threads running in your Java application.</div>

    <div class="question">Q23. How to get a thread dump in Java?</div>
    <div class="answer">To obtain a thread dump in Java, you can use several methods depending on the environment. One common way is to send a SIGQUIT signal by pressing Ctrl+\ in Unix/Linux or Ctrl+Break in Windows on the command line where the Java application is running. Alternatively, you can use tools like jstack with the process ID to generate a thread dump. This tool is part of the JDK and provides detailed information about the threads running in your Java application.</div>

    <div class="question">Q24. What are the different ways to achieve synchronization in Java?</div>
    <div class="answer">In Java, synchronization can be achieved through several methods to ensure thread safety. The primary way is using the synchronized keyword, which can be applied to methods or blocks of code to restrict access to a resource to one thread at a time. Additionally, Java provides volatile variables to ensure visibility of changes to variables across threads. More sophisticated synchronization can involve using classes from the java.util.concurrent package, like ReentrantLock, Semaphore, and CountDownLatch, which offer more control and flexibility than synchronized.</div>

    <div class="question">Q25. What is the difference between synchronized method and synchronized block?</div>
    <div class="answer">In Java, a synchronized method locks the entire method at the object or class level, depending on whether the method is an instance method or static, ensuring that only one thread can access it at a time. In contrast, a synchronized block provides more granular control by only locking a specific section of a method or a specific object, which can minimize waiting times for threads and improve performance by reducing the scope of the lock.</div>

<h2>Collection Framework Basics</h2>

<div class="question">Q1. What is collection framework in Java?</div>
    <div class="answer">The Java Collection Framework is a set of tools that helps us organize, store, and manage groups of data easily. It includes various types of collections like lists, sets, and maps.</div>
    
    <div class="question">Q2. What are the main interfaces of the Java Collection Framework?</div>
    <div class="answer">The main parts of the Java Collection Framework are interfaces like Collection, List, Set, Queue, and Map. Each one helps manage data in different ways.</div>
    
    <div class="question">Q3. Can you explain how Iterator works within the Java Collection Framework?</div>
    <div class="answer">An Iterator is a tool in the Collection Framework that lets you go through a collection's elements one by one.</div>
    
    <div class="question">Q4. What are some common methods available in all Collection types?</div>
    <div class="answer">Some common methods all collection types have are add, remove, clear, size, and isEmpty. These methods let us add and remove items, check the size, and see if the collection is empty.</div>
    
    <div class="question">Q5. How does Java Collection Framework handle concurrency?</div>
    <div class="answer">The Collection Framework deals with multiple threads using special collection classes like ConcurrentHashMap and CopyOnWriteArrayList, which let different parts of our program modify the collection at the same time safely.</div>
    
    <div class="question">Q6. How do you choose the right collection type for a specific problem?</div>
    <div class="answer">To pick the right collection type, think about what we need: List if you want an ordered collection that can include duplicates, Set if you need unique elements, Queue for processing elements in order, and Map for storing pairs of keys and values.</div>
    
    <div class="question">Q7. What enhancements were made to the Java Collection Framework in Java 8?</div>
    <div class="answer">Java 8 made improvements to the Collection Framework by adding Streams, which make it easier to handle collections in bulk, and lambda expressions, which simplify writing code for operations on collections.</div>
    
    <div class="question">Q8. What is the difference between Iterator and ListIterator?</div>
    <div class="answer">Iterator allows forward traversal of a collection, while ListIterator extends Iterator functionality to allow bidirectional traversal of lists and also supports element modification.</div>
    
    <div class="question">Q9. Name of algorithm used by Arrays.sort(..) and Collections.sort(..)?</div>
    <div class="answer">Arrays.sort() uses a Dual-Pivot Quicksort algorithm for primitive types and TimSort for object arrays. Collections.sort() uses TimSort, a hybrid sorting algorithm combining merge sort and insertion sort.</div>
    
    <div class="question">Q10. How do you store elements in a set to preserve insertion order?</div>
    <div class="answer">Use a LinkedHashSet, which preserves the insertion order of elements.</div>
    
    <div class="question">Q11. How do you store elements in a way that they are sorted?</div>
    <div class="answer">Use a TreeSet or a TreeMap, which automatically sorts elements based on their natural ordering or a specified comparator.</div>
    
    <div class="question">Q12. What's the use case of ArrayList, LinkedList, and HashSet?</div>
    <div class="answer"><strong>ArrayList:</strong> Use it when you need efficient random access to elements via indices, like retrieving elements frequently from a list without altering it.</div>
    <div class="answer"><strong>LinkedList:</strong> Use it when you frequently add and remove elements from the beginning or middle of the list, such as implementing queues or stacks.</div>
    <div class="answer"><strong>HashSet:</strong> Use it when you need to ensure that there are no duplicates and require fast lookups, additions, and deletions. It is ideal for scenarios like checking membership existence, such as in a set of unique items or keys.</div>
    
    <div class="question">Q13. How does a HashSet ensure that there are no duplicates?</div>
    <div class="answer">A HashSet in Java uses a HashMap under the hood. Each element you add is treated as a key in this HashMap. Since keys in a HashMap are unique, HashSet automatically prevents any duplicate entries.</div>
	<div class="question">Q13. Can you describe how hashCode() and equals() work together in a collection?</div>
    <div class="answer">hashCode() determines which bucket an object goes into, while equals() checks equality between objects in the same bucket to handle collisions, ensuring that each key is unique.</div>
    
    <div class="question">Q14. Why is it important to override the hashCode method when you override equals? What would be the consequence if we don’t?</div>
    <div class="answer">Overriding hashCode() is crucial because hash-based collections like HashMap and HashSet use the hashcode to locate objects. Without consistent hashCode() and equals(), objects may not be found or stored correctly.</div>
    
    <div class="question">Q15. Can you give an example where a TreeSet is more appropriate than HashSet?</div>
    <div class="answer">A TreeSet is more appropriate than a HashSet when you need to maintain the elements in a sorted order. For example, if we are managing a list of customer names that must be displayed alphabetically, using a TreeSet would be ideal.</div>
    
    <div class="question">Q16. What is the internal implementation of ArrayList and LinkedList?</div>
    <div class="answer">ArrayList is backed by a dynamic array, which provides O(1) access time but requires resizing. LinkedList is implemented as a doubly-linked list, providing O(1) insertion and deletion at both ends but O(n) access time.</div>
    
    <div class="question">Q17. Can you explain the internal working of HashMap in Java?</div>
    <div class="answer">A HashMap in Java stores key-value pairs in an array where each element is a bucket. It uses a hash function to determine which bucket a key should go into for efficient data retrieval. If two keys end up in the same bucket, a collision happens. The HashMap manages these collisions by maintaining a linked list or a balanced tree depending on the Java version in each bucket.</div>
    
    <div class="question">Q18. What happens when two keys have the same hash code? How would you handle this scenario?</div>
    <div class="answer">When two different Java objects have the same hashcode, it's called a hash collision. In this case, Java handles it by storing both objects in the same bucket in a hash-based collection, like a HashMap. It then compares the objects using the equals() method to differentiate them.</div>
    
    <div class="question">Q19. How does a HashMap handle collisions in Java?</div>
    <div class="answer">In Java, when a HashMap encounters a collision (two keys with the same hashcode), it stores both entries in the same bucket. Prior to Java 8, it linked them in a simple list structure. In Java 8, if the number of entries in a bucket grows large, the list is converted to a balanced tree for faster lookups.</div>
    
    <div class="question">Q20. Can you please tell me what changes were done for the HashMap in Java 8?</div>
    <div class="answer">Before Java 8, HashMap dealt with collisions by using a simple linked list. Starting from Java 8, when too many items end up in the same bucket, the list turns into a balanced tree, which helps speed up searching.</div>
    
    <div class="question">Q21. Can we include a class as a key in HashMap?</div>
    <div class="answer">No, as a functional interface allows only a single abstract method. However, a functional interface can inherit another interface if it contains only static and default methods in it.</div>
    
    <div class="question">Q22. Can you please explain ConcurrentHashMap?</div>
    <div class="answer">ConcurrentHashMap is a version of HashMap that's safe to use by many threads at once without needing to lock the entire map. It divides the map into parts that can be locked separately, allowing better performance.</div>
    
    <div class="question">Q23. How does ConcurrentHashMap improve performance in a multi-threaded environment?</div>
    <div class="answer">ConcurrentHashMap boosts performance in multi-threaded settings by letting different threads access and modify different parts of the map simultaneously, reducing waiting times and improving efficiency.</div>
	 <div class="question">Q1. What is collection framework in Java?</div>
    <div class="answer">The Java Collection Framework is a set of tools that helps us organize, store, and manage groups of data easily. It includes various types of collections like lists, sets, and maps.</div>
    
    <div class="question">Q24. What is the time complexity of insertions, deletions, and retrievals in HashSet and HashMap?</div>
    <div class="answer">
        <ul>
            <li><strong>Insertion:</strong></li>
            <ul>
                <li>Average: O(1)</li>
                <li>Worst case: O(n) when rehashing occurs</li>
            </ul>
            <li><strong>Deletion:</strong></li>
            <ul>
                <li>Average: O(1)</li>
                <li>Worst case: O(n) when rehashing occurs</li>
            </ul>
            <li><strong>Retrieval:</strong></li>
            <ul>
                <li>Average: O(1)</li>
                <li>Worst case: O(n) when rehashing occurs (due to hash collisions)</li>
            </ul>
            <p>Note: HashSet and HashMap are not internally sorted.</p>
        </ul>
    </div>
    
    <div class="question">Q25. What is the time complexity of insertions, deletions, and retrievals in TreeSet and TreeMap?</div>
    <div class="answer">O(log n) for operations like insertions, deletions, and retrievals.<br>Note: TreeSet and TreeMap maintain elements in sorted order.</div>
    
    <div class="question">Q26. What techniques do HashMap, TreeMap, HashSet, and TreeSet use internally for performing operations?</div>
    <div class="answer">
        <ul>
            <li><strong>HashMap</strong> uses an array of nodes, where each node is a linked list or a tree depending on collisions and Java versions. From Java 8 onwards, if there are high hash collisions, the linked list gets converted to a balanced tree.</li>
            <li><strong>TreeMap</strong> uses a Red-Black tree, which is a type of self-balancing binary search tree. Each node in the Red-Black tree stores a key-value pair.</li>
            <li><strong>HashSet</strong> internally uses a HashMap.</li>
            <li><strong>TreeSet</strong> internally uses a TreeMap.</li>
        </ul>
    </div>
	<h2>Design Patterns and Principles Basics</h2>

<div class="question">Q1. What is a design pattern in Java and why do we use it?</div>
    <div class="answer">Design patterns are best practices and solutions to common software design problems. They provide a structured approach to coding, improving maintainability, scalability, and reusability.</div>

    <div class="question">Q2. Can you list and explain a few common design patterns used in Java programming?</div>
    <div class="answer">Common design patterns in Java:
        <ul>
            <li><strong>Singleton:</strong> Ensures a class has only one instance, with a global access point.</li>
            <li><strong>Observer:</strong> Allows objects to notify others about changes in their state.</li>
            <li><strong>Factory Method:</strong> Delegates the creation of objects to subclasses, promoting flexibility.</li>
            <li><strong>Builder:</strong> Separates object construction from its representation, making it easier to create complex objects.</li>
        </ul>
    </div>

    <div class="question">Q3. How can design patterns affect the performance of a Java application?</div>
    <div class="answer">Design patterns can introduce slight performance overhead due to abstraction layers, but they enhance modularity, maintainability, and scalability, which are critical for long-term software development.</div>

    <div class="question">Q4. Which design pattern would you use to manage database connections efficiently in a Java application?</div>
    <div class="answer">The <strong>Singleton</strong> pattern is commonly used for managing database connections, ensuring a single shared connection instance is reused efficiently, preventing unnecessary resource consumption.</div>

    <div class="question">Q5. How do you choose the appropriate design pattern for a particular problem in Java?</div>
    <div class="answer">Understanding the problem domain, evaluating common design patterns, and assessing their impact on maintainability, performance, and extensibility help in choosing the right pattern.</div>

    <div class="question">Q6. What is the difference between HashMap and TreeMap?</div>
    <div class="answer">HashMap stores key-value pairs without ordering, providing O(1) lookup time in ideal cases. TreeMap, on the other hand, maintains keys in sorted order and has a time complexity of O(log n) for operations.</div>

    <div class="question">Q7. In what scenarios would you prefer to use a TreeMap over a HashMap?</div>
    <div class="answer">Use TreeMap when you need to maintain a sorted order of keys, such as implementing a navigation system or a ranking system. HashMap is preferable for fast, unordered key-value lookups.</div>

    <div class="question">Q8. Can we add objects as keys in a TreeMap?</div>
    <div class="answer">Yes, objects can be used as keys in a TreeMap if they implement the <strong>Comparable</strong> interface or a custom <strong>Comparator</strong> is provided to define the sorting logic.</div>
	
	<div class="question">Q9. What are SOLID Principles?</div>
<div class="answer">
    <ul>
        <li><strong>S - Single Responsibility Principle:</strong> A class should have only one reason to change, meaning it should handle only one functionality.<br>
            <em>Example:</em> A class <code>VehicleRegistration</code> should only handle vehicle registration details. If it also manages vehicle insurance, it violates this principle.
        </li>
        <li><strong>O - Open/Closed Principle:</strong> Classes should be open for extension but closed for modification.<br>
            <em>Example:</em> A <code>VehicleService</code> class providing maintenance services should allow extension through subclasses like <code>ElectricVehicleService</code> without modifying the original class.
        </li>
        <li><strong>L - Liskov Substitution Principle:</strong> Subtypes must be substitutable for their base types without altering the correctness of the program.<br>
            <em>Example:</em> A superclass <code>Vehicle</code> with a method <code>startEngine()</code> should allow substitution with subclasses like <code>Car</code> and <code>ElectricCar</code> without breaking the system.
        </li>
        <li><strong>I - Interface Segregation Principle:</strong> Clients should not be forced to depend on interfaces they do not use; large interfaces should be split into smaller ones.<br>
            <em>Example:</em> Instead of one large interface <code>VehicleOperations</code> with methods like <code>drive()</code>, <code>refuel()</code>, <code>charge()</code>, and <code>navigate()</code>, split it into focused interfaces like <code>Drivable</code>, <code>Refuelable</code>, and <code>Navigable</code>.
        </li>
        <li><strong>D - Dependency Inversion Principle:</strong> High-level modules should depend on abstractions rather than concrete implementations.<br>
            <em>Example:</em> A <code>VehicleTracker</code> class that logs vehicle positions should interact through a <code>GPSDevice</code> interface instead of depending directly on a specific GPS device model.
        </li>
    </ul>
</div>

<h2>Miscellaneous questions </h2>
<div class="question">Q1. What is transient?</div>
<div class="answer">
    The <code>transient</code> keyword in Java is used to indicate that a field should not be serialized. This means it will be ignored when objects are serialized and deserialized.
</div>

<div class="question">Q2. Can we create a server in a Java application without using Spring or any other framework?</div>
<div class="answer">
    Yes, you can create a server in a Java application using only Java SE APIs, such as by utilizing the <code>ServerSocket</code> class for a simple TCP server or the <code>HttpServer</code> class for HTTP services.
</div>

<div class="question">Q3. What is the Exchanger class?</div>
<div class="answer">
    The <code>Exchanger</code> class in Java is a synchronization point at which threads can pair and swap elements within pairs. Each thread presents some object on exchange and receives another object in return from another thread.
</div>

<div class="question">Q4. What is reflection in Java?</div>
<div class="answer">
    Reflection in Java is a capability to inspect and modify the runtime behavior of applications. It allows programs to manipulate internal properties of classes, methods, and interfaces, and dynamically call them at runtime.
</div>

<div class="question">Q5. What is the difference between weak reference and soft reference in Java?</div>
<div class="answer">
    Weak references in Java are garbage collected when no strong references exist. Soft references are only cleared at the discretion of the garbage collector, typically when memory is low.
</div>

<div class="question">Q6. What is Java Flight Recorder?</div>
<div class="answer">
    Java Flight Recorder (JFR) is a tool for collecting diagnostic and profiling data about a running Java application without significant performance overhead.
</div>

<div class="question">Q7. Discuss Java Generics.</div>
<div class="answer">
    Generics provide type safety by allowing classes and methods to operate on objects of specific types, preventing runtime <code>ClassCastException</code> and reducing code duplication.
</div>

<div class="question">Q8. What is the difference between Young Generation and Old Generation memory spaces?</div>
<div class="answer">
    The Young Generation stores newly created objects. The Old Generation holds objects that have survived several garbage collection cycles in the Young Generation.
</div>

 <h2>Exception Handling </h2>
 
<div class="question">Q1. What happens when an exception is thrown in a static initialization block?</div>
<div class="answer">
    When an exception is thrown in a static initialization block in Java, it prevents the class from being loaded properly. This results in a <code>java.lang.ExceptionInInitializerError</code>. If an attempt is made to use the class afterwards, the JVM will throw a <code>NoClassDefFoundError</code> because the class initialization previously failed. This mechanism ensures that no class is used unless it has been correctly and fully initialized.
</div>

<div class="question">Q2. Provide an example of when you would purposely use a checked exception over an unchecked one.</div>
<div class="answer">
    You would purposely use a checked exception when you want to enforce error handling by the caller of a method. For instance, in situations where a method deals with reading from a file or querying a database, you might use a checked exception like <code>IOException</code> or <code>SQLException</code>. These exceptions alert the developer that there must be logic to handle these potential issues, ensuring that such problems are acknowledged and addressed at compile time, preventing overlooked errors that could occur at runtime.
</div>

<div class="question">Q3. Have you ever used a finally block? If yes, can you provide a scenario where you have used it?</div>
<div class="answer">
    In Java, a <code>finally</code> block is crucial for resource management, ensuring resources like streams, connections, or files are properly closed regardless of whether an exception occurs. For example, when working with file handling, even if an <code>IOException</code> occurs, the <code>finally</code> block ensures that the file stream is closed to avoid resource leaks, thus maintaining system stability and performance.
</div>

<div class="question">Q4. Was there ever a time when the finally block caused any unexpected behavior or side effects?</div>
<div class="answer">
    A <code>finally</code> block in Java generally executes reliably, but unexpected behavior can arise if a new exception is thrown within the <code>finally</code> block itself. For instance, if an exception occurs while closing a resource in the <code>finally</code> block, it can obscure an exception that was thrown in the <code>try</code> block, leading to the loss of the original exception's details. This is why it's essential to handle exceptions within the <code>finally</code> block carefully to prevent such issues.
</div>

<div class="question">Q5. What is a deadlock in multithreading? How can you prevent it?</div>
<div class="answer">
    A deadlock in multithreading occurs when two or more threads are each waiting for the other to release a resource they need to continue, resulting in all involved threads being blocked indefinitely. To prevent deadlocks, ensure that all threads acquire locks in a consistent order, avoid holding multiple locks if possible, and use timeout options with lock attempts. Another strategy is to use a lock hierarchy or a try-lock method to manage resources dynamically without stalling.
</div>

<div class="question">Q6. What issues might arise when both method overloading and overriding are used in the same class hierarchy?</div>
<div class="answer">
    Using both method overloading and overriding in the same class hierarchy can lead to confusion and errors in Java. Overloading methods within a class allows multiple methods with the same name but different parameters. Overriding changes the behavior of a method in a subclass. When these concepts are combined, it can be unclear whether a method call is invoking an overloaded method or an overridden one, especially if the signatures are similar. This ambiguity can make the code harder to read and maintain, and increase the likelihood of bugs.
</div>

<div class="question">Q7. Why might it be bad practice to catch Throwable?</div>
<div class="answer">
    Catching <code>Throwable</code> in Java is generally considered bad practice because <code>Throwable</code> is the superclass of all errors and exceptions. Catching it means catching both <code>Exception</code> and <code>Error</code> classes. Errors, such as <code>OutOfMemoryError</code> or <code>StackOverflowError</code>, are typically serious problems that a normal application should not attempt to handle because they are often related to system-level issues. Catching <code>Throwable</code> may prevent the propagation of errors that should naturally cause the program to terminate, potentially leading to system instability or corrupting application state.
</div>




</body>
</html>

<h1 style="background-color: blue;">Paper 3</h1>


<div class="question">Q1. Describe a scenario where you used a PriorityQueue, and explain why it was chosen over other types of queues.</div>
<div class="answer">
    I used a <code>PriorityQueue</code> in a scenario where I needed to manage tasks by their priority, not just by the order they arrived. This type of queue helped in automatically sorting tasks such that the most critical ones were handled first. Unlike regular queues that process tasks in the order they come (FIFO), <code>PriorityQueue</code> sorts them based on their urgency, making it ideal for situations where some tasks are more important than others.
</div>

<div class="question">Q2. What are enums in Java and how are they useful?</div>
<div class="answer">
    Enums in Java are special types used to define a set of fixed constants, like days of the week or directions (<code>NORTH</code>, <code>SOUTH</code>, etc.). They are useful because they make the code more readable and prevent errors by limiting the possible values for a variable. Instead of using random numbers or strings, enums ensure only predefined values are used, improving code clarity and safety.
</div>

<div class="question">Q3. What is the Builder Pattern in Java? How is it different from the Factory Pattern?</div>
<div class="answer">
    The <code>Builder Pattern</code> in Java is used to construct complex objects step by step, allowing different parts of an object to be built independently and then assembled as a final step. It's different from the <code>Factory Pattern</code>, which is used to create objects without exposing the creation logic to the client. The <code>Builder Pattern</code> gives more control over the construction process, whereas the <code>Factory Pattern</code> focuses on creating a finished object in a single step.
</div>

<div class="question">Q4. What is the impact of declaring a method as final on inheritance?</div>
<div class="answer">
    Declaring a method as <code>final</code> in Java prevents it from being overridden in any subclass. This is useful when you want to ensure that the functionality of a method remains consistent and unchanged, regardless of inheritance. It provides a safeguard that the method will behave the same way, even in derived classes, maintaining the original behavior and preventing any alteration or unexpected behavior in the program.
</div>

<div class="question">Q5. Can method overloading be determined at runtime?</div>
<div class="answer">
    No, method overloading cannot be determined at runtime; it is resolved at compile-time. Method overloading occurs when multiple methods have the same name but different parameters within the same class. The compiler determines which method to use based on the method signature (method name and parameter types) when the code is compiled. This is unlike method overriding, where the method to execute is determined at runtime based on the object’s actual class type.
</div>

<div class="question">Q6. How does Java resolve a call to an overloaded method?</div>
<div class="answer">
    Java resolves a call to an overloaded method at compile time by looking at the method signature, which includes the method name and the types and number of parameters. The compiler matches the arguments used in the method call to the parameters of the defined methods. It selects the most specific method that fits the arguments provided. If there's no exact match or it's ambiguous, the compiler will throw an error.
</div>

<div class="question">Q7. What is the diamond operator, and how does it work?</div>
<div class="answer">
    The diamond operator (<code>&lt;&gt;</code>) in Java, introduced in Java 7, simplifies the notation of generics by reducing the need to duplicate generic type parameters. For instance, instead of writing <code>List&lt;String&gt; list = new ArrayList&lt;String&gt;();</code>, you can use the diamond operator: <code>List&lt;String&gt; list = new ArrayList&lt;&gt;();</code>. The compiler infers the type parameter <code>String</code> for the <code>ArrayList</code> based on the variable's declared type, making the code cleaner and easier to read.
</div>

<div class="question">Q8. Explain inner classes in Java.</div>
<div class="answer">
    Inner classes in Java are classes defined within another class. They are useful for logically grouping classes that will only be used in one place, increasing encapsulation. Inner classes have access to the attributes and methods of the outer class, even if they are declared private. There are several types: non-static nested classes (inner classes), static nested classes, local classes (inside a method), and anonymous classes (without a class name). Each type serves different purposes based on the specific need for grouping and scope control.
</div>

<div class="question">Q9. Can inner classes have static declarations?</div>
<div class="answer">
    Inner classes in Java can have static declarations if they are themselves declared as <code>static</code>. These static nested classes can contain static methods, fields, or blocks. However, non-static inner classes, which are associated with an instance of the outer class, cannot contain any static members. The reason is that static members belong to the class rather than an instance, and non-static inner classes are intimately linked to the outer class's instance.
</div>

<div class="question">Q10. What is the significance of an anonymous inner class?</div>
<div class="answer">
    Anonymous inner classes in Java are useful when you need to implement an interface or extend a class without creating a separate named class. They are defined and instantiated all at once, typically at the point of use. This is particularly helpful for handling events or creating runnable objects in GUI applications with minimal code. By using anonymous inner classes, developers can make their code more concise and focused on specific tasks.
</div>

<div class="question">11) What do you think Java uses: pass by value or pass by reference?</div>
<div class="answer">Java uses pass by value. This means when you pass a variable to a method, Java copies the actual value of an argument into the formal parameter of the function. For primitive types, Java copies the actual values, while for objects, Java copies the value of the reference to the object. Therefore, changes made to the parameter inside the method do not affect the original value outside the method.</div>

<div class="question">12) What are the differences between implementing Runnable and extending Thread in Java?</div>
<div class="answer">In Java, implementing the Runnable interface and extending the Thread class are two ways to create a thread, but they serve different purposes. Implementing Runnable is generally preferred as it allows a class to extend another class while still being able to run in a thread, promoting better object-oriented design and flexibility. Extending Thread makes a class unable to extend any other class due to Java's single inheritance limitation, but it can be simpler for straightforward scenarios.</div>

<div class="question">13) What is a marker interface?</div>
<div class="answer">A marker interface in Java is an interface with no methods or fields. It serves to provide runtime information to objects about what they can do. Essentially, it "marks" a class with a certain property, allowing the program to use instanceof checks to trigger specific behavior based on the presence of the marker. Examples include Serializable and Cloneable, which indicate that a class is capable of serialization or cloning, respectively.</div>

<div class="question">14) Can you provide a scenario where creating a custom marker interface would be beneficial?</div>
<div class="answer">Creating a custom marker interface can be beneficial in scenarios where you want to enforce a special handling or policy for certain classes without adding any actual methods. For example, consider a security system where only certain data objects can be transmitted over a network. You could define a marker interface like Transmittable. By implementing this interface in certain classes, you can use instanceof to check and ensure that only objects of these classes are transmitted, enhancing security controls.</div>

<div class="question">15) How does Java determine which method to call in the case of method overloading?</div>
<div class="answer">In the case of method overloading, Java determines which method to call based on the method's signature. This includes the method name and the number and types of parameters. The compiler looks at the arguments passed during the method call and matches them to the method that has the corresponding parameter types. If it finds an exact match, it executes that method. If it doesn’t find a match or if the call is ambiguous, it results in a compile-time error.</div>

<div class="question">16) What happens if two packages have the same class name?</div>
<div class="answer">If two packages in Java contain a class with the same name, you can still use both classes in your program, but you must manage them carefully to avoid naming conflicts. To differentiate between the two, you should use the fully qualified name of the classes, which includes the package name followed by the class name, in your code. For example, package1.ClassName and package2.ClassName. This approach clarifies which class you intend to use from each package.</div>

<div class="question">17) How do you access a package-private class from another package?</div>
<div class="answer">In Java, a package-private class, which is declared without any access modifiers, is only accessible within the same package. To access such a class from another package, you cannot do so directly due to its limited visibility. The typical solution involves changing the access level of the class to public, making it accessible from other packages. Alternatively, you can add methods or classes within the same package that can access the package-private class and expose its functionality publicly or through interfaces.</div>

<div class="question">18) Can you modify a final object reference in Java?</div>
<div class="answer">In Java, when you declare an object reference as final, you cannot change the reference to point to a different object after it has been assigned. However, the object itself can still be modified if it is mutable. This means that while you can't reassign the final reference to a new object, you can change the object's properties or state. For instance, you can add items to a final list but cannot reassign it to another list.</div>

<div class="question">19) What is the default access modifier if none is specified?</div>
<div class="answer">In Java, if no access modifier is specified for a class member (like fields or methods), it defaults to package-private. This means that the member is accessible only within classes that are in the same package. This default access level provides a moderate level of protection within the package and is less restrictive than private, but more restrictive than protected or public, preventing access from outside the package.</div>

<div class="question">20) What are the potential issues with using mutable objects as keys in a HashMap?</div>
<div class="answer">Using mutable objects as keys in a HashMap can lead to significant issues. If the object’s state changes after it’s been used as a key, its hashcode can change, making it impossible to locate in the map even though it's still there. This results in a loss of access to that entry, effectively causing data loss and potential memory leaks. Therefore, it's best to use immutable objects as keys to maintain consistent behavior and reliable access.</div>

<div class="question">21) What would happen if you override only the equals() method and not hashCode() in a custom key class used in HashMap?</div>
<div class="answer">If you override only the equals() method without overriding hashCode() in a custom key class used in a HashMap, you'll run into problems. Java requires that equal objects must have the same hash code. If they don’t, the HashMap might not find the object even though it's there. This inconsistency can lead to duplicate keys and unpredictable behavior, as the HashMap uses the hash code to locate keys. Always override both methods to ensure correct behavior.</div>

<div class="question">22) What is the difference between HashMap and IdentityHashMap in terms of how they handle keys?</div>
<div class="answer">The main difference between HashMap and IdentityHashMap is how they handle key comparison. HashMap uses the equals() method and hashCode() to determine if two keys are the same, which checks for logical equality. In contrast, IdentityHashMap uses == for key comparison, which checks for reference equality. This means IdentityHashMap considers two keys equal only if they are exactly the same object, not merely equal objects. This makes IdentityHashMap suitable for identity-based key operations.</div>

<div class="question">23) How does Collections.sort() work internally?</div>
<div class="answer">Internally, Collections.sort() in Java uses a modified version of the MergeSort algorithm known as TimSort. This algorithm is efficient and stable, meaning it preserves the order of equal elements. It breaks the list into smaller parts, sorts each part, and then merges them back together in sorted order, ensuring that the overall list is ordered. This method is optimized for performance and reliability, making it suitable for sorting both primitive types and objects based on natural ordering or a specified comparator.</div>

<div class="question">24) What would happen if you try to sort a list containing null elements using Collections.sort()?</div>
<div class="answer">If you try to sort a list containing null elements using Collections.sort(), it will throw a NullPointerException. This method requires all elements in the list to be non-null and comparable. Null elements lack a comparison order, which prevents Collections.sort() from determining their position relative to other elements. To sort such lists, you must either remove null elements or use a custom comparator that explicitly handles nulls.</div>

<div class="question">25) Can you sort a list of custom objects using Collections.sort() without providing a Comparator?</div>
<div class="answer">Yes, you can sort a list of custom objects using Collections.sort() without providing a Comparator, but only if the custom objects implement the Comparable interface. This interface requires defining a compareTo method, which specifies the natural ordering of the objects. If the objects do not implement Comparable, or if the compareTo method is not implemented, attempting to sort without a Comparator will result in a ClassCastException.</div>

<div class="question">26) What is the difference between using Collections.sort() and Stream.sorted() in Java 8+?</div>
<div class="answer">The difference between Collections.sort() and Stream.sorted() in Java 8+ lies in how they handle data and output. Collections.sort() modifies the list it sorts directly, changing the original data structure. On the other hand, Stream.sorted() operates on a stream of data and returns a new sorted stream without altering the original source. This makes Stream.sorted() more flexible and suitable for functional programming styles, as it supports chain operations and doesn't affect the original data.</div>

<div class="question">27) Can an enum extend another class in Java?</div>
<div class="answer">No, an enum in Java cannot extend another class. In Java, all enums implicitly extend the java.lang.Enum class, and since Java does not support multiple inheritance for classes, an enum cannot extend any other class. However, enums can implement interfaces, allowing them to include additional functionality beyond the basic enum capabilities. This provides a way to enhance the functionality of enums without the need for class inheritance.</div>

<div class="question">28) How do you iterate over all values of an enum?</div>
<div class="answer">To iterate over all values of an enum in Java, you can use the values() method, which returns an array of all enum constants in the order they're declared. You can then loop through this array using a for-each loop. Here’s how it works: for each constant in the enum, you perform the desired operation. This method is straightforward and efficient for accessing and manipulating each constant in an enum type.</div>

<div class="question">29) Can you serialize static fields in Java?</div>
<div class="answer">No, you cannot serialize static fields in Java. Serialization in Java is designed to capture the state of an object, and static fields are not part of any individual object's state. Instead, static fields belong to the class itself, shared among all instances. When an object is serialized, only the object's instance variables are saved, while static fields are ignored. This ensures that the class's shared state remains consistent and is not duplicated with each object's serialization.</div>

<div class="question">30) What happens if an exception is thrown during the serialization process?</div>
<div class="answer">If an exception is thrown during the serialization process in Java, the serialization fails, and the state of the object being serialized is not saved. Typically, a NotSerializableException is thrown if an object does not support serialization (i.e., it does not implement the Serializable interface). Other exceptions can include IOException for input/output issues. These exceptions prevent the object from being properly converted into a byte stream, disrupting the storage or transmission of its state.</div>

<div class="question">31) What happens if your Serializable class contains a member which is not serializable? How do you fix it?</div>
<div class="answer">If your Serializable class contains a member that is not serializable, you'll encounter a NotSerializableException when you try to serialize the class. To fix this, you can either make the non-serializable member transient, which means it won't be included in the serialization process, or ensure that the member class also implements the Serializable interface. Alternatively, you can customize the serialization process by providing your own writeObject and readObject methods that handle the non-serializable member appropriately.</div>

<div class="question">32) What is Type Erasure?</div>
<div class="answer">Type Erasure in Java refers to the process by which the Java compiler removes generic type information from your code after it compiles it, enforcing generic constraints only at compile time and not at runtime. This means that generic type information is not available during the execution of the program. For example, a List<Integer> and a List<String> are just treated as List. This approach helps maintain backward compatibility with older Java versions that do not support generics.</div>

<div class="question">33) What is a generic type inference?</div>
<div class="answer">Generic type inference in Java is a feature that allows the Java compiler to automatically determine, or infer, the types of generic arguments that are necessary for method calls and expressions. This means you don't always have to explicitly specify the generic types when you're coding, which simplifies your code. For example, when you use the diamond operator (<>) with collections, the compiler can infer the type of the elements in the collection from the context.</div>

<div class="question">34) Why can’t we create an array of generic types in Java?</div>
<div class="answer">In Java, you cannot create an array of generic types because generics do not maintain their type information at runtime due to type erasure. This means that the Java compiler removes all information related to type parameters and type arguments within a generic at runtime. Arrays, however, need concrete type information at runtime to ensure type safety, which isn't possible with erased generic types. This mismatch prevents the creation of generic arrays to avoid runtime type errors.</div>

<div class="question">35) How Are Strings Represented in Memory?</div>
<div class="answer">In Java, strings are represented in memory as objects of the String class, which internally uses a character array to store the string data. Each String object is immutable, meaning once it is created, it cannot be changed. To optimize memory usage, Java maintains a special area called the "String Pool" where literals are stored. If you create a string that already exists in the pool, Java reuses the existing string instead of creating a new one, reducing memory overhead.</div>

<div class="question">36) What is the difference between Lambda vs. Anonymous Classes?</div>
<div class="answer">Lambda expressions and anonymous classes in Java both provide ways to implement methods from a functional interface, but they do so differently. Lambdas are more concise and focused on passing behavior or functionality, often written in a single line of code without a name. Anonymous classes, on the other hand, are more verbose, require a class declaration, and can be used to create instances of interfaces or abstract classes with methods. Lambdas generally lead to clearer, more readable code compared to anonymous classes.</div>

<div class="question">37) Explain the difference between Stream API map and flatMap?</div>
<div class="answer">In Java's Stream API, map and flatMap are functions used for transforming streams. map applies a function to each element of a stream and collects the results in a new stream. For example, converting each string in a stream to its upper case. On the other hand, flatMap is used when each element of the stream is a stream itself, or can be converted into a stream. It "flattens" all these streams into a single stream. For instance, converting a stream of lists into a stream of elements.</div>

<div class="question">38) Explain the difference between peek() and map(). In what scenarios should peek() be used with caution?</div>
<div class="answer">In Java's Stream API, peek() and map() both operate on elements of a stream, but they serve different purposes. map() transforms each element and returns a new stream containing the transformed elements. peek(), on the other hand, is mainly for debugging and allows you to perform operations on each element without altering them, returning the same stream. Caution is advised with peek() because its side effects can be unpredictable if used for purposes other than debugging, such as altering the state of objects, which can lead to inconsistent results in the stream's pipeline execution.</div>

<div class="question">39) How do imports affect compilation and class loading?</div>
<div class="answer">Imports in Java simplify code by allowing you to refer to classes from other packages without using their fully qualified names. During compilation, the import statements help the compiler locate and recognize these classes, but they don't affect performance or class loading. Class loading occurs at runtime when a class is first used, regardless of whether it's imported. Imports don't increase memory usage or slow down the program—they simply make the code more readable and organized.</div>

<div class="question">40) What is the difference between Import and Static Imports?</div>
<div class="answer">The difference between import and static import in Java lies in what they bring into scope. Regular import is used to access classes from other packages without using their fully qualified names, making code cleaner. Static imports, introduced in Java 5, allow direct access to static members (fields and methods) of a class without qualifying them with the class name. This is useful when you need frequent access to static methods, like Math.sqrt() or constants like PI, simplifying the code.</div>


<div class="question">41) What is the impact of static imports on code readability and maintainability?</div>
<div class="answer">Static imports can improve code readability by reducing repetitive class references, making the code more concise. For example, instead of writing Math.PI, you can just use PI. However, overusing static imports can harm maintainability, as it becomes harder to know where methods or constants are coming from, especially in larger projects. The lack of clarity can confuse developers unfamiliar with the code, so static imports should be used sparingly and wisely.</div>

<div class="question">42) How to choose initial capacity in an ArrayList constructor in a scenario where the list is repeatedly cleared and reused?</div>
<div class="answer">When choosing the initial capacity of an ArrayList in a scenario where the list is repeatedly cleared and reused, it's best to base it on the expected maximum size of the list during its heaviest use. This avoids frequent resizing and reallocations, which are costly. Setting the capacity slightly higher than the typical maximum size ensures that the list has enough space without frequent expansions, leading to better performance and memory management.</div>

<div class="question">43) Can you tell me an example of how objects and classes interact in a real-world application?</div>
<div class="answer">In a real-world banking application, a Customer class defines attributes like name and account number. When a user opens an account, an object of the Customer class is created with specific values. These objects interact with methods like deposit, withdraw, and check balance, encapsulating the behavior and data of the customer.</div>

<div class="question">44) Scenario-Based: How would you handle a situation where you need to compare the content equality of two custom object instances?</div>
<div class="answer">To compare the content equality of two custom object instances, override the equals() method in the class. Inside the method, compare the object's fields (like ID, name, or other properties). This ensures that two objects with identical values are considered equal, even if their references differ.</div>

<div class="question">45) Scenario-Based: Suppose you're storing user session data in a HashMap. How would you ensure thread safety?</div>
<div class="answer">To ensure thread safety when storing user session data in a HashMap, you can use Collections.synchronizedMap() to wrap the HashMap, making it thread-safe by synchronizing access to it. Alternatively, for better performance in highly concurrent environments, you can use ConcurrentHashMap, which provides thread safety with less locking overhead by allowing concurrent reads and controlled updates. This ensures that multiple threads can safely access and modify the session data.<br>
Example:<br>
Map&lt;String, SessionData&gt; sessionMap = new ConcurrentHashMap&lt;&gt;();</div>

<div class="question">46) Can an interface with multiple default methods still be a functional interface?</div>
<div class="answer">No, an interface with multiple default methods cannot be a functional interface. A functional interface is defined as an interface with only one abstract method, which allows it to be used with lambda expressions. Default methods are concrete (non-abstract), so having multiple default methods is fine, but as long as there's only one abstract method, the interface can still be functional. Multiple abstract methods would disqualify it as a functional interface.</div>

<div class="question">47) How does TreeSet sort elements when it stores objects and not wrapper classes?</div>
<div class="answer">When a TreeSet stores objects that are not wrapper classes, it uses natural ordering provided by the object's Comparable implementation, if the class implements the Comparable interface. The compareTo() method in the object defines how to sort the elements. Alternatively, if the objects don't implement Comparable, you can provide a custom Comparator when creating the TreeSet, which specifies how the elements should be ordered. Without this, trying to store unsorted objects would result in a runtime error.</div>

<div class="question">48) Can an enum extend another class in Java?</div>
<div class="answer">No, an enum in Java cannot extend another class. All enums implicitly extend java.lang.Enum, and since Java doesn't allow multiple inheritance for classes, an enum cannot extend any other class. However, an enum can implement interfaces to gain additional functionality. This limitation ensures that enums remain simple, specialized types that represent fixed sets of constants, while still allowing some flexibility through interfaces.</div>

<div class="question">49) How do you iterate over all values of an enum?</div>
<div class="answer">In Java, you can easily iterate over all the values of an enum using a for-each loop. First, use the values() method provided by the enum. This method returns an array containing all the values of the enum in the order they're declared. Then, use a for-each loop to go through each element in this array. Here, you treat each enum value as an element of the array and perform any operations inside the loop.</div>

<div class="question">50) How does TreeSet sort elements when it stores objects and not wrapper classes?</div>
<div class="answer">In Java, a TreeSet sorts objects based on natural ordering or a custom comparator. For natural ordering, the class of the objects stored in the TreeSet must implement the Comparable interface. This interface requires a method called compareTo that defines the order. If the objects don't have natural ordering, you can provide a Comparator when creating the TreeSet, specifying how to compare and sort the objects.</div>

<div class="question">51) Suppose you have multiple interfaces with default methods that a class implements. How would you resolve method conflicts?</div>
<div class="answer">When a class implements multiple interfaces that have default methods with the same signature, you must resolve the conflict by overriding the method in your class. In the overridden method, you can explicitly choose which interface's default method to use by using the syntax InterfaceName.super.methodName(). This tells your class exactly which version of the conflicting method to execute, thus resolving the ambiguity.</div>

<div class="question">52) How do JVM optimizations affect the performance of Java applications?</div>
<div class="answer">JVM optimizations significantly enhance the performance of Java applications by improving execution efficiency. The JVM uses techniques like Just-In-Time (JIT) compilation, which converts Java bytecode into native machine code that runs faster on the processor. It also employs methods like garbage collection optimization and inlining functions to reduce memory usage and execution time. These optimizations help Java programs run faster and more smoothly, making efficient use of system resources.</div>

<div class="question">53) Can ‘this’ be used in a static method or block?</div>
<div class="answer">No, the keyword this cannot be used in a static method or block in Java. The reason is that this refers to the current instance of a class, and static methods or blocks do not belong to any instance but to the class itself. Since static methods can be called without creating an instance of the class, there's no this context available in static contexts.</div>

<div class="question">54) Explain Java Class Loader.</div>
<div class="answer">The Java Class Loader is a part of the Java Runtime Environment that dynamically loads Java classes into the Java Virtual Machine. It does this when the class is needed for the first time, not at program start, enhancing efficiency. Java uses multiple class loaders in a hierarchy: Bootstrap, Extension, and System/Application. This mechanism helps in separating the namespace of the classes loaded by different class loaders, preventing conflicts.</div>

<div class="question">55) Is it possible to unload a class in Java?</div>
<div class="answer">In Java, directly unloading a class is not possible as Java does not provide explicit control over the unloading of classes. However, a class can be unloaded when its class loader is garbage collected. This happens if there are no active references to the class and its class loader from any part of the program. Essentially, for a class to be eligible for unloading, all instances of the class and the class loader itself must no longer be in use.</div>

<div class="question">56) How does class loading affect memory usage?</div>
<div class="answer">Class loading in Java affects memory usage by increasing it each time a class is loaded into the JVM. Each class needs memory for its metadata, methods, and associated objects. This loading is necessary for the JVM to use the class, but if many classes are loaded, or large libraries are in use, memory consumption can increase significantly. Proper management of class loaders can help in optimizing memory usage, especially in large applications.</div>

<div class="question">57) Can you serialize static fields in Java?</div>
<div class="answer">In Java, static fields are not serialized. Serialization in Java is focused on saving the state of an object, and static fields are part of the class state, not individual object state. Therefore, static fields are common to all instances of the class and remain unchanged based on individual object serialization. When you deserialize an object, the static fields will have the values set by the current running program or their initial values as defined in the class.</div>

<div class="question">58) What is the role of ExecutorService in the Executor Framework? What methods does it provide?</div>
<div class="answer">The ExecutorService in the Java Executor Framework plays a crucial role in managing and controlling thread execution. It provides a higher-level replacement for working directly with threads, offering methods to manage lifecycle operations like starting, running, and stopping threads efficiently. Some key methods it provides include submit() for executing callable tasks that return a result, execute() for running runnable tasks, and shutdown() to stop the executor service gracefully once tasks are completed.</div>
 <script>
        function showTab(tabId) {
            var tabs = document.querySelectorAll('.tab');
            tabs.forEach(tab => tab.classList.remove('active'));
            document.getElementById(tabId).classList.add('active');
        }
    </script>
       
</body>
</html>
